{
    "sourceFile": "main.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 48,
            "patches": [
                {
                    "date": 1750487296904,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750487412783,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,440 +0,0 @@\n-import cv2\r\n-import numpy as np\r\n-import time\r\n-import os\r\n-import subprocess\r\n-import threading\r\n-import tkinter as tk\r\n-from tkinter import ttk, filedialog, scrolledtext\r\n-from PIL import Image, ImageTk\r\n-import pyautogui\r\n-\r\n-class YokaiWatchAutoGUI:\r\n-    def __init__(self, root):\r\n-        self.root = root\r\n-        self.root.title(\"妖怪ウォッチぷにぷに自動周回ソフト\")\r\n-        self.root.geometry(\"800x600\")\r\n-        self.root.resizable(True, True)\r\n-        \r\n-        # アプリケーション状態\r\n-        self.running = False\r\n-        self.paused = False\r\n-        self.stage_45_detected = False\r\n-        self.puzzle_tapped_count = 0\r\n-        self.adb_path = \"\"\r\n-        self.images_path = \"\"\r\n-        self.images = {\r\n-            \"boss\": None,\r\n-            \"play\": None,\r\n-            \"puzzle\": None,\r\n-            \"waza_ok\": None,\r\n-            \"next\": None,\r\n-            \"close\": None,\r\n-            \"close_mini\": None,\r\n-            \"stage_45\": None\r\n-        }\r\n-        \r\n-        # メインフレームの作成\r\n-        self.main_frame = ttk.Frame(self.root, padding=10)\r\n-        self.main_frame.pack(fill=tk.BOTH, expand=True)\r\n-        \r\n-        # 設定フレーム\r\n-        self.setup_settings_frame()\r\n-        \r\n-        # コントロールフレーム\r\n-        self.setup_control_frame()\r\n-        \r\n-        # ログフレーム\r\n-        self.setup_log_frame()\r\n-        \r\n-        # ステータスバー\r\n-        self.status_var = tk.StringVar()\r\n-        self.status_var.set(\"準備完了\")\r\n-        self.status_bar = ttk.Label(self.root, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)\r\n-        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)\r\n-    \r\n-    def setup_settings_frame(self):\r\n-        settings_frame = ttk.LabelFrame(self.main_frame, text=\"設定\", padding=10)\r\n-        settings_frame.pack(fill=tk.X, pady=5)\r\n-        \r\n-        # ADBパス設定\r\n-        ttk.Label(settings_frame, text=\"ADBパス:\").grid(row=0, column=0, sticky=tk.W, pady=5)\r\n-        self.adb_path_var = tk.StringVar()\r\n-        adb_entry = ttk.Entry(settings_frame, textvariable=self.adb_path_var, width=50)\r\n-        adb_entry.grid(row=0, column=1, sticky=tk.W, pady=5)\r\n-        ttk.Button(settings_frame, text=\"参照\", command=self.browse_adb).grid(row=0, column=2, sticky=tk.W, pady=5, padx=5)\r\n-        \r\n-        # 画像フォルダ設定\r\n-        ttk.Label(settings_frame, text=\"画像フォルダ:\").grid(row=1, column=0, sticky=tk.W, pady=5)\r\n-        self.images_path_var = tk.StringVar()\r\n-        images_entry = ttk.Entry(settings_frame, textvariable=self.images_path_var, width=50)\r\n-        images_entry.grid(row=1, column=1, sticky=tk.W, pady=5)\r\n-        ttk.Button(settings_frame, text=\"参照\", command=self.browse_images).grid(row=1, column=2, sticky=tk.W, pady=5, padx=5)\r\n-        \r\n-        # 一致率設定\r\n-        ttk.Label(settings_frame, text=\"一致率しきい値:\").grid(row=2, column=0, sticky=tk.W, pady=5)\r\n-        self.threshold_var = tk.DoubleVar(value=0.8)\r\n-        threshold_scale = ttk.Scale(settings_frame, from_=0.5, to=1.0, orient=tk.HORIZONTAL, \r\n-                                    variable=self.threshold_var, length=200)\r\n-        threshold_scale.grid(row=2, column=1, sticky=tk.W, pady=5)\r\n-        ttk.Label(settings_frame, textvariable=self.threshold_var).grid(row=2, column=2, sticky=tk.W, pady=5)\r\n-        \r\n-        # ディレイ設定\r\n-        ttk.Label(settings_frame, text=\"操作間隔(秒):\").grid(row=3, column=0, sticky=tk.W, pady=5)\r\n-        self.delay_var = tk.DoubleVar(value=1.0)\r\n-        delay_scale = ttk.Scale(settings_frame, from_=0.1, to=5.0, orient=tk.HORIZONTAL, \r\n-                                variable=self.delay_var, length=200)\r\n-        delay_scale.grid(row=3, column=1, sticky=tk.W, pady=5)\r\n-        ttk.Label(settings_frame, textvariable=self.delay_var).grid(row=3, column=2, sticky=tk.W, pady=5)\r\n-        \r\n-        # 画像のロードボタン\r\n-        ttk.Button(settings_frame, text=\"画像をロード\", command=self.load_images).grid(row=4, column=1, pady=10)\r\n-    \r\n-    def setup_control_frame(self):\r\n-        control_frame = ttk.LabelFrame(self.main_frame, text=\"コントロール\", padding=10)\r\n-        control_frame.pack(fill=tk.X, pady=5)\r\n-        \r\n-        # スタート・ストップボタン\r\n-        self.start_btn = ttk.Button(control_frame, text=\"開始\", command=self.start_automation)\r\n-        self.start_btn.pack(side=tk.LEFT, padx=5)\r\n-        \r\n-        self.stop_btn = ttk.Button(control_frame, text=\"停止\", command=self.stop_automation, state=tk.DISABLED)\r\n-        self.stop_btn.pack(side=tk.LEFT, padx=5)\r\n-        \r\n-        self.pause_btn = ttk.Button(control_frame, text=\"一時停止\", command=self.pause_automation, state=tk.DISABLED)\r\n-        self.pause_btn.pack(side=tk.LEFT, padx=5)\r\n-        \r\n-        # 1サイクルのみ実行ボタン\r\n-        self.single_cycle_btn = ttk.Button(control_frame, text=\"1サイクル実行\", command=self.run_single_cycle)\r\n-        self.single_cycle_btn.pack(side=tk.LEFT, padx=5)\r\n-        \r\n-        # スクリーンショットボタン\r\n-        self.screenshot_btn = ttk.Button(control_frame, text=\"スクリーンショット\", command=self.take_screenshot)\r\n-        self.screenshot_btn.pack(side=tk.LEFT, padx=5)\r\n-    \r\n-    def setup_log_frame(self):\r\n-        log_frame = ttk.LabelFrame(self.main_frame, text=\"ログ\", padding=10)\r\n-        log_frame.pack(fill=tk.BOTH, expand=True, pady=5)\r\n-        \r\n-        # ログエリア\r\n-        self.log_area = scrolledtext.ScrolledText(log_frame, width=80, height=15)\r\n-        self.log_area.pack(fill=tk.BOTH, expand=True)\r\n-        self.log_area.config(state=tk.DISABLED)\r\n-        \r\n-        # プレビューフレーム\r\n-        preview_frame = ttk.LabelFrame(self.main_frame, text=\"プレビュー\", padding=10)\r\n-        preview_frame.pack(fill=tk.X, pady=5)\r\n-        \r\n-        self.preview_label = ttk.Label(preview_frame, text=\"スクリーンショットをここに表示\")\r\n-        self.preview_label.pack(padx=10, pady=10)\r\n-    \r\n-    def browse_adb(self):\r\n-        path = filedialog.askopenfilename(title=\"ADB実行ファイルを選択\", \r\n-                                         filetypes=[(\"実行ファイル\", \"*.exe\"), (\"すべてのファイル\", \"*.*\")])\r\n-        if path:\r\n-            self.adb_path_var.set(path)\r\n-            self.adb_path = path\r\n-            self.log(\"ADBパスを設定: \" + path)\r\n-    \r\n-    def browse_images(self):\r\n-        path = filedialog.askdirectory(title=\"画像フォルダを選択\")\r\n-        if path:\r\n-            self.images_path_var.set(path)\r\n-            self.images_path = path\r\n-            self.log(\"画像フォルダを設定: \" + path)\r\n-    \r\n-    def load_images(self):\r\n-        if not self.images_path:\r\n-            self.log(\"エラー: 画像フォルダが設定されていません。\")\r\n-            return\r\n-            \r\n-        try:\r\n-            for image_name in self.images:\r\n-                image_path = os.path.join(self.images_path, f\"{image_name}.png\")\r\n-                if os.path.exists(image_path):\r\n-                    self.images[image_name] = cv2.imread(image_path)\r\n-                    if self.images[image_name] is not None:\r\n-                        self.log(f\"{image_name}.pngを読み込みました。\")\r\n-                    else:\r\n-                        self.log(f\"警告: {image_name}.pngの読み込みに失敗しました。\")\r\n-                else:\r\n-                    self.log(f\"警告: {image_name}.pngが見つかりません。\")\r\n-            \r\n-            self.log(\"画像の読み込みが完了しました。\")\r\n-        except Exception as e:\r\n-            self.log(f\"エラー: 画像の読み込み中にエラーが発生しました。{str(e)}\")\r\n-    \r\n-    def log(self, message):\r\n-        self.log_area.config(state=tk.NORMAL)\r\n-        self.log_area.insert(tk.END, f\"[{time.strftime('%H:%M:%S')}] {message}\\n\")\r\n-        self.log_area.see(tk.END)\r\n-        self.log_area.config(state=tk.DISABLED)\r\n-    \r\n-    def start_automation(self):\r\n-        if not self.adb_path or not self.images_path:\r\n-            self.log(\"エラー: ADBパスと画像フォルダを設定してください。\")\r\n-            return\r\n-            \r\n-        # 必要な画像が読み込まれているか確認\r\n-        missing_images = [name for name, img in self.images.items() if img is None]\r\n-        if missing_images:\r\n-            self.log(f\"エラー: 以下の画像が読み込まれていません: {', '.join(missing_images)}\")\r\n-            return\r\n-        \r\n-        self.running = True\r\n-        self.paused = False\r\n-        self.stage_45_detected = False\r\n-        self.puzzle_tapped_count = 0\r\n-        \r\n-        # UIの更新\r\n-        self.start_btn.config(state=tk.DISABLED)\r\n-        self.stop_btn.config(state=tk.NORMAL)\r\n-        self.pause_btn.config(state=tk.NORMAL)\r\n-        self.single_cycle_btn.config(state=tk.DISABLED)\r\n-        \r\n-        self.status_var.set(\"実行中...\")\r\n-        self.log(\"自動周回を開始しました。\")\r\n-        \r\n-        # 別スレッドで実行\r\n-        self.automation_thread = threading.Thread(target=self.automation_loop)\r\n-        self.automation_thread.daemon = True\r\n-        self.automation_thread.start()\r\n-    \r\n-    def stop_automation(self):\r\n-        self.running = False\r\n-        \r\n-        # UIの更新\r\n-        self.start_btn.config(state=tk.NORMAL)\r\n-        self.stop_btn.config(state=tk.DISABLED)\r\n-        self.pause_btn.config(state=tk.DISABLED)\r\n-        self.single_cycle_btn.config(state=tk.NORMAL)\r\n-        \r\n-        self.status_var.set(\"停止\")\r\n-        self.log(\"自動周回を停止しました。\")\r\n-    \r\n-    def pause_automation(self):\r\n-        self.paused = not self.paused\r\n-        \r\n-        if self.paused:\r\n-            self.pause_btn.config(text=\"再開\")\r\n-            self.status_var.set(\"一時停止中\")\r\n-            self.log(\"自動周回を一時停止しました。\")\r\n-        else:\r\n-            self.pause_btn.config(text=\"一時停止\")\r\n-            self.status_var.set(\"実行中...\")\r\n-            self.log(\"自動周回を再開しました。\")\r\n-    \r\n-    def run_single_cycle(self):\r\n-        if not self.adb_path or not self.images_path:\r\n-            self.log(\"エラー: ADBパスと画像フォルダを設定してください。\")\r\n-            return\r\n-            \r\n-        # 必要な画像が読み込まれているか確認\r\n-        missing_images = [name for name, img in self.images.items() if img is None]\r\n-        if missing_images:\r\n-            self.log(f\"エラー: 以下の画像が読み込まれていません: {', '.join(missing_images)}\")\r\n-            return\r\n-        \r\n-        # UIの更新\r\n-        self.start_btn.config(state=tk.DISABLED)\r\n-        self.stop_btn.config(state=tk.DISABLED)\r\n-        self.pause_btn.config(state=tk.DISABLED)\r\n-        self.single_cycle_btn.config(state=tk.DISABLED)\r\n-        \r\n-        self.status_var.set(\"1サイクル実行中...\")\r\n-        self.log(\"1サイクルの実行を開始しました。\")\r\n-        \r\n-        # 別スレッドで実行\r\n-        threading.Thread(target=self.run_one_cycle).daemon = True\r\n-        threading.Thread(target=self.run_one_cycle).start()\r\n-    \r\n-    def take_screenshot(self):\r\n-        try:\r\n-            self.log(\"スクリーンショットを取得中...\")\r\n-            result = subprocess.run([self.adb_path, \"shell\", \"screencap\", \"-p\", \"/sdcard/screenshot.png\"], \r\n-                                  stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)\r\n-            \r\n-            result = subprocess.run([self.adb_path, \"pull\", \"/sdcard/screenshot.png\", \"screenshot.png\"], \r\n-                                  stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)\r\n-            \r\n-            # プレビューを更新\r\n-            img = Image.open(\"screenshot.png\")\r\n-            img = img.resize((300, 200), Image.LANCZOS)\r\n-            img_tk = ImageTk.PhotoImage(img)\r\n-            \r\n-            self.preview_label.config(image=img_tk)\r\n-            self.preview_label.image = img_tk  # 参照を保持\r\n-            \r\n-            self.log(\"スクリーンショットを取得しました。\")\r\n-        except Exception as e:\r\n-            self.log(f\"エラー: スクリーンショット取得中にエラーが発生しました。{str(e)}\")\r\n-    \r\n-    def detect_image(self, template_name):\r\n-        try:\r\n-            # スクリーンショットの取得\r\n-            subprocess.run([self.adb_path, \"shell\", \"screencap\", \"-p\", \"/sdcard/screenshot.png\"], check=True)\r\n-            subprocess.run([self.adb_path, \"pull\", \"/sdcard/screenshot.png\", \"screenshot.png\"], check=True)\r\n-            \r\n-            # 画像の読み込み\r\n-            screenshot = cv2.imread(\"screenshot.png\")\r\n-            template = self.images[template_name]\r\n-            \r\n-            if screenshot is None or template is None:\r\n-                self.log(f\"エラー: 画像の読み込みに失敗しました。\")\r\n-                return None\r\n-            \r\n-            # テンプレートマッチング\r\n-            result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n-            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-            \r\n-            threshold = self.threshold_var.get()\r\n-            if max_val >= threshold:\r\n-                # マッチした位置を計算\r\n-                h, w = template.shape[:2]\r\n-                top_left = max_loc\r\n-                center_x = top_left[0] + w // 2\r\n-                center_y = top_left[1] + h // 2\r\n-                \r\n-                self.log(f\"{template_name}.pngを検出しました。一致率: {max_val:.2f}, 位置: ({center_x}, {center_y})\")\r\n-                return (center_x, center_y)\r\n-            else:\r\n-                self.log(f\"{template_name}.pngは検出されませんでした。最大一致率: {max_val:.2f}\")\r\n-                return None\r\n-        except Exception as e:\r\n-            self.log(f\"エラー: 画像検出中にエラーが発生しました。{str(e)}\")\r\n-            return None\r\n-    \r\n-    def tap(self, x, y):\r\n-        try:\r\n-            subprocess.run([self.adb_path, \"shell\", \"input\", \"tap\", str(x), str(y)], check=True)\r\n-            self.log(f\"画面の位置 ({x}, {y}) をタップしました。\")\r\n-            time.sleep(self.delay_var.get())  # 操作間の待機\r\n-            return True\r\n-        except Exception as e:\r\n-            self.log(f\"エラー: タップ操作中にエラーが発生しました。{str(e)}\")\r\n-            return False\r\n-    \r\n-    def check_close_button(self):\r\n-        # close.pngの検出\r\n-        close_pos = self.detect_image(\"close\")\r\n-        if close_pos:\r\n-            if not (self.stage_45_detected):\r\n-                self.log(\"close.pngを検出しました。タップします。\")\r\n-                self.tap(close_pos[0], close_pos[1])\r\n-                return True\r\n-            else:\r\n-                self.log(\"stage_45が検出されているため、close.pngはタップしません。\")\r\n-        \r\n-        # close_mini.pngの検出\r\n-        close_mini_pos = self.detect_image(\"close_mini\")\r\n-        if close_mini_pos:\r\n-            if not (self.stage_45_detected):\r\n-                self.log(\"close_mini.pngを検出しました。タップします。\")\r\n-                self.tap(close_mini_pos[0], close_mini_pos[1])\r\n-                return True\r\n-            else:\r\n-                self.log(\"stage_45が検出されているため、close_mini.pngはタップしません。\")\r\n-        \r\n-        return False\r\n-    \r\n-    def automation_loop(self):\r\n-        while self.running:\r\n-            if not self.paused:\r\n-                self.run_one_cycle()\r\n-            else:\r\n-                time.sleep(0.5)  # 一時停止中は短い間隔でループ\r\n-    \r\n-    def run_one_cycle(self):\r\n-        try:\r\n-            # 常時closeボタンをチェック\r\n-            if self.check_close_button():\r\n-                time.sleep(self.delay_var.get())\r\n-            \r\n-            # ステップ1: boss.pngをタップ\r\n-            self.log(\"ステップ1: boss.pngを探しています...\")\r\n-            boss_pos = self.detect_image(\"boss\")\r\n-            if boss_pos:\r\n-                self.tap(boss_pos[0], boss_pos[1])\r\n-            else:\r\n-                self.log(\"boss.pngが見つかりませんでした。再試行します。\")\r\n-                time.sleep(self.delay_var.get())\r\n-                return\r\n-            \r\n-            # ステップ2: play.pngをタップ\r\n-            self.log(\"ステップ2: play.pngを探しています...\")\r\n-            play_pos = self.detect_image(\"play\")\r\n-            if play_pos:\r\n-                # stage_45の検出\r\n-                stage_45_pos = self.detect_image(\"stage_45\")\r\n-                if stage_45_pos:\r\n-                    self.log(\"stage_45.pngを検出しました。\")\r\n-                    self.stage_45_detected = True\r\n-                \r\n-                self.tap(play_pos[0], play_pos[1])\r\n-            else:\r\n-                self.log(\"play.pngが見つかりませんでした。再試行します。\")\r\n-                time.sleep(self.delay_var.get())\r\n-                return\r\n-            \r\n-            # ステップ3と4: puzzle.pngとwaza_ok.pngを交互にタップ、next.pngが検出されるまで\r\n-            self.puzzle_tapped_count = 0\r\n-            next_detected = False\r\n-            \r\n-            self.log(\"ステップ3/4: パズル中のループを開始します...\")\r\n-            while not next_detected and self.running and not self.paused:\r\n-                # 常時closeボタンをチェック\r\n-                if self.check_close_button():\r\n-                    time.sleep(self.delay_var.get())\r\n-                \r\n-                # next.pngの検出\r\n-                next_pos = self.detect_image(\"next\")\r\n-                if next_pos:\r\n-                    next_detected = True\r\n-                    self.log(\"next.pngを検出しました。ループを終了します。\")\r\n-                    break\r\n-                \r\n-                # puzzle.pngのタップ（2回まで）\r\n-                if self.puzzle_tapped_count < 2:\r\n-                    puzzle_pos = self.detect_image(\"puzzle\")\r\n-                    if puzzle_pos:\r\n-                        self.tap(puzzle_pos[0], puzzle_pos[1])\r\n-                        self.puzzle_tapped_count += 1\r\n-                \r\n-                # waza_ok.pngのタップ\r\n-                waza_ok_pos = self.detect_image(\"waza_ok\")\r\n-                if waza_ok_pos:\r\n-                    self.tap(waza_ok_pos[0], waza_ok_pos[1])\r\n-                \r\n-                time.sleep(self.delay_var.get())\r\n-            \r\n-            # ステップ5: next.pngをタップ\r\n-            if next_detected:\r\n-                self.log(\"ステップ5: next.pngをタップします...\")\r\n-                next_pos = self.detect_image(\"next\")\r\n-                if next_pos:\r\n-                    self.tap(next_pos[0], next_pos[1])\r\n-            \r\n-            # 1サイクル終了\r\n-            self.log(\"1サイクルが完了しました。\")\r\n-            self.stage_45_detected = False  # stage_45フラグをリセット\r\n-            \r\n-            # 単一サイクルモードの場合はUIを更新\r\n-            if not self.running:\r\n-                self.root.after(0, self.update_ui_after_single_cycle)\r\n-            \r\n-        except Exception as e:\r\n-            self.log(f\"エラー: 自動化ループ中にエラーが発生しました。{str(e)}\")\r\n-            if not self.running:\r\n-                self.root.after(0, self.update_ui_after_single_cycle)\r\n-    \r\n-    def update_ui_after_single_cycle(self):\r\n-        self.start_btn.config(state=tk.NORMAL)\r\n-        self.stop_btn.config(state=tk.DISABLED)\r\n-        self.pause_btn.config(state=tk.DISABLED)\r\n-        self.single_cycle_btn.config(state=tk.NORMAL)\r\n-        self.status_var.set(\"準備完了\")\r\n-\r\n-if __name__ == \"__main__\":\r\n-    root = tk.Tk()\r\n-    app = YokaiWatchAutoGUI(root)\r\n-    root.mainloop()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1750487944410,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,444 @@\n+import tkinter as tk\r\n+from tkinter import ttk, scrolledtext, messagebox\r\n+import cv2\r\n+import numpy as np\r\n+import subprocess\r\n+import threading\r\n+import time\r\n+import os\r\n+from datetime import datetime\r\n+import json\r\n+\r\n+class PuniPuniAutoPlayer:\r\n+    def __init__(self, root):\r\n+        self.root = root\r\n+        self.root.title(\"妖怪ウォッチぷにぷに自動周回ソフト\")\r\n+        self.root.geometry(\"800x600\")\r\n+        \r\n+        # 変数の初期化\r\n+        self.devices = []\r\n+        self.selected_devices = []\r\n+        self.running = False\r\n+        self.threads = {}\r\n+        self.device_status = {}\r\n+        \r\n+        # 画像ファイルパス\r\n+        self.image_paths = {\r\n+            'boss': 'image/boss.jpg',\r\n+            'play': 'image/play.png',\r\n+            'puzzle': 'image/puzzle.png',\r\n+            'waza_ok': 'image/waza_ok.png',\r\n+            'next': 'image/next.png',\r\n+            'close': 'image/close.png',\r\n+            'close_mini': 'image/close_mini.png',\r\n+            'stage_45': 'image/stage_45.png'\r\n+        }\r\n+          # 設定\r\n+        self.settings = {\r\n+            'similarity_threshold': 0.8,\r\n+            'tap_delay': 0.3,  # 実際のタップに近い遅延\r\n+            'puzzle_tap_count': 2,\r\n+            'check_interval': 0.1,  # 高速チェック間隔\r\n+            'screenshot_cache_time': 0.05,  # スクリーンショットキャッシュ時間\r\n+            'human_like_delay_min': 0.15,  # 人間らしい遅延の最小値\r\n+            'human_like_delay_max': 0.4   # 人間らしい遅延の最大値\r\n+        }\r\n+        \r\n+        # スクリーンショットキャッシュ\r\n+        self.screenshot_cache = {}\r\n+        self.last_screenshot_time = {}\r\n+        \r\n+        self.create_widgets()\r\n+        self.refresh_devices()\r\n+        \r\n+    def create_widgets(self):\r\n+        # メインフレーム\r\n+        main_frame = ttk.Frame(self.root, padding=\"10\")\r\n+        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n+        \r\n+        # デバイス選択フレーム\r\n+        device_frame = ttk.LabelFrame(main_frame, text=\"デバイス選択\", padding=\"5\")\r\n+        device_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))\r\n+        \r\n+        ttk.Button(device_frame, text=\"デバイス更新\", command=self.refresh_devices).grid(row=0, column=0, padx=(0, 10))\r\n+        \r\n+        self.device_listbox = tk.Listbox(device_frame, height=4, selectmode=tk.MULTIPLE)\r\n+        self.device_listbox.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(5, 0))\r\n+        \r\n+        # 設定フレーム\r\n+        settings_frame = ttk.LabelFrame(main_frame, text=\"設定\", padding=\"5\")\r\n+        settings_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N), padx=(0, 10))\r\n+        \r\n+        ttk.Label(settings_frame, text=\"類似度閾値:\").grid(row=0, column=0, sticky=tk.W)\r\n+        self.similarity_var = tk.DoubleVar(value=self.settings['similarity_threshold'])\r\n+        ttk.Scale(settings_frame, from_=0.5, to=1.0, variable=self.similarity_var, \r\n+                 orient=tk.HORIZONTAL, length=150).grid(row=0, column=1, padx=(5, 0))\r\n+        ttk.Label(settings_frame, textvariable=self.similarity_var).grid(row=0, column=2, padx=(5, 0))\r\n+        \r\n+        ttk.Label(settings_frame, text=\"タップ間隔(秒):\").grid(row=1, column=0, sticky=tk.W)\r\n+        self.delay_var = tk.DoubleVar(value=self.settings['tap_delay'])\r\n+        ttk.Scale(settings_frame, from_=0.1, to=2.0, variable=self.delay_var, \r\n+                 orient=tk.HORIZONTAL, length=150).grid(row=1, column=1, padx=(5, 0))\r\n+        ttk.Label(settings_frame, textvariable=self.delay_var).grid(row=1, column=2, padx=(5, 0))\r\n+        \r\n+        ttk.Label(settings_frame, text=\"パズルタップ回数:\").grid(row=2, column=0, sticky=tk.W)\r\n+        self.puzzle_count_var = tk.IntVar(value=self.settings['puzzle_tap_count'])\r\n+        ttk.Spinbox(settings_frame, from_=1, to=10, textvariable=self.puzzle_count_var, \r\n+                   width=10).grid(row=2, column=1, sticky=tk.W, padx=(5, 0))\r\n+        \r\n+        ttk.Label(settings_frame, text=\"検知間隔(秒):\").grid(row=3, column=0, sticky=tk.W)\r\n+        self.check_interval_var = tk.DoubleVar(value=self.settings['check_interval'])\r\n+        ttk.Scale(settings_frame, from_=0.05, to=1.0, variable=self.check_interval_var, \r\n+                 orient=tk.HORIZONTAL, length=150).grid(row=3, column=1, padx=(5, 0))\r\n+        ttk.Label(settings_frame, textvariable=self.check_interval_var).grid(row=3, column=2, padx=(5, 0))\r\n+        \r\n+        # コントロールフレーム\r\n+        control_frame = ttk.LabelFrame(main_frame, text=\"制御\", padding=\"5\")\r\n+        control_frame.grid(row=1, column=1, sticky=(tk.W, tk.E, tk.N))\r\n+        \r\n+        self.start_button = ttk.Button(control_frame, text=\"開始\", command=self.start_automation)\r\n+        self.start_button.grid(row=0, column=0, padx=(0, 5), pady=(0, 5))\r\n+        \r\n+        self.stop_button = ttk.Button(control_frame, text=\"停止\", command=self.stop_automation, state=tk.DISABLED)\r\n+        self.stop_button.grid(row=0, column=1, pady=(0, 5))\r\n+        \r\n+        ttk.Button(control_frame, text=\"スクリーンショット\", command=self.take_screenshot).grid(row=1, column=0, columnspan=2, pady=(0, 5))\r\n+        \r\n+        ttk.Button(control_frame, text=\"設定保存\", command=self.save_settings).grid(row=2, column=0, padx=(0, 5))\r\n+        ttk.Button(control_frame, text=\"設定読込\", command=self.load_settings).grid(row=2, column=1)\r\n+        \r\n+        # ログフレーム\r\n+        log_frame = ttk.LabelFrame(main_frame, text=\"ログ\", padding=\"5\")\r\n+        log_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(10, 0))\r\n+        \r\n+        self.log_text = scrolledtext.ScrolledText(log_frame, height=15, width=80)\r\n+        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n+        \r\n+        # グリッドの重み設定\r\n+        self.root.columnconfigure(0, weight=1)\r\n+        self.root.rowconfigure(0, weight=1)\r\n+        main_frame.columnconfigure(0, weight=1)\r\n+        main_frame.columnconfigure(1, weight=1)\r\n+        main_frame.rowconfigure(2, weight=1)\r\n+        device_frame.columnconfigure(0, weight=1)\r\n+        log_frame.columnconfigure(0, weight=1)\r\n+        log_frame.rowconfigure(0, weight=1)\r\n+        \r\n+    def log(self, message, device_id=None):\r\n+        \"\"\"ログメッセージを表示\"\"\"\r\n+        timestamp = datetime.now().strftime(\"%H:%M:%S\")\r\n+        if device_id:\r\n+            log_message = f\"[{timestamp}] [{device_id}] {message}\\n\"\r\n+        else:\r\n+            log_message = f\"[{timestamp}] {message}\\n\"\r\n+        \r\n+        self.log_text.insert(tk.END, log_message)\r\n+        self.log_text.see(tk.END)\r\n+        print(log_message.strip())\r\n+        \r\n+    def refresh_devices(self):\r\n+        \"\"\"ADBデバイスを更新\"\"\"\r\n+        try:\r\n+            result = subprocess.run(['adb', 'devices'], capture_output=True, text=True)\r\n+            lines = result.stdout.strip().split('\\n')[1:]  # ヘッダーを除く\r\n+            \r\n+            self.devices = []\r\n+            for line in lines:\r\n+                if line.strip() and 'device' in line:\r\n+                    device_id = line.split('\\t')[0]\r\n+                    self.devices.append(device_id)\r\n+            \r\n+            # リストボックスを更新\r\n+            self.device_listbox.delete(0, tk.END)\r\n+            for device in self.devices:\r\n+                self.device_listbox.insert(tk.END, device)\r\n+            \r\n+            self.log(f\"デバイス検出: {len(self.devices)}台\")\r\n+            \r\n+        except Exception as e:\r\n+            self.log(f\"デバイス検出エラー: {str(e)}\")\r\n+            \r\n+    def get_selected_devices(self):\r\n+        \"\"\"選択されたデバイスを取得\"\"\"\r\n+        selected_indices = self.device_listbox.curselection()\r\n+        return [self.devices[i] for i in selected_indices]\r\n+        \r\n+    def take_screenshot(self, device_id=None, force_new=False):\r\n+        \"\"\"スクリーンショットを取得（キャッシュ機能付き）\"\"\"\r\n+        if not device_id:\r\n+            devices = self.get_selected_devices()\r\n+            if not devices:\r\n+                messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n+                return\r\n+            device_id = devices[0]\r\n+        \r\n+        current_time = time.time()\r\n+        \r\n+        # キャッシュチェック（強制更新でない場合）\r\n+        if not force_new and device_id in self.last_screenshot_time:\r\n+            if current_time - self.last_screenshot_time[device_id] < self.settings['screenshot_cache_time']:\r\n+                if device_id in self.screenshot_cache:\r\n+                    return self.screenshot_cache[device_id]\r\n+        \r\n+        try:\r\n+            # スクリーンショットを取得\r\n+            screenshot_path = f'screenshot_{device_id}.png'\r\n+            subprocess.run(['adb', '-s', device_id, 'shell', 'screencap', '/sdcard/screenshot.png'], \r\n+                         check=True, capture_output=True)\r\n+            subprocess.run(['adb', '-s', device_id, 'pull', '/sdcard/screenshot.png', screenshot_path], \r\n+                         check=True, capture_output=True)\r\n+            \r\n+            # キャッシュに保存\r\n+            self.screenshot_cache[device_id] = screenshot_path\r\n+            self.last_screenshot_time[device_id] = current_time\r\n+            \r\n+            return screenshot_path\r\n+        except Exception as e:\r\n+            self.log(f\"スクリーンショットエラー: {str(e)}\", device_id)\r\n+            return None\r\n+            \r\n+    def find_image_on_screen(self, template_path, device_id, threshold=None):\r\n+        \"\"\"画面上で画像を検索\"\"\"\r\n+        if threshold is None:\r\n+            threshold = self.similarity_var.get()\r\n+            \r\n+        screenshot_path = self.take_screenshot(device_id)\r\n+        if not screenshot_path:\r\n+            return None\r\n+            \r\n+        try:\r\n+            # 画像を読み込み\r\n+            screenshot = cv2.imread(screenshot_path)\r\n+            template = cv2.imread(template_path)\r\n+            \r\n+            if screenshot is None or template is None:\r\n+                self.log(f\"画像読み込みエラー: {template_path}\", device_id)\r\n+                return None\r\n+            \r\n+            # テンプレートマッチング\r\n+            result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n+            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+            \r\n+            if max_val >= threshold:\r\n+                # マッチした位置の中心座標を計算\r\n+                h, w = template.shape[:2]\r\n+                center_x = max_loc[0] + w // 2\r\n+                center_y = max_loc[1] + h // 2\r\n+                \r\n+                self.log(f\"画像検出: {os.path.basename(template_path)} at ({center_x}, {center_y}) 類似度: {max_val:.3f}\", device_id)\r\n+                return (center_x, center_y)\r\n+            else:\r\n+                return None\r\n+                \r\n+        except Exception as e:\r\n+            self.log(f\"画像検索エラー: {str(e)}\", device_id)\r\n+            return None\r\n+            \r\n+    def tap_screen(self, x, y, device_id):\r\n+        \"\"\"画面にタップ\"\"\"\r\n+        try:\r\n+            subprocess.run(['adb', '-s', device_id, 'shell', 'input', 'tap', str(x), str(y)], check=True)\r\n+            self.log(f\"タップ: ({x}, {y})\", device_id)\r\n+            time.sleep(self.delay_var.get())\r\n+            return True\r\n+        except Exception as e:\r\n+            self.log(f\"タップエラー: {str(e)}\", device_id)\r\n+            return False\r\n+            \r\n+    def human_like_delay(self):\r\n+        \"\"\"人間らしいランダムな遅延\"\"\"\r\n+        import random\r\n+        delay = random.uniform(\r\n+            self.settings['human_like_delay_min'], \r\n+            self.settings['human_like_delay_max']\r\n+        )\r\n+        time.sleep(delay)\r\n+        \r\n+    def smart_tap_screen(self, x, y, device_id, tap_type=\"normal\"):\r\n+        \"\"\"スマートタップ機能（タップ種類に応じて遅延を調整）\"\"\"\r\n+        try:\r\n+            subprocess.run(['adb', '-s', device_id, 'shell', 'input', 'tap', str(x), str(y)], \r\n+                         check=True, capture_output=True)\r\n+            self.log(f\"タップ: ({x}, {y}) [{tap_type}]\", device_id)\r\n+            \r\n+            # タップ種類に応じた遅延\r\n+            if tap_type == \"boss\":\r\n+                time.sleep(self.delay_var.get() * 1.5)  # ボス選択は少し長め\r\n+            elif tap_type == \"play\":\r\n+                time.sleep(self.delay_var.get() * 2.0)  # プレイボタンは読み込み時間考慮\r\n+            elif tap_type == \"puzzle\":\r\n+                time.sleep(self.delay_var.get() * 0.8)  # パズルは短め\r\n+            elif tap_type == \"close\":\r\n+                time.sleep(self.delay_var.get() * 0.5)  # 閉じるボタンは最短\r\n+            else:\r\n+                time.sleep(self.delay_var.get())\r\n+            \r\n+            # 人間らしい微小な遅延を追加\r\n+            self.human_like_delay()\r\n+            return True\r\n+        except Exception as e:\r\n+            self.log(f\"タップエラー: {str(e)}\", device_id)\r\n+            return False\r\n+\r\n+    def automation_loop(self, device_id):\r\n+        \"\"\"メインの自動化ループ\"\"\"\r\n+        self.device_status[device_id] = \"実行中\"\r\n+        puzzle_tap_count = 0\r\n+        stage_45_detected = False\r\n+        \r\n+        while self.running and device_id in self.threads:\r\n+            try:\r\n+                # close.pngの常時監視（stage_45検出時は除く）\r\n+                if not stage_45_detected:\r\n+                    close_pos = self.find_image_on_screen(self.image_paths['close'], device_id)\r\n+                    if close_pos:\r\n+                        self.tap_screen(close_pos[0], close_pos[1], device_id)\r\n+                        continue\r\n+                    \r\n+                    close_mini_pos = self.find_image_on_screen(self.image_paths['close_mini'], device_id)\r\n+                    if close_mini_pos:\r\n+                        self.tap_screen(close_mini_pos[0], close_mini_pos[1], device_id)\r\n+                        continue\r\n+                \r\n+                # ①boss.pngをタップ\r\n+                boss_pos = self.find_image_on_screen(self.image_paths['boss'], device_id)\r\n+                if boss_pos:\r\n+                    self.tap_screen(boss_pos[0], boss_pos[1], device_id)\r\n+                    time.sleep(self.delay_var.get())\r\n+                    \r\n+                    # ②play.pngをタップ\r\n+                    play_pos = self.find_image_on_screen(self.image_paths['play'], device_id)\r\n+                    if play_pos:\r\n+                        # stage_45.pngをチェック\r\n+                        stage_45_pos = self.find_image_on_screen(self.image_paths['stage_45'], device_id)\r\n+                        if stage_45_pos:\r\n+                            stage_45_detected = True\r\n+                            self.log(\"ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n+                        \r\n+                        self.tap_screen(play_pos[0], play_pos[1], device_id)\r\n+                        time.sleep(self.delay_var.get())\r\n+                        \r\n+                        # ③④のループ\r\n+                        puzzle_tap_count = 0\r\n+                        while self.running and device_id in self.threads:\r\n+                            # ⑤next.pngをチェック\r\n+                            next_pos = self.find_image_on_screen(self.image_paths['next'], device_id)\r\n+                            if next_pos:\r\n+                                self.tap_screen(next_pos[0], next_pos[1], device_id)\r\n+                                stage_45_detected = False  # リセット\r\n+                                break\r\n+                            \r\n+                            # ③puzzle.pngをタップ（2回まで）\r\n+                            if puzzle_tap_count < self.puzzle_count_var.get():\r\n+                                puzzle_pos = self.find_image_on_screen(self.image_paths['puzzle'], device_id)\r\n+                                if puzzle_pos:\r\n+                                    self.tap_screen(puzzle_pos[0], puzzle_pos[1], device_id)\r\n+                                    puzzle_tap_count += 1\r\n+                                    continue\r\n+                            \r\n+                            # ④waza_ok.pngをタップ\r\n+                            waza_ok_pos = self.find_image_on_screen(self.image_paths['waza_ok'], device_id)\r\n+                            if waza_ok_pos:\r\n+                                self.tap_screen(waza_ok_pos[0], waza_ok_pos[1], device_id)\r\n+                                puzzle_tap_count = 0  # リセット\r\n+                            \r\n+                            time.sleep(self.settings['check_interval'])\r\n+                \r\n+                time.sleep(self.settings['check_interval'])\r\n+                \r\n+            except Exception as e:\r\n+                self.log(f\"自動化エラー: {str(e)}\", device_id)\r\n+                time.sleep(1)\r\n+        \r\n+        self.device_status[device_id] = \"停止\"\r\n+        self.log(\"自動化停止\", device_id)\r\n+        \r\n+    def start_automation(self):\r\n+        \"\"\"自動化開始\"\"\"\r\n+        selected_devices = self.get_selected_devices()\r\n+        if not selected_devices:\r\n+            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n+            return\r\n+        \r\n+        # 画像ファイルの確認\r\n+        missing_files = []\r\n+        for name, path in self.image_paths.items():\r\n+            if not os.path.exists(path):\r\n+                missing_files.append(path)\r\n+        \r\n+        if missing_files:\r\n+            messagebox.showerror(\"エラー\", f\"画像ファイルが見つかりません:\\n\" + \"\\n\".join(missing_files))\r\n+            return\r\n+        \r\n+        self.running = True\r\n+        self.start_button.config(state=tk.DISABLED)\r\n+        self.stop_button.config(state=tk.NORMAL)\r\n+        \r\n+        # 設定を更新\r\n+        self.settings['similarity_threshold'] = self.similarity_var.get()\r\n+        self.settings['tap_delay'] = self.delay_var.get()\r\n+        self.settings['puzzle_tap_count'] = self.puzzle_count_var.get()\r\n+        \r\n+        # 各デバイスでスレッドを開始\r\n+        for device_id in selected_devices:\r\n+            thread = threading.Thread(target=self.automation_loop, args=(device_id,))\r\n+            thread.daemon = True\r\n+            self.threads[device_id] = thread\r\n+            thread.start()\r\n+            self.log(\"自動化開始\", device_id)\r\n+            \r\n+    def stop_automation(self):\r\n+        \"\"\"自動化停止\"\"\"\r\n+        self.running = False\r\n+        self.threads.clear()\r\n+        \r\n+        self.start_button.config(state=tk.NORMAL)\r\n+        self.stop_button.config(state=tk.DISABLED)\r\n+        \r\n+        self.log(\"全デバイスの自動化を停止\")\r\n+        \r\n+    def save_settings(self):\r\n+        \"\"\"設定保存\"\"\"\r\n+        settings = {\r\n+            'similarity_threshold': self.similarity_var.get(),\r\n+            'tap_delay': self.delay_var.get(),\r\n+            'puzzle_tap_count': self.puzzle_count_var.get()\r\n+        }\r\n+        \r\n+        try:\r\n+            with open('settings.json', 'w', encoding='utf-8') as f:\r\n+                json.dump(settings, f, indent=2, ensure_ascii=False)\r\n+            self.log(\"設定を保存しました\")\r\n+        except Exception as e:\r\n+            self.log(f\"設定保存エラー: {str(e)}\")\r\n+            \r\n+    def load_settings(self):\r\n+        \"\"\"設定読込\"\"\"\r\n+        try:\r\n+            with open('settings.json', 'r', encoding='utf-8') as f:\r\n+                settings = json.load(f)\r\n+            \r\n+            self.similarity_var.set(settings.get('similarity_threshold', 0.8))\r\n+            self.delay_var.set(settings.get('tap_delay', 1.0))\r\n+            self.puzzle_count_var.set(settings.get('puzzle_tap_count', 2))\r\n+            \r\n+            self.log(\"設定を読み込みました\")\r\n+        except FileNotFoundError:\r\n+            self.log(\"設定ファイルが見つかりません\")\r\n+        except Exception as e:\r\n+            self.log(f\"設定読込エラー: {str(e)}\")\r\n+\r\n+def main():\r\n+    root = tk.Tk()\r\n+    app = PuniPuniAutoPlayer(root)\r\n+    \r\n+    def on_closing():\r\n+        if app.running:\r\n+            app.stop_automation()\r\n+        root.destroy()\r\n+    \r\n+    root.protocol(\"WM_DELETE_WINDOW\", on_closing)\r\n+    root.mainloop()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    main()\r\n"
                },
                {
                    "date": 1750488311479,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,10 @@\n import time\r\n import os\r\n from datetime import datetime\r\n import json\r\n+import struct\r\n+import socket\r\n \r\n class PuniPuniAutoPlayer:\r\n     def __init__(self, root):\r\n         self.root = root\r\n@@ -47,8 +49,13 @@\n         # スクリーンショットキャッシュ\r\n         self.screenshot_cache = {}\r\n         self.last_screenshot_time = {}\r\n         \r\n+        # メモリ直接アクセス用の設定\r\n+        self.use_memory_capture = True  # メモリ直接取得を有効化\r\n+        self.minicap_connections = {}  # デバイスごとのminicap接続\r\n+        self.raw_capture_enabled = False  # RAWキャプチャフラグ\r\n+        \r\n         self.create_widgets()\r\n         self.refresh_devices()\r\n         \r\n     def create_widgets(self):\r\n@@ -91,8 +98,12 @@\n         ttk.Scale(settings_frame, from_=0.05, to=1.0, variable=self.check_interval_var, \r\n                  orient=tk.HORIZONTAL, length=150).grid(row=3, column=1, padx=(5, 0))\r\n         ttk.Label(settings_frame, textvariable=self.check_interval_var).grid(row=3, column=2, padx=(5, 0))\r\n         \r\n+        # メモリ直接取得設定\r\n+        self.memory_capture_var = tk.BooleanVar(value=self.settings.get('use_memory_capture', True))\r\n+        ttk.Checkbutton(settings_frame, text=\"メモリ直接取得\", variable=self.memory_capture_var).grid(row=4, column=0, columnspan=2, sticky=tk.W, pady=(5, 0))\r\n+\r\n         # コントロールフレーム\r\n         control_frame = ttk.LabelFrame(main_frame, text=\"制御\", padding=\"5\")\r\n         control_frame.grid(row=1, column=1, sticky=(tk.W, tk.E, tk.N))\r\n         \r\n@@ -233,9 +244,47 @@\n         except Exception as e:\r\n             self.log(f\"画像検索エラー: {str(e)}\", device_id)\r\n             return None\r\n             \r\n-    def tap_screen(self, x, y, device_id):\r\n+    def find_multiple_images_on_screen(self, template_paths, device_id, threshold=None):\r\n+        \"\"\"複数の画像を同時に検索\"\"\"\r\n+        if threshold is None:\r\n+            threshold = self.similarity_var.get()\r\n+            \r\n+        screenshot_path = self.take_screenshot(device_id)\r\n+        if not screenshot_path:\r\n+            return {}\r\n+            \r\n+        try:\r\n+            screenshot = cv2.imread(screenshot_path)\r\n+            if screenshot is None:\r\n+                return {}\r\n+            \r\n+            results = {}\r\n+            for name, template_path in template_paths.items():\r\n+                template = cv2.imread(template_path)\r\n+                if template is None:\r\n+                    continue\r\n+                \r\n+                # テンプレートマッチング\r\n+                result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n+                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+                \r\n+                if max_val >= threshold:\r\n+                    h, w = template.shape[:2]\r\n+                    center_x = max_loc[0] + w // 2\r\n+                    center_y = max_loc[1] + h // 2\r\n+                    \r\n+                    results[name] = {\r\n+                        'pos': (center_x, center_y),\r\n+                        'confidence': max_val\r\n+                    }\r\n+            \r\n+            return results\r\n+                \r\n+        except Exception as e:\r\n+            self.log(f\"複数画像検索エラー: {str(e)}\", device_id)\r\n+            return {}\r\n         \"\"\"画面にタップ\"\"\"\r\n         try:\r\n             subprocess.run(['adb', '-s', device_id, 'shell', 'input', 'tap', str(x), str(y)], check=True)\r\n             self.log(f\"タップ: ({x}, {y})\", device_id)\r\n@@ -278,82 +327,125 @@\n             return True\r\n         except Exception as e:\r\n             self.log(f\"タップエラー: {str(e)}\", device_id)\r\n             return False\r\n-\r\n+            \r\n     def automation_loop(self, device_id):\r\n-        \"\"\"メインの自動化ループ\"\"\"\r\n+        \"\"\"最適化されたメインの自動化ループ\"\"\"\r\n         self.device_status[device_id] = \"実行中\"\r\n         puzzle_tap_count = 0\r\n         stage_45_detected = False\r\n         \r\n         while self.running and device_id in self.threads:\r\n             try:\r\n-                # close.pngの常時監視（stage_45検出時は除く）\r\n+                # 優先度の高い画像を同時検索\r\n+                priority_images = {}\r\n+                \r\n+                # close系の監視（stage_45検出時は除く）\r\n                 if not stage_45_detected:\r\n-                    close_pos = self.find_image_on_screen(self.image_paths['close'], device_id)\r\n-                    if close_pos:\r\n-                        self.tap_screen(close_pos[0], close_pos[1], device_id)\r\n-                        continue\r\n+                    priority_images['close'] = self.image_paths['close']\r\n+                    priority_images['close_mini'] = self.image_paths['close_mini']\r\n+                \r\n+                # 現在の状態に応じた画像を追加\r\n+                priority_images['boss'] = self.image_paths['boss']\r\n+                priority_images['play'] = self.image_paths['play']\r\n+                priority_images['next'] = self.image_paths['next']\r\n+                \r\n+                # 複数画像を同時検索\r\n+                detected_images = self.find_multiple_images_on_screen(priority_images, device_id)\r\n+                \r\n+                # 優先順位に従って処理\r\n+                if 'close' in detected_images and not stage_45_detected:\r\n+                    pos = detected_images['close']['pos']\r\n+                    self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n+                    continue\r\n                     \r\n-                    close_mini_pos = self.find_image_on_screen(self.image_paths['close_mini'], device_id)\r\n-                    if close_mini_pos:\r\n-                        self.tap_screen(close_mini_pos[0], close_mini_pos[1], device_id)\r\n-                        continue\r\n+                if 'close_mini' in detected_images and not stage_45_detected:\r\n+                    pos = detected_images['close_mini']['pos']\r\n+                    self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n+                    continue\r\n                 \r\n-                # ①boss.pngをタップ\r\n-                boss_pos = self.find_image_on_screen(self.image_paths['boss'], device_id)\r\n-                if boss_pos:\r\n-                    self.tap_screen(boss_pos[0], boss_pos[1], device_id)\r\n+                # next.pngが検出された場合（最優先）\r\n+                if 'next' in detected_images:\r\n+                    pos = detected_images['next']['pos']\r\n+                    self.smart_tap_screen(pos[0], pos[1], device_id, \"next\")\r\n+                    stage_45_detected = False  # リセット\r\n+                    puzzle_tap_count = 0\r\n+                    continue\r\n+                \r\n+                # boss.pngが検出された場合\r\n+                if 'boss' in detected_images:\r\n+                    pos = detected_images['boss']['pos']\r\n+                    self.smart_tap_screen(pos[0], pos[1], device_id, \"boss\")\r\n+                    \r\n+                    # play.pngを待機して検索\r\n                     time.sleep(self.delay_var.get())\r\n-                    \r\n-                    # ②play.pngをタップ\r\n                     play_pos = self.find_image_on_screen(self.image_paths['play'], device_id)\r\n                     if play_pos:\r\n                         # stage_45.pngをチェック\r\n                         stage_45_pos = self.find_image_on_screen(self.image_paths['stage_45'], device_id)\r\n                         if stage_45_pos:\r\n                             stage_45_detected = True\r\n                             self.log(\"ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n                         \r\n-                        self.tap_screen(play_pos[0], play_pos[1], device_id)\r\n-                        time.sleep(self.delay_var.get())\r\n+                        self.smart_tap_screen(play_pos[0], play_pos[1], device_id, \"play\")\r\n                         \r\n-                        # ③④のループ\r\n+                        # バトルループ（③④の処理）\r\n+                        self.battle_loop(device_id, puzzle_tap_count)\r\n                         puzzle_tap_count = 0\r\n-                        while self.running and device_id in self.threads:\r\n-                            # ⑤next.pngをチェック\r\n-                            next_pos = self.find_image_on_screen(self.image_paths['next'], device_id)\r\n-                            if next_pos:\r\n-                                self.tap_screen(next_pos[0], next_pos[1], device_id)\r\n-                                stage_45_detected = False  # リセット\r\n-                                break\r\n-                            \r\n-                            # ③puzzle.pngをタップ（2回まで）\r\n-                            if puzzle_tap_count < self.puzzle_count_var.get():\r\n-                                puzzle_pos = self.find_image_on_screen(self.image_paths['puzzle'], device_id)\r\n-                                if puzzle_pos:\r\n-                                    self.tap_screen(puzzle_pos[0], puzzle_pos[1], device_id)\r\n-                                    puzzle_tap_count += 1\r\n-                                    continue\r\n-                            \r\n-                            # ④waza_ok.pngをタップ\r\n-                            waza_ok_pos = self.find_image_on_screen(self.image_paths['waza_ok'], device_id)\r\n-                            if waza_ok_pos:\r\n-                                self.tap_screen(waza_ok_pos[0], waza_ok_pos[1], device_id)\r\n-                                puzzle_tap_count = 0  # リセット\r\n-                            \r\n-                            time.sleep(self.settings['check_interval'])\r\n                 \r\n-                time.sleep(self.settings['check_interval'])\r\n+                # 短い間隔で次のチェック\r\n+                time.sleep(self.check_interval_var.get())\r\n                 \r\n             except Exception as e:\r\n                 self.log(f\"自動化エラー: {str(e)}\", device_id)\r\n-                time.sleep(1)\r\n+                time.sleep(0.5)\r\n         \r\n         self.device_status[device_id] = \"停止\"\r\n         self.log(\"自動化停止\", device_id)\r\n         \r\n+    def battle_loop(self, device_id, initial_puzzle_count=0):\r\n+        \"\"\"バトル中のループ処理（③④の最適化）\"\"\"\r\n+        puzzle_tap_count = initial_puzzle_count\r\n+        battle_start_time = time.time()\r\n+        max_battle_time = 60  # 最大バトル時間（秒）\r\n+        \r\n+        while self.running and device_id in self.threads:\r\n+            # 最大時間チェック\r\n+            if time.time() - battle_start_time > max_battle_time:\r\n+                self.log(\"バトル時間超過 - 次のサイクルに移行\", device_id)\r\n+                break\r\n+            \r\n+            # バトル関連の画像を同時検索\r\n+            battle_images = {\r\n+                'next': self.image_paths['next'],\r\n+                'puzzle': self.image_paths['puzzle'],\r\n+                'waza_ok': self.image_paths['waza_ok']\r\n+            }\r\n+            \r\n+            detected = self.find_multiple_images_on_screen(battle_images, device_id)\r\n+            \r\n+            # next.pngが検出されたらバトル終了\r\n+            if 'next' in detected:\r\n+                pos = detected['next']['pos']\r\n+                self.smart_tap_screen(pos[0], pos[1], device_id, \"next\")\r\n+                break\r\n+            \r\n+            # puzzle.pngをタップ（回数制限あり）\r\n+            if puzzle_tap_count < self.puzzle_count_var.get() and 'puzzle' in detected:\r\n+                pos = detected['puzzle']['pos']\r\n+                self.smart_tap_screen(pos[0], pos[1], device_id, \"puzzle\")\r\n+                puzzle_tap_count += 1\r\n+                continue\r\n+            \r\n+            # waza_ok.pngをタップ\r\n+            if 'waza_ok' in detected:\r\n+                pos = detected['waza_ok']['pos']\r\n+                self.smart_tap_screen(pos[0], pos[1], device_id, \"waza_ok\")\r\n+                puzzle_tap_count = 0  # パズルカウンターリセット\r\n+            \r\n+            time.sleep(self.check_interval_var.get())\r\n+        \r\n     def start_automation(self):\r\n         \"\"\"自動化開始\"\"\"\r\n         selected_devices = self.get_selected_devices()\r\n         if not selected_devices:\r\n@@ -372,13 +464,13 @@\n         \r\n         self.running = True\r\n         self.start_button.config(state=tk.DISABLED)\r\n         self.stop_button.config(state=tk.NORMAL)\r\n-        \r\n-        # 設定を更新\r\n+          # 設定を更新\r\n         self.settings['similarity_threshold'] = self.similarity_var.get()\r\n         self.settings['tap_delay'] = self.delay_var.get()\r\n         self.settings['puzzle_tap_count'] = self.puzzle_count_var.get()\r\n+        self.settings['check_interval'] = self.check_interval_var.get()\r\n         \r\n         # 各デバイスでスレッドを開始\r\n         for device_id in selected_devices:\r\n             thread = threading.Thread(target=self.automation_loop, args=(device_id,))\r\n@@ -401,9 +493,10 @@\n         \"\"\"設定保存\"\"\"\r\n         settings = {\r\n             'similarity_threshold': self.similarity_var.get(),\r\n             'tap_delay': self.delay_var.get(),\r\n-            'puzzle_tap_count': self.puzzle_count_var.get()\r\n+            'puzzle_tap_count': self.puzzle_count_var.get(),\r\n+            'check_interval': self.check_interval_var.get()\r\n         }\r\n         \r\n         try:\r\n             with open('settings.json', 'w', encoding='utf-8') as f:\r\n@@ -415,20 +508,93 @@\n     def load_settings(self):\r\n         \"\"\"設定読込\"\"\"\r\n         try:\r\n             with open('settings.json', 'r', encoding='utf-8') as f:\r\n-                settings = json.load(f)\r\n-            \r\n+                settings = json.load(f)            \r\n             self.similarity_var.set(settings.get('similarity_threshold', 0.8))\r\n-            self.delay_var.set(settings.get('tap_delay', 1.0))\r\n+            self.delay_var.set(settings.get('tap_delay', 0.3))\r\n             self.puzzle_count_var.set(settings.get('puzzle_tap_count', 2))\r\n+            self.check_interval_var.set(settings.get('check_interval', 0.1))\r\n             \r\n             self.log(\"設定を読み込みました\")\r\n         except FileNotFoundError:\r\n             self.log(\"設定ファイルが見つかりません\")\r\n         except Exception as e:\r\n             self.log(f\"設定読込エラー: {str(e)}\")\r\n \r\n+    def setup_memory_capture(self, device_id):\r\n+        \"\"\"メモリ直接キャプチャのセットアップ\"\"\"\r\n+        try:\r\n+            # scrcpyのRAWモードを使用してメモリから直接取得\r\n+            cmd = [\r\n+                'adb', '-s', device_id, 'exec-out', \r\n+                'screencap'\r\n+            ]\r\n+            \r\n+            # プロセスを開始（継続的にデータを取得）\r\n+            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n+            self.minicap_connections[device_id] = process\r\n+            \r\n+            self.log(f\"メモリ直接キャプチャセットアップ完了\", device_id)\r\n+            return True\r\n+            \r\n+        except Exception as e:\r\n+            self.log(f\"メモリキャプチャセットアップエラー: {str(e)}\", device_id)\r\n+            return False\r\n+    \r\n+    def get_memory_screenshot(self, device_id):\r\n+        \"\"\"メモリから直接スクリーンショットを取得\"\"\"\r\n+        try:\r\n+            # ADB exec-outを使用してRAWデータを直接取得\r\n+            result = subprocess.run([\r\n+                'adb', '-s', device_id, 'exec-out', 'screencap'\r\n+            ], capture_output=True, timeout=2)\r\n+            \r\n+            if result.returncode != 0:\r\n+                return None\r\n+            \r\n+            # RAWデータをnumpy配列に変換\r\n+            raw_data = result.stdout\r\n+            \r\n+            if len(raw_data) == 0:\r\n+                return None\r\n+            \r\n+            # PNGヘッダーをチェック\r\n+            if raw_data[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n+                # PNG形式の場合\r\n+                nparr = np.frombuffer(raw_data, np.uint8)\r\n+                screenshot = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\r\n+            else:\r\n+                # RAW形式の可能性がある場合は従来の方法にフォールバック\r\n+                return None\r\n+            \r\n+            return screenshot\r\n+            \r\n+        except subprocess.TimeoutExpired:\r\n+            self.log(f\"メモリキャプチャタイムアウト\", device_id)\r\n+            return None\r\n+        except Exception as e:\r\n+            self.log(f\"メモリキャプチャエラー: {str(e)}\", device_id)\r\n+            return None\r\n+    \r\n+    def fast_screenshot_to_memory(self, device_id):\r\n+        \"\"\"高速スクリーンショット（メモリ直接 or ファイル）\"\"\"\r\n+        if self.memory_capture_var.get():\r\n+            # メモリ直接取得を試行\r\n+            screenshot = self.get_memory_screenshot(device_id)\r\n+            if screenshot is not None:\r\n+                return screenshot\r\n+            \r\n+            # メモリ取得失敗時は従来の方法にフォールバック\r\n+            self.log(f\"メモリ取得失敗 - ファイル方式にフォールバック\", device_id)\r\n+        \r\n+        # 従来のファイル方式\r\n+        screenshot_path = self.take_screenshot(device_id)\r\n+        if screenshot_path:\r\n+            return cv2.imread(screenshot_path)\r\n+        \r\n+        return None\r\n+\r\n def main():\r\n     root = tk.Tk()\r\n     app = PuniPuniAutoPlayer(root)\r\n     \r\n"
                },
                {
                    "date": 1750489395066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -207,66 +207,59 @@\n         except Exception as e:\r\n             self.log(f\"スクリーンショットエラー: {str(e)}\", device_id)\r\n             return None\r\n             \r\n-    def find_image_on_screen(self, template_path, device_id, threshold=None):\r\n-        \"\"\"画面上で画像を検索\"\"\"\r\n+    def find_image_on_screen_optimized(self, template_path, device_id, threshold=None):\r\n+        \"\"\"最適化された画像検索（メモリ直接対応）\"\"\"\r\n         if threshold is None:\r\n             threshold = self.similarity_var.get()\r\n             \r\n-        screenshot_path = self.take_screenshot(device_id)\r\n-        if not screenshot_path:\r\n+        # メモリから直接スクリーンショットを取得\r\n+        screenshot = self.fast_screenshot_to_memory(device_id)\r\n+        if screenshot is None:\r\n             return None\r\n             \r\n         try:\r\n-            # 画像を読み込み\r\n-            screenshot = cv2.imread(screenshot_path)\r\n             template = cv2.imread(template_path)\r\n-            \r\n-            if screenshot is None or template is None:\r\n-                self.log(f\"画像読み込みエラー: {template_path}\", device_id)\r\n+            if template is None:\r\n+                self.log(f\"テンプレート読み込みエラー: {template_path}\", device_id)\r\n                 return None\r\n             \r\n-            # テンプレートマッチング\r\n+            # テンプレートマッチング（高速化）\r\n             result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n             min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n             \r\n             if max_val >= threshold:\r\n-                # マッチした位置の中心座標を計算\r\n                 h, w = template.shape[:2]\r\n                 center_x = max_loc[0] + w // 2\r\n                 center_y = max_loc[1] + h // 2\r\n                 \r\n-                self.log(f\"画像検出: {os.path.basename(template_path)} at ({center_x}, {center_y}) 類似度: {max_val:.3f}\", device_id)\r\n                 return (center_x, center_y)\r\n             else:\r\n                 return None\r\n                 \r\n         except Exception as e:\r\n-            self.log(f\"画像検索エラー: {str(e)}\", device_id)\r\n+            self.log(f\"最適化画像検索エラー: {str(e)}\", device_id)\r\n             return None\r\n             \r\n-    def find_multiple_images_on_screen(self, template_paths, device_id, threshold=None):\r\n-        \"\"\"複数の画像を同時に検索\"\"\"\r\n+    def find_multiple_images_on_screen_optimized(self, template_paths, device_id, threshold=None):\r\n+        \"\"\"最適化された複数画像同時検索（メモリ直接対応）\"\"\"\r\n         if threshold is None:\r\n             threshold = self.similarity_var.get()\r\n             \r\n-        screenshot_path = self.take_screenshot(device_id)\r\n-        if not screenshot_path:\r\n+        # メモリから直接スクリーンショットを取得\r\n+        screenshot = self.fast_screenshot_to_memory(device_id)\r\n+        if screenshot is None:\r\n             return {}\r\n             \r\n         try:\r\n-            screenshot = cv2.imread(screenshot_path)\r\n-            if screenshot is None:\r\n-                return {}\r\n-            \r\n             results = {}\r\n             for name, template_path in template_paths.items():\r\n                 template = cv2.imread(template_path)\r\n                 if template is None:\r\n                     continue\r\n                 \r\n-                # テンプレートマッチング\r\n+                # テンプレートマッチング（高速化）\r\n                 result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n                 min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n                 \r\n                 if max_val >= threshold:\r\n@@ -277,13 +270,17 @@\n                     results[name] = {\r\n                         'pos': (center_x, center_y),\r\n                         'confidence': max_val\r\n                     }\r\n+                    \r\n+                    # ログは最高精度のもののみ表示（ログ量削減）\r\n+                    if max_val > 0.9:\r\n+                        self.log(f\"高精度検出: {name} ({max_val:.3f})\", device_id)\r\n             \r\n             return results\r\n                 \r\n         except Exception as e:\r\n-            self.log(f\"複数画像検索エラー: {str(e)}\", device_id)\r\n+            self.log(f\"最適化複数画像検索エラー: {str(e)}\", device_id)\r\n             return {}\r\n         \"\"\"画面にタップ\"\"\"\r\n         try:\r\n             subprocess.run(['adb', '-s', device_id, 'shell', 'input', 'tap', str(x), str(y)], check=True)\r\n@@ -335,12 +332,20 @@\n         puzzle_tap_count = 0\r\n         stage_45_detected = False\r\n         \r\n         while self.running and device_id in self.threads:\r\n-            try:\r\n-                # 優先度の高い画像を同時検索\r\n+            try:                # 優先度の高い画像を同時検索\r\n                 priority_images = {}\r\n                 \r\n+                # stage_45.pngを最初にチェック\r\n+                stage_45_pos = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n+                if stage_45_pos and not stage_45_detected:\r\n+                    stage_45_detected = True\r\n+                    self.log(\"ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n+                elif not stage_45_pos and stage_45_detected:\r\n+                    stage_45_detected = False\r\n+                    self.log(\"ステージ45終了 - close系ボタンの監視を再開\", device_id)\r\n+                \r\n                 # close系の監視（stage_45検出時は除く）\r\n                 if not stage_45_detected:\r\n                     priority_images['close'] = self.image_paths['close']\r\n                     priority_images['close_mini'] = self.image_paths['close_mini']\r\n@@ -348,12 +353,11 @@\n                 # 現在の状態に応じた画像を追加\r\n                 priority_images['boss'] = self.image_paths['boss']\r\n                 priority_images['play'] = self.image_paths['play']\r\n                 priority_images['next'] = self.image_paths['next']\r\n+                  # 複数画像を同時検索（最適化版）\r\n+                detected_images = self.find_multiple_images_on_screen_optimized(priority_images, device_id)\r\n                 \r\n-                # 複数画像を同時検索\r\n-                detected_images = self.find_multiple_images_on_screen(priority_images, device_id)\r\n-                \r\n                 # 優先順位に従って処理\r\n                 if 'close' in detected_images and not stage_45_detected:\r\n                     pos = detected_images['close']['pos']\r\n                     self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n@@ -374,22 +378,27 @@\n                 \r\n                 # boss.pngが検出された場合\r\n                 if 'boss' in detected_images:\r\n                     pos = detected_images['boss']['pos']\r\n-                    self.smart_tap_screen(pos[0], pos[1], device_id, \"boss\")\r\n-                    \r\n-                    # play.pngを待機して検索\r\n+                    self.smart_tap_screen(pos[0], pos[1], device_id, \"boss\")                    # play.pngを待機して検索（最適化版）\r\n                     time.sleep(self.delay_var.get())\r\n-                    play_pos = self.find_image_on_screen(self.image_paths['play'], device_id)\r\n+                    play_pos = self.find_image_on_screen_optimized(self.image_paths['play'], device_id)\r\n                     if play_pos:\r\n-                        # stage_45.pngをチェック\r\n-                        stage_45_pos = self.find_image_on_screen(self.image_paths['stage_45'], device_id)\r\n+                        # play.pngをタップ前に再度stage_45.pngをチェック\r\n+                        stage_45_pos = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n                         if stage_45_pos:\r\n                             stage_45_detected = True\r\n-                            self.log(\"ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n+                            self.log(\"プレイ前ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n                         \r\n                         self.smart_tap_screen(play_pos[0], play_pos[1], device_id, \"play\")\r\n                         \r\n+                        # プレイ後も再度チェック\r\n+                        time.sleep(self.delay_var.get() * 0.5)\r\n+                        stage_45_pos_after = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n+                        if stage_45_pos_after and not stage_45_detected:\r\n+                            stage_45_detected = True\r\n+                            self.log(\"プレイ後ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n+                        \r\n                         # バトルループ（③④の処理）\r\n                         self.battle_loop(device_id, puzzle_tap_count)\r\n                         puzzle_tap_count = 0\r\n                 \r\n@@ -407,24 +416,49 @@\n         \"\"\"バトル中のループ処理（③④の最適化）\"\"\"\r\n         puzzle_tap_count = initial_puzzle_count\r\n         battle_start_time = time.time()\r\n         max_battle_time = 60  # 最大バトル時間（秒）\r\n+        stage_45_in_battle = False\r\n         \r\n         while self.running and device_id in self.threads:\r\n             # 最大時間チェック\r\n             if time.time() - battle_start_time > max_battle_time:\r\n                 self.log(\"バトル時間超過 - 次のサイクルに移行\", device_id)\r\n                 break\r\n             \r\n+            # バトル開始時にstage_45をチェック\r\n+            if not stage_45_in_battle:\r\n+                stage_45_pos = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n+                if stage_45_pos:\r\n+                    stage_45_in_battle = True\r\n+                    self.log(\"バトル中ステージ45検出 - close系監視停止\", device_id)\r\n+            \r\n             # バトル関連の画像を同時検索\r\n             battle_images = {\r\n                 'next': self.image_paths['next'],\r\n                 'puzzle': self.image_paths['puzzle'],\r\n                 'waza_ok': self.image_paths['waza_ok']\r\n             }\r\n             \r\n-            detected = self.find_multiple_images_on_screen(battle_images, device_id)\r\n+            # stage_45が検出されていない場合のみclose系を追加\r\n+            if not stage_45_in_battle:\r\n+                battle_images['close'] = self.image_paths['close']\r\n+                battle_images['close_mini'] = self.image_paths['close_mini']\r\n             \r\n+            detected = self.find_multiple_images_on_screen_optimized(battle_images, device_id)\r\n+            \r\n+            # close系の処理（stage_45が検出されていない場合のみ）\r\n+            if not stage_45_in_battle:\r\n+                if 'close' in detected:\r\n+                    pos = detected['close']['pos']\r\n+                    self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n+                    continue\r\n+                    \r\n+                if 'close_mini' in detected:\r\n+                    pos = detected['close_mini']['pos']\r\n+                    self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n+                    continue\r\n+            \r\n             # next.pngが検出されたらバトル終了\r\n             if 'next' in detected:\r\n                 pos = detected['next']['pos']\r\n                 self.smart_tap_screen(pos[0], pos[1], device_id, \"next\")\r\n@@ -463,14 +497,14 @@\n             return\r\n         \r\n         self.running = True\r\n         self.start_button.config(state=tk.DISABLED)\r\n-        self.stop_button.config(state=tk.NORMAL)\r\n-          # 設定を更新\r\n+        self.stop_button.config(state=tk.NORMAL)        # 設定を更新\r\n         self.settings['similarity_threshold'] = self.similarity_var.get()\r\n         self.settings['tap_delay'] = self.delay_var.get()\r\n         self.settings['puzzle_tap_count'] = self.puzzle_count_var.get()\r\n         self.settings['check_interval'] = self.check_interval_var.get()\r\n+        self.settings['use_memory_capture'] = self.memory_capture_var.get()\r\n         \r\n         # 各デバイスでスレッドを開始\r\n         for device_id in selected_devices:\r\n             thread = threading.Thread(target=self.automation_loop, args=(device_id,))\r\n@@ -494,9 +528,10 @@\n         settings = {\r\n             'similarity_threshold': self.similarity_var.get(),\r\n             'tap_delay': self.delay_var.get(),\r\n             'puzzle_tap_count': self.puzzle_count_var.get(),\r\n-            'check_interval': self.check_interval_var.get()\r\n+            'check_interval': self.check_interval_var.get(),\r\n+            'use_memory_capture': self.memory_capture_var.get()\r\n         }\r\n         \r\n         try:\r\n             with open('settings.json', 'w', encoding='utf-8') as f:\r\n@@ -508,13 +543,15 @@\n     def load_settings(self):\r\n         \"\"\"設定読込\"\"\"\r\n         try:\r\n             with open('settings.json', 'r', encoding='utf-8') as f:\r\n-                settings = json.load(f)            \r\n+                settings = json.load(f)\r\n+            \r\n             self.similarity_var.set(settings.get('similarity_threshold', 0.8))\r\n             self.delay_var.set(settings.get('tap_delay', 0.3))\r\n             self.puzzle_count_var.set(settings.get('puzzle_tap_count', 2))\r\n             self.check_interval_var.set(settings.get('check_interval', 0.1))\r\n+            self.memory_capture_var.set(settings.get('use_memory_capture', True))\r\n             \r\n             self.log(\"設定を読み込みました\")\r\n         except FileNotFoundError:\r\n             self.log(\"設定ファイルが見つかりません\")\r\n@@ -539,61 +576,154 @@\n             \r\n         except Exception as e:\r\n             self.log(f\"メモリキャプチャセットアップエラー: {str(e)}\", device_id)\r\n             return False\r\n-    \r\n     def get_memory_screenshot(self, device_id):\r\n-        \"\"\"メモリから直接スクリーンショットを取得\"\"\"\r\n+        \"\"\"メモリから直接スクリーンショットを取得（改良版）\"\"\"\r\n         try:\r\n-            # ADB exec-outを使用してRAWデータを直接取得\r\n+            # 方法1: ADB exec-outを使用してRAWデータを直接取得\r\n             result = subprocess.run([\r\n                 'adb', '-s', device_id, 'exec-out', 'screencap'\r\n-            ], capture_output=True, timeout=2)\r\n+            ], capture_output=True, timeout=3)\r\n             \r\n-            if result.returncode != 0:\r\n-                return None\r\n+            if result.returncode == 0 and len(result.stdout) > 0:\r\n+                raw_data = result.stdout\r\n+                \r\n+                # PNGヘッダーをチェック\r\n+                if raw_data[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n+                    # PNG形式の場合\r\n+                    nparr = np.frombuffer(raw_data, np.uint8)\r\n+                    screenshot = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\r\n+                    if screenshot is not None:\r\n+                        return screenshot\r\n+                \r\n+                # RAW形式の場合のパース（Android 4.4以降）\r\n+                if len(raw_data) >= 12:\r\n+                    # ヘッダー情報を解析\r\n+                    width = struct.unpack('<I', raw_data[0:4])[0]\r\n+                    height = struct.unpack('<I', raw_data[4:8])[0]\r\n+                    pixel_format = struct.unpack('<I', raw_data[8:12])[0]\r\n+                    \r\n+                    # 妥当性チェック\r\n+                    if 100 <= width <= 4096 and 100 <= height <= 4096:\r\n+                        if pixel_format == 1:  # RGBA_8888\r\n+                            expected_size = width * height * 4 + 12\r\n+                            if len(raw_data) >= expected_size:\r\n+                                # RGBA データを抽出\r\n+                                image_data = raw_data[12:12 + width * height * 4]\r\n+                                # numpy配列に変換\r\n+                                img_array = np.frombuffer(image_data, dtype=np.uint8)\r\n+                                img_array = img_array.reshape((height, width, 4))\r\n+                                # BGRAからBGRに変換（Alphaチャンネル削除）\r\n+                                screenshot = cv2.cvtColor(img_array, cv2.COLOR_RGBA2BGR)\r\n+                                return screenshot\r\n             \r\n-            # RAWデータをnumpy配列に変換\r\n-            raw_data = result.stdout\r\n+            # 方法2: shellコマンドでscreencapを実行してファイル取得を避ける\r\n+            result2 = subprocess.run([\r\n+                'adb', '-s', device_id, 'shell', 'screencap', '-p'\r\n+            ], capture_output=True, timeout=3)\r\n             \r\n-            if len(raw_data) == 0:\r\n-                return None\r\n+            if result2.returncode == 0 and len(result2.stdout) > 0:\r\n+                # base64形式でない場合の処理\r\n+                raw_data = result2.stdout\r\n+                if raw_data[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n+                    nparr = np.frombuffer(raw_data, np.uint8)\r\n+                    screenshot = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\r\n+                    if screenshot is not None:\r\n+                        return screenshot\r\n+                        \r\n+            return None\r\n             \r\n-            # PNGヘッダーをチェック\r\n-            if raw_data[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n-                # PNG形式の場合\r\n-                nparr = np.frombuffer(raw_data, np.uint8)\r\n-                screenshot = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\r\n-            else:\r\n-                # RAW形式の可能性がある場合は従来の方法にフォールバック\r\n-                return None\r\n-            \r\n-            return screenshot\r\n-            \r\n         except subprocess.TimeoutExpired:\r\n             self.log(f\"メモリキャプチャタイムアウト\", device_id)\r\n             return None\r\n         except Exception as e:\r\n             self.log(f\"メモリキャプチャエラー: {str(e)}\", device_id)\r\n             return None\r\n-    \r\n     def fast_screenshot_to_memory(self, device_id):\r\n-        \"\"\"高速スクリーンショット（メモリ直接 or ファイル）\"\"\"\r\n+        \"\"\"高速スクリーンショット（メモリ直接 or ファイル）改良版\"\"\"\r\n         if self.memory_capture_var.get():\r\n             # メモリ直接取得を試行\r\n             screenshot = self.get_memory_screenshot(device_id)\r\n             if screenshot is not None:\r\n+                # メモリ取得成功のログ（初回のみ）\r\n+                if not hasattr(self, '_memory_success_logged'):\r\n+                    self.log(f\"メモリ直接取得成功\", device_id)\r\n+                    self._memory_success_logged = True\r\n                 return screenshot\r\n             \r\n-            # メモリ取得失敗時は従来の方法にフォールバック\r\n-            self.log(f\"メモリ取得失敗 - ファイル方式にフォールバック\", device_id)\r\n+            # メモリ取得失敗時は従来の方法にフォールバック（ログは最初の数回のみ）\r\n+            if not hasattr(self, '_fallback_count'):\r\n+                self._fallback_count = 0\r\n+            \r\n+            if self._fallback_count < 3:  # 最初の3回のみログ出力\r\n+                self.log(f\"メモリ取得失敗 - ファイル方式にフォールバック ({self._fallback_count + 1}/3)\", device_id)\r\n+                self._fallback_count += 1\r\n         \r\n-        # 従来のファイル方式\r\n-        screenshot_path = self.take_screenshot(device_id)\r\n+        # 従来のファイル方式（高速化版）\r\n+        screenshot_path = self.take_screenshot_fast(device_id)\r\n         if screenshot_path:\r\n             return cv2.imread(screenshot_path)\r\n         \r\n         return None\r\n+    \r\n+    def take_screenshot_fast(self, device_id):\r\n+        \"\"\"高速ファイルベーススクリーンショット\"\"\"\r\n+        try:\r\n+            # テンポラリファイル名を使用\r\n+            temp_name = f'/sdcard/temp_screenshot_{int(time.time() * 1000) % 10000}.png'\r\n+            local_path = f'temp_screenshot_{device_id}.png'\r\n+            \r\n+            # 高速スクリーンショット取得\r\n+            subprocess.run(['adb', '-s', device_id, 'shell', 'screencap', temp_name], \r\n+                         check=True, capture_output=True, timeout=3)\r\n+            subprocess.run(['adb', '-s', device_id, 'pull', temp_name, local_path], \r\n+                         check=True, capture_output=True, timeout=3)\r\n+            \r\n+            # デバイス上のテンポラリファイルを削除\r\n+            subprocess.run(['adb', '-s', device_id, 'shell', 'rm', temp_name], \r\n+                         capture_output=True, timeout=1)\r\n+            \r\n+            return local_path\r\n+            \r\n+        except (subprocess.TimeoutExpired, subprocess.CalledProcessError) as e:\r\n+            self.log(f\"高速スクリーンショットエラー: {str(e)}\", device_id)\r\n+            return None\r\n+    def check_device_memory_support(self, device_id):\r\n+        \"\"\"デバイスのメモリ直接取得サポートをチェック\"\"\"\r\n+        try:\r\n+            # Androidバージョンを取得\r\n+            result = subprocess.run([\r\n+                'adb', '-s', device_id, 'shell', 'getprop', 'ro.build.version.release'\r\n+            ], capture_output=True, text=True, timeout=5)\r\n+            \r\n+            if result.returncode == 0:\r\n+                android_version = result.stdout.strip()\r\n+                self.log(f\"Androidバージョン: {android_version}\", device_id)\r\n+                \r\n+                # Android 4.4以降でexec-outをサポート\r\n+                try:\r\n+                    version_num = float(android_version.split('.')[0])\r\n+                    if version_num >= 4:\r\n+                        return True\r\n+                except:\r\n+                    pass\r\n+            \r\n+            # exec-outコマンドが使用可能かテスト\r\n+            test_result = subprocess.run([\r\n+                'adb', '-s', device_id, 'exec-out', 'echo', 'test'\r\n+            ], capture_output=True, timeout=3)\r\n+            \r\n+            if test_result.returncode == 0 and b'test' in test_result.stdout:\r\n+                self.log(f\"exec-outコマンド利用可能\", device_id)\r\n+                return True\r\n+            else:\r\n+                self.log(f\"exec-outコマンド利用不可 - ファイル方式を使用\", device_id)\r\n+                return False\r\n+                \r\n+        except Exception as e:\r\n+            self.log(f\"デバイス互換性チェックエラー: {str(e)}\", device_id)\r\n+            return False\r\n \r\n def main():\r\n     root = tk.Tk()\r\n     app = PuniPuniAutoPlayer(root)\r\n"
                },
                {
                    "date": 1750489496127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,13 +48,14 @@\n         \r\n         # スクリーンショットキャッシュ\r\n         self.screenshot_cache = {}\r\n         self.last_screenshot_time = {}\r\n-        \r\n-        # メモリ直接アクセス用の設定\r\n+          # メモリ直接アクセス用の設定\r\n         self.use_memory_capture = True  # メモリ直接取得を有効化\r\n         self.minicap_connections = {}  # デバイスごとのminicap接続\r\n         self.raw_capture_enabled = False  # RAWキャプチャフラグ\r\n+        self.device_compatibility = {}  # デバイス互換性情報\r\n+        self.fallback_count = {}  # フォールバック回数の記録\r\n         \r\n         self.create_widgets()\r\n         self.refresh_devices()\r\n         \r\n@@ -494,18 +495,25 @@\n         \r\n         if missing_files:\r\n             messagebox.showerror(\"エラー\", f\"画像ファイルが見つかりません:\\n\" + \"\\n\".join(missing_files))\r\n             return\r\n+          self.running = True\r\n+        self.start_button.config(state=tk.DISABLED)\r\n+        self.stop_button.config(state=tk.NORMAL)\r\n         \r\n-        self.running = True\r\n-        self.start_button.config(state=tk.DISABLED)\r\n-        self.stop_button.config(state=tk.NORMAL)        # 設定を更新\r\n+        # 設定を更新\r\n         self.settings['similarity_threshold'] = self.similarity_var.get()\r\n         self.settings['tap_delay'] = self.delay_var.get()\r\n         self.settings['puzzle_tap_count'] = self.puzzle_count_var.get()\r\n         self.settings['check_interval'] = self.check_interval_var.get()\r\n         self.settings['use_memory_capture'] = self.memory_capture_var.get()\r\n         \r\n+        # デバイス互換性チェック\r\n+        if self.memory_capture_var.get():\r\n+            for device_id in selected_devices:\r\n+                if not self.check_device_memory_support(device_id):\r\n+                    self.log(f\"メモリ直接取得非対応 - ファイル方式で動作\", device_id)\r\n+        \r\n         # 各デバイスでスレッドを開始\r\n         for device_id in selected_devices:\r\n             thread = threading.Thread(target=self.automation_loop, args=(device_id,))\r\n             thread.daemon = True\r\n@@ -722,9 +730,55 @@\n                 \r\n         except Exception as e:\r\n             self.log(f\"デバイス互換性チェックエラー: {str(e)}\", device_id)\r\n             return False\r\n+    def check_device_compatibility(self, device_id):\r\n+        \"\"\"デバイスの互換性チェック\"\"\"\r\n+        if device_id in self.device_compatibility:\r\n+            return self.device_compatibility[device_id]\r\n+        \r\n+        compatibility = {\r\n+            'exec_out_supported': False,\r\n+            'android_version': 'unknown',\r\n+            'memory_capture_supported': False,\r\n+            'reason': ''\r\n+        }\r\n+        \r\n+        try:\r\n+            # Androidバージョンを取得\r\n+            result = subprocess.run([self.adb_path, '-s', device_id, 'shell', 'getprop', 'ro.build.version.release'],\r\n+                                  capture_output=True, text=True, timeout=10)\r\n+            if result.returncode == 0:\r\n+                compatibility['android_version'] = result.stdout.strip()\r\n+            \r\n+            # exec-out screencapコマンドの動作テスト\r\n+            result = subprocess.run([self.adb_path, '-s', device_id, 'exec-out', 'screencap', '-p'],\r\n+                                  capture_output=True, timeout=15)\r\n+            \r\n+            if result.returncode == 0 and len(result.stdout) > 1000:  # 最小限の画像データサイズ\r\n+                compatibility['exec_out_supported'] = True\r\n+                compatibility['memory_capture_supported'] = True\r\n+                compatibility['reason'] = 'Memory capture fully supported'\r\n+            else:\r\n+                compatibility['reason'] = f'exec-out failed (returncode: {result.returncode})'\r\n+                \r\n+        except subprocess.TimeoutExpired:\r\n+            compatibility['reason'] = 'Command timeout'\r\n+        except Exception as e:\r\n+            compatibility['reason'] = f'Error: {str(e)}'\r\n+        \r\n+        self.device_compatibility[device_id] = compatibility\r\n+        return compatibility\r\n \r\n+    def log_device_compatibility(self, device_id):\r\n+        \"\"\"デバイス互換性情報をログ出力\"\"\"\r\n+        compat = self.check_device_compatibility(device_id)\r\n+        self.log(f\"デバイス互換性チェック: Android {compat['android_version']}\", device_id)\r\n+        if compat['memory_capture_supported']:\r\n+            self.log(\"メモリ直接取得: サポート\", device_id)\r\n+        else:\r\n+            self.log(f\"メモリ直接取得: 非サポート - {compat['reason']}\", device_id)\r\n+            self.log(\"通常のファイル方式を使用します\", device_id)\r\n def main():\r\n     root = tk.Tk()\r\n     app = PuniPuniAutoPlayer(root)\r\n     \r\n"
                },
                {
                    "date": 1750489880387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -495,9 +495,10 @@\n         \r\n         if missing_files:\r\n             messagebox.showerror(\"エラー\", f\"画像ファイルが見つかりません:\\n\" + \"\\n\".join(missing_files))\r\n             return\r\n-          self.running = True\r\n+        \r\n+        self.running = True\r\n         self.start_button.config(state=tk.DISABLED)\r\n         self.stop_button.config(state=tk.NORMAL)\r\n         \r\n         # 設定を更新\r\n@@ -505,14 +506,21 @@\n         self.settings['tap_delay'] = self.delay_var.get()\r\n         self.settings['puzzle_tap_count'] = self.puzzle_count_var.get()\r\n         self.settings['check_interval'] = self.check_interval_var.get()\r\n         self.settings['use_memory_capture'] = self.memory_capture_var.get()\r\n-        \r\n-        # デバイス互換性チェック\r\n+          # デバイス互換性チェック\r\n+        for device_id in selected_devices:\r\n+            self.log_device_compatibility(device_id)\r\n+            \r\n+        # メモリ直接取得の警告\r\n         if self.memory_capture_var.get():\r\n-            for device_id in selected_devices:\r\n-                if not self.check_device_memory_support(device_id):\r\n-                    self.log(f\"メモリ直接取得非対応 - ファイル方式で動作\", device_id)\r\n+            memory_supported_devices = [\r\n+                device_id for device_id in selected_devices \r\n+                if self.device_compatibility.get(device_id, {}).get('memory_capture_supported', False)\r\n+            ]\r\n+            if not memory_supported_devices:\r\n+                self.log(\"警告: メモリ直接取得をサポートするデバイスがありません\")\r\n+                self.log(\"すべてのデバイスでファイル方式を使用します\")\r\n         \r\n         # 各デバイスでスレッドを開始\r\n         for device_id in selected_devices:\r\n             thread = threading.Thread(target=self.automation_loop, args=(device_id,))\r\n@@ -646,27 +654,34 @@\n             return None\r\n         except Exception as e:\r\n             self.log(f\"メモリキャプチャエラー: {str(e)}\", device_id)\r\n             return None\r\n+    \r\n     def fast_screenshot_to_memory(self, device_id):\r\n         \"\"\"高速スクリーンショット（メモリ直接 or ファイル）改良版\"\"\"\r\n-        if self.memory_capture_var.get():\r\n-            # メモリ直接取得を試行\r\n+        # 互換性チェック\r\n+        if device_id not in self.device_compatibility:\r\n+            self.log_device_compatibility(device_id)\r\n+        \r\n+        # メモリ直接取得を試行（サポートされている場合のみ）\r\n+        if (self.memory_capture_var.get() and \r\n+            self.device_compatibility.get(device_id, {}).get('memory_capture_supported', False)):\r\n+            \r\n             screenshot = self.get_memory_screenshot(device_id)\r\n             if screenshot is not None:\r\n                 # メモリ取得成功のログ（初回のみ）\r\n                 if not hasattr(self, '_memory_success_logged'):\r\n                     self.log(f\"メモリ直接取得成功\", device_id)\r\n                     self._memory_success_logged = True\r\n                 return screenshot\r\n-            \r\n-            # メモリ取得失敗時は従来の方法にフォールバック（ログは最初の数回のみ）\r\n-            if not hasattr(self, '_fallback_count'):\r\n-                self._fallback_count = 0\r\n-            \r\n-            if self._fallback_count < 3:  # 最初の3回のみログ出力\r\n-                self.log(f\"メモリ取得失敗 - ファイル方式にフォールバック ({self._fallback_count + 1}/3)\", device_id)\r\n-                self._fallback_count += 1\r\n+            else:\r\n+                # フォールバック回数を記録\r\n+                self.fallback_count[device_id] = self.fallback_count.get(device_id, 0) + 1\r\n+                \r\n+                # 連続失敗時は一時的にメモリ取得を無効化\r\n+                if self.fallback_count[device_id] >= 5:\r\n+                    self.device_compatibility[device_id]['memory_capture_supported'] = False\r\n+                    self.log(\"メモリ取得を一時無効化（連続失敗）\", device_id)\r\n         \r\n         # 従来のファイル方式（高速化版）\r\n         screenshot_path = self.take_screenshot_fast(device_id)\r\n         if screenshot_path:\r\n@@ -744,15 +759,15 @@\n         }\r\n         \r\n         try:\r\n             # Androidバージョンを取得\r\n-            result = subprocess.run([self.adb_path, '-s', device_id, 'shell', 'getprop', 'ro.build.version.release'],\r\n+            result = subprocess.run(['adb', '-s', device_id, 'shell', 'getprop', 'ro.build.version.release'],\r\n                                   capture_output=True, text=True, timeout=10)\r\n             if result.returncode == 0:\r\n                 compatibility['android_version'] = result.stdout.strip()\r\n             \r\n             # exec-out screencapコマンドの動作テスト\r\n-            result = subprocess.run([self.adb_path, '-s', device_id, 'exec-out', 'screencap', '-p'],\r\n+            result = subprocess.run(['adb', '-s', device_id, 'exec-out', 'screencap', '-p'],\r\n                                   capture_output=True, timeout=15)\r\n             \r\n             if result.returncode == 0 and len(result.stdout) > 1000:  # 最小限の画像データサイズ\r\n                 compatibility['exec_out_supported'] = True\r\n@@ -777,8 +792,67 @@\n             self.log(\"メモリ直接取得: サポート\", device_id)\r\n         else:\r\n             self.log(f\"メモリ直接取得: 非サポート - {compat['reason']}\", device_id)\r\n             self.log(\"通常のファイル方式を使用します\", device_id)\r\n+    def diagnostic_memory_capture(self, device_id):\r\n+        \"\"\"メモリ直接取得の診断情報を表示\"\"\"\r\n+        self.log(\"=== メモリ直接取得診断 ===\", device_id)\r\n+        \r\n+        try:\r\n+            # 1. デバイス情報取得\r\n+            info_cmd = ['adb', '-s', device_id, 'shell', 'getprop']\r\n+            result = subprocess.run(info_cmd, capture_output=True, text=True, timeout=5)\r\n+            if result.returncode == 0:\r\n+                lines = result.stdout.split('\\n')\r\n+                for line in lines:\r\n+                    if 'ro.build.version.release' in line or 'ro.build.version.sdk' in line:\r\n+                        self.log(f\"デバイス情報: {line.strip()}\", device_id)\r\n+            \r\n+            # 2. exec-outコマンドのサポート確認\r\n+            test_cmd = ['adb', '-s', device_id, 'exec-out', 'echo', 'test']\r\n+            result = subprocess.run(test_cmd, capture_output=True, timeout=3)\r\n+            if result.returncode == 0:\r\n+                self.log(\"exec-out コマンド: サポート\", device_id)\r\n+            else:\r\n+                self.log(f\"exec-out コマンド: 非サポート (code: {result.returncode})\", device_id)\r\n+            \r\n+            # 3. screencapコマンドの直接実行\r\n+            screencap_cmd = ['adb', '-s', device_id, 'shell', 'screencap', '-h']\r\n+            result = subprocess.run(screencap_cmd, capture_output=True, text=True, timeout=3)\r\n+            if result.returncode == 0:\r\n+                self.log(\"screencap コマンド: 利用可能\", device_id)\r\n+            else:\r\n+                self.log(f\"screencap コマンド: エラー (code: {result.returncode})\", device_id)\r\n+            \r\n+            # 4. 実際のメモリ取得を試行\r\n+            memory_cmd = ['adb', '-s', device_id, 'exec-out', 'screencap']\r\n+            result = subprocess.run(memory_cmd, capture_output=True, timeout=5)\r\n+            \r\n+            if result.returncode == 0:\r\n+                data_size = len(result.stdout)\r\n+                self.log(f\"メモリ取得: 成功 (データサイズ: {data_size} bytes)\", device_id)\r\n+                \r\n+                if data_size > 0:\r\n+                    # データ形式を確認\r\n+                    header = result.stdout[:16]\r\n+                    self.log(f\"データヘッダー: {header}\", device_id)\r\n+                    \r\n+                    if header[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n+                        self.log(\"データ形式: PNG\", device_id)\r\n+                    else:\r\n+                        self.log(\"データ形式: RAW (もしくは不明)\", device_id)\r\n+                else:\r\n+                    self.log(\"メモリ取得: データが空\", device_id)\r\n+            else:\r\n+                self.log(f\"メモリ取得: 失敗 (code: {result.returncode})\", device_id)\r\n+                if result.stderr:\r\n+                    error_msg = result.stderr.decode('utf-8', errors='ignore')\r\n+                    self.log(f\"エラー詳細: {error_msg}\", device_id)\r\n+            \r\n+        except Exception as e:\r\n+            self.log(f\"診断エラー: {str(e)}\", device_id)\r\n+        \r\n+        self.log(\"=== 診断終了 ===\", device_id)\r\n def main():\r\n     root = tk.Tk()\r\n     app = PuniPuniAutoPlayer(root)\r\n     \r\n"
                },
                {
                    "date": 1750489943660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,11 +115,13 @@\n         self.stop_button.grid(row=0, column=1, pady=(0, 5))\r\n         \r\n         ttk.Button(control_frame, text=\"スクリーンショット\", command=self.take_screenshot).grid(row=1, column=0, columnspan=2, pady=(0, 5))\r\n         \r\n-        ttk.Button(control_frame, text=\"設定保存\", command=self.save_settings).grid(row=2, column=0, padx=(0, 5))\r\n-        ttk.Button(control_frame, text=\"設定読込\", command=self.load_settings).grid(row=2, column=1)\r\n+        ttk.Button(control_frame, text=\"メモリ診断\", command=self.run_memory_diagnostic).grid(row=2, column=0, columnspan=2, pady=(0, 5))\r\n         \r\n+        ttk.Button(control_frame, text=\"設定保存\", command=self.save_settings).grid(row=3, column=0, padx=(0, 5))\r\n+        ttk.Button(control_frame, text=\"設定読込\", command=self.load_settings).grid(row=3, column=1)\r\n+        \r\n         # ログフレーム\r\n         log_frame = ttk.LabelFrame(main_frame, text=\"ログ\", padding=\"5\")\r\n         log_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(10, 0))\r\n         \r\n@@ -851,8 +853,19 @@\n         except Exception as e:\r\n             self.log(f\"診断エラー: {str(e)}\", device_id)\r\n         \r\n         self.log(\"=== 診断終了 ===\", device_id)\r\n+    \r\n+    def run_memory_diagnostic(self):\r\n+        \"\"\"メモリ診断を実行\"\"\"\r\n+        selected_devices = self.get_selected_devices()\r\n+        if not selected_devices:\r\n+            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n+            return\r\n+        \r\n+        self.log(\"メモリ直接取得の診断を開始します\")\r\n+        for device_id in selected_devices:\r\n+            self.diagnostic_memory_capture(device_id)\r\n def main():\r\n     root = tk.Tk()\r\n     app = PuniPuniAutoPlayer(root)\r\n     \r\n"
                },
                {
                    "date": 1750490152603,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -355,12 +355,36 @@\n                 \r\n                 # 現在の状態に応じた画像を追加\r\n                 priority_images['boss'] = self.image_paths['boss']\r\n                 priority_images['play'] = self.image_paths['play']\r\n-                priority_images['next'] = self.image_paths['next']\r\n-                  # 複数画像を同時検索（最適化版）\r\n+                priority_images['next'] = self.image_paths['next']                # 複数画像を同時検索（最適化版）\r\n                 detected_images = self.find_multiple_images_on_screen_optimized(priority_images, device_id)\r\n                 \r\n+                # playボタンを直接検出した場合の処理を追加\r\n+                if 'play' in detected_images:\r\n+                    self.log(\"playボタンを直接検出しました\", device_id)\r\n+                    pos = detected_images['play']['pos']\r\n+                    \r\n+                    # play.pngをタップ前に再度stage_45.pngをチェック\r\n+                    stage_45_pos = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n+                    if stage_45_pos:\r\n+                        stage_45_detected = True\r\n+                        self.log(\"プレイ前ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n+                    \r\n+                    self.smart_tap_screen(pos[0], pos[1], device_id, \"play\")\r\n+                    \r\n+                    # プレイ後も再度チェック\r\n+                    time.sleep(self.delay_var.get() * 0.5)\r\n+                    stage_45_pos_after = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n+                    if stage_45_pos_after and not stage_45_detected:\r\n+                        stage_45_detected = True\r\n+                        self.log(\"プレイ後ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n+                    \r\n+                    # バトルループ（③④の処理）\r\n+                    self.battle_loop(device_id, puzzle_tap_count)\r\n+                    puzzle_tap_count = 0\r\n+                    continue\r\n+                \r\n                 # 優先順位に従って処理\r\n                 if 'close' in detected_images and not stage_45_detected:\r\n                     pos = detected_images['close']['pos']\r\n                     self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n@@ -377,34 +401,66 @@\n                     self.smart_tap_screen(pos[0], pos[1], device_id, \"next\")\r\n                     stage_45_detected = False  # リセット\r\n                     puzzle_tap_count = 0\r\n                     continue\r\n-                \r\n-                # boss.pngが検出された場合\r\n+                  # boss.pngが検出された場合\r\n                 if 'boss' in detected_images:\r\n                     pos = detected_images['boss']['pos']\r\n-                    self.smart_tap_screen(pos[0], pos[1], device_id, \"boss\")                    # play.pngを待機して検索（最適化版）\r\n-                    time.sleep(self.delay_var.get())\r\n-                    play_pos = self.find_image_on_screen_optimized(self.image_paths['play'], device_id)\r\n-                    if play_pos:\r\n-                        # play.pngをタップ前に再度stage_45.pngをチェック\r\n-                        stage_45_pos = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n-                        if stage_45_pos:\r\n-                            stage_45_detected = True\r\n-                            self.log(\"プレイ前ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n+                    self.smart_tap_screen(pos[0], pos[1], device_id, \"boss\")\r\n+                    \r\n+                    # play.pngを待機して検索（最適化版・強化）\r\n+                    self.log(\"boss検出後、playボタンを検索中...\", device_id)\r\n+                    play_found = False\r\n+                    max_attempts = 10  # 最大試行回数\r\n+                    \r\n+                    for attempt in range(max_attempts):\r\n+                        time.sleep(0.5)  # 画面遷移を待つ\r\n+                        play_pos = self.find_image_on_screen_optimized(self.image_paths['play'], device_id)\r\n                         \r\n-                        self.smart_tap_screen(play_pos[0], play_pos[1], device_id, \"play\")\r\n-                        \r\n-                        # プレイ後も再度チェック\r\n-                        time.sleep(self.delay_var.get() * 0.5)\r\n-                        stage_45_pos_after = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n-                        if stage_45_pos_after and not stage_45_detected:\r\n-                            stage_45_detected = True\r\n-                            self.log(\"プレイ後ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n-                        \r\n-                        # バトルループ（③④の処理）\r\n-                        self.battle_loop(device_id, puzzle_tap_count)\r\n-                        puzzle_tap_count = 0\r\n+                        if play_pos:\r\n+                            self.log(f\"playボタン検出成功 (試行{attempt + 1}回目): {play_pos}\", device_id)\r\n+                            play_found = True\r\n+                            \r\n+                            # play.pngをタップ前に再度stage_45.pngをチェック\r\n+                            stage_45_pos = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n+                            if stage_45_pos:\r\n+                                stage_45_detected = True\r\n+                                self.log(\"プレイ前ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n+                            \r\n+                            self.smart_tap_screen(play_pos[0], play_pos[1], device_id, \"play\")\r\n+                            \r\n+                            # プレイ後も再度チェック\r\n+                            time.sleep(self.delay_var.get() * 0.5)\r\n+                            stage_45_pos_after = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n+                            if stage_45_pos_after and not stage_45_detected:\r\n+                                stage_45_detected = True\r\n+                                self.log(\"プレイ後ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n+                            \r\n+                            # バトルループ（③④の処理）\r\n+                            self.battle_loop(device_id, puzzle_tap_count)\r\n+                            puzzle_tap_count = 0\r\n+                            break\r\n+                        else:\r\n+                            self.log(f\"playボタン未検出 (試行{attempt + 1}回目)\", device_id)\r\n+                            \r\n+                            # close系ボタンがあればタップして再試行\r\n+                            close_images = {\r\n+                                'close': self.image_paths['close'],\r\n+                                'close_mini': self.image_paths['close_mini']\r\n+                            }\r\n+                            close_detected = self.find_multiple_images_on_screen_optimized(close_images, device_id)\r\n+                            \r\n+                            if 'close' in close_detected:\r\n+                                self.log(\"playボタン待機中にcloseボタンを検出、タップします\", device_id)\r\n+                                close_pos = close_detected['close']['pos']\r\n+                                self.smart_tap_screen(close_pos[0], close_pos[1], device_id, \"close\")\r\n+                            elif 'close_mini' in close_detected:\r\n+                                self.log(\"playボタン待機中にclose_miniボタンを検出、タップします\", device_id)\r\n+                                close_pos = close_detected['close_mini']['pos']\r\n+                                self.smart_tap_screen(close_pos[0], close_pos[1], device_id, \"close\")\r\n+                    \r\n+                    if not play_found:\r\n+                        self.log(f\"playボタンが見つかりませんでした（{max_attempts}回試行）\", device_id)\r\n                 \r\n                 # 短い間隔で次のチェック\r\n                 time.sleep(self.check_interval_var.get())\r\n                 \r\n@@ -864,8 +920,30 @@\n         \r\n         self.log(\"メモリ直接取得の診断を開始します\")\r\n         for device_id in selected_devices:\r\n             self.diagnostic_memory_capture(device_id)\r\n+    \r\n+    def find_image_with_multiple_thresholds(self, template_path, device_id, initial_threshold=None):\r\n+        \"\"\"複数の閾値でplayボタンを検索（段階的に閾値を下げる）\"\"\"\r\n+        if initial_threshold is None:\r\n+            initial_threshold = self.similarity_var.get()\r\n+        \r\n+        # 段階的に閾値を下げて検索\r\n+        thresholds = [initial_threshold, initial_threshold - 0.1, initial_threshold - 0.2, 0.6]\r\n+        \r\n+        for threshold in thresholds:\r\n+            if threshold < 0.5:  # 最低限の閾値\r\n+                break\r\n+                \r\n+            result = self.find_image_on_screen_optimized(template_path, device_id, threshold)\r\n+            if result:\r\n+                self.log(f\"画像検出成功 (閾値: {threshold:.2f}): {template_path}\", device_id)\r\n+                return result\r\n+            else:\r\n+                self.log(f\"画像未検出 (閾値: {threshold:.2f}): {template_path}\", device_id)\r\n+        \r\n+        return None\r\n+\r\n def main():\r\n     root = tk.Tk()\r\n     app = PuniPuniAutoPlayer(root)\r\n     \r\n"
                },
                {
                    "date": 1750490229667,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -413,9 +413,10 @@\n                     max_attempts = 10  # 最大試行回数\r\n                     \r\n                     for attempt in range(max_attempts):\r\n                         time.sleep(0.5)  # 画面遷移を待つ\r\n-                        play_pos = self.find_image_on_screen_optimized(self.image_paths['play'], device_id)\r\n+                        # 段階的閾値検索を使用\r\n+                        play_pos = self.find_image_with_multiple_thresholds(self.image_paths['play'], device_id)\r\n                         \r\n                         if play_pos:\r\n                             self.log(f\"playボタン検出成功 (試行{attempt + 1}回目): {play_pos}\", device_id)\r\n                             play_found = True\r\n@@ -942,8 +943,46 @@\n                 self.log(f\"画像未検出 (閾値: {threshold:.2f}): {template_path}\", device_id)\r\n         \r\n         return None\r\n \r\n+    def test_image_detection(self):\r\n+        \"\"\"画像検出のテスト機能\"\"\"\r\n+        selected_devices = self.get_selected_devices()\r\n+        if not selected_devices:\r\n+            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n+            return\r\n+        \r\n+        device_id = selected_devices[0]\r\n+        \r\n+        self.log(\"=== 画像検出テスト ===\", device_id)\r\n+        \r\n+        # すべての画像ファイルをテスト\r\n+        for name, path in self.image_paths.items():\r\n+            self.log(f\"テスト対象: {name} ({path})\", device_id)\r\n+            \r\n+            # 画像ファイルの存在確認\r\n+            if not os.path.exists(path):\r\n+                self.log(f\"❌ ファイルが存在しません: {path}\", device_id)\r\n+                continue\r\n+            \r\n+            # 画像の読み込みテスト\r\n+            template = cv2.imread(path)\r\n+            if template is None:\r\n+                self.log(f\"❌ 画像読み込み失敗: {path}\", device_id)\r\n+                continue\r\n+            \r\n+            height, width = template.shape[:2]\r\n+            self.log(f\"✅ 画像読み込み成功: {width}x{height}\", device_id)\r\n+            \r\n+            # 現在の画面で検索テスト\r\n+            result = self.find_image_with_multiple_thresholds(path, device_id)\r\n+            if result:\r\n+                self.log(f\"✅ 検出成功: {name} at {result}\", device_id)\r\n+            else:\r\n+                self.log(f\"❌ 検出失敗: {name}\", device_id)\r\n+        \r\n+        self.log(\"=== テスト終了 ===\", device_id)\r\n+\r\n def main():\r\n     root = tk.Tk()\r\n     app = PuniPuniAutoPlayer(root)\r\n     \r\n"
                },
                {
                    "date": 1750490754580,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,11 +117,13 @@\n         ttk.Button(control_frame, text=\"スクリーンショット\", command=self.take_screenshot).grid(row=1, column=0, columnspan=2, pady=(0, 5))\r\n         \r\n         ttk.Button(control_frame, text=\"メモリ診断\", command=self.run_memory_diagnostic).grid(row=2, column=0, columnspan=2, pady=(0, 5))\r\n         \r\n-        ttk.Button(control_frame, text=\"設定保存\", command=self.save_settings).grid(row=3, column=0, padx=(0, 5))\r\n-        ttk.Button(control_frame, text=\"設定読込\", command=self.load_settings).grid(row=3, column=1)\r\n+        ttk.Button(control_frame, text=\"画像検出テスト\", command=self.test_image_detection).grid(row=3, column=0, columnspan=2, pady=(0, 5))\r\n         \r\n+        ttk.Button(control_frame, text=\"設定保存\", command=self.save_settings).grid(row=4, column=0, padx=(0, 5))\r\n+        ttk.Button(control_frame, text=\"設定読込\", command=self.load_settings).grid(row=4, column=1)\r\n+        \r\n         # ログフレーム\r\n         log_frame = ttk.LabelFrame(main_frame, text=\"ログ\", padding=\"5\")\r\n         log_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(10, 0))\r\n         \r\n@@ -980,8 +982,43 @@\n             else:\r\n                 self.log(f\"❌ 検出失敗: {name}\", device_id)\r\n         \r\n         self.log(\"=== テスト終了 ===\", device_id)\r\n+    \r\n+    def find_puzzle_with_enhanced_detection(self, device_id):\r\n+        \"\"\"puzzle.png専用の強化検知機能\"\"\"\r\n+        # より低い閾値でpuzzle検索\r\n+        thresholds = [self.similarity_var.get(), 0.7, 0.6, 0.5, 0.4]\r\n+        \r\n+        for i, threshold in enumerate(thresholds):\r\n+            result = self.find_image_on_screen_optimized(self.image_paths['puzzle'], device_id, threshold)\r\n+            if result:\r\n+                self.log(f\"puzzle検出成功 (閾値: {threshold:.2f}, 試行{i+1}回目): {result}\", device_id)\r\n+                return result\r\n+            else:\r\n+                self.log(f\"puzzle未検出 (閾値: {threshold:.2f})\", device_id)\r\n+        \r\n+        # 最後の手段：画面全体を再取得して検索\r\n+        self.log(\"puzzle検出失敗 - 画面再取得で再試行\", device_id)\r\n+        screenshot = self.fast_screenshot_to_memory(device_id)\r\n+        if screenshot is not None:\r\n+            try:\r\n+                template = cv2.imread(self.image_paths['puzzle'])\r\n+                if template is not None:\r\n+                    # より緩い条件でマッチング\r\n+                    result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n+                    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+                    \r\n+                    if max_val >= 0.3:  # 非常に低い閾値\r\n+                        h, w = template.shape[:2]\r\n+                        center_x = max_loc[0] + w // 2\r\n+                        center_y = max_loc[1] + h // 2\r\n+                        self.log(f\"puzzle低閾値検出 (信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n+                        return (center_x, center_y)\r\n+            except Exception as e:\r\n+                self.log(f\"puzzle再試行エラー: {str(e)}\", device_id)\r\n+        \r\n+        return None\r\n \r\n def main():\r\n     root = tk.Tk()\r\n     app = PuniPuniAutoPlayer(root)\r\n"
                },
                {
                    "date": 1750490827574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -524,16 +524,30 @@\n             if 'next' in detected:\r\n                 pos = detected['next']['pos']\r\n                 self.smart_tap_screen(pos[0], pos[1], device_id, \"next\")\r\n                 break\r\n+              # puzzle.pngをタップ（回数制限あり・強化検知）\r\n+            if puzzle_tap_count < self.puzzle_count_var.get():\r\n+                # 通常の検知を試行\r\n+                if 'puzzle' in detected:\r\n+                    pos = detected['puzzle']['pos']\r\n+                    self.log(f\"puzzle通常検出 (回数: {puzzle_tap_count + 1}/{self.puzzle_count_var.get()})\", device_id)\r\n+                    self.smart_tap_screen(pos[0], pos[1], device_id, \"puzzle\")\r\n+                    puzzle_tap_count += 1\r\n+                    continue\r\n+                else:\r\n+                    # 強化検知を試行\r\n+                    puzzle_pos = self.find_puzzle_with_enhanced_detection(device_id)\r\n+                    if puzzle_pos:\r\n+                        self.log(f\"puzzle強化検出 (回数: {puzzle_tap_count + 1}/{self.puzzle_count_var.get()})\", device_id)\r\n+                        self.smart_tap_screen(puzzle_pos[0], puzzle_pos[1], device_id, \"puzzle\")\r\n+                        puzzle_tap_count += 1\r\n+                        continue\r\n+                    else:\r\n+                        # puzzle検出失敗時は少し待ってから次のループ\r\n+                        if puzzle_tap_count == 0:  # 初回失敗のみログ\r\n+                            self.log(\"puzzle検出失敗 - waza_okを待機中\", device_id)\r\n             \r\n-            # puzzle.pngをタップ（回数制限あり）\r\n-            if puzzle_tap_count < self.puzzle_count_var.get() and 'puzzle' in detected:\r\n-                pos = detected['puzzle']['pos']\r\n-                self.smart_tap_screen(pos[0], pos[1], device_id, \"puzzle\")\r\n-                puzzle_tap_count += 1\r\n-                continue\r\n-            \r\n             # waza_ok.pngをタップ\r\n             if 'waza_ok' in detected:\r\n                 pos = detected['waza_ok']['pos']\r\n                 self.smart_tap_screen(pos[0], pos[1], device_id, \"waza_ok\")\r\n@@ -983,8 +997,72 @@\n                 self.log(f\"❌ 検出失敗: {name}\", device_id)\r\n         \r\n         self.log(\"=== テスト終了 ===\", device_id)\r\n     \r\n+    def test_puzzle_detection_specifically(self):\r\n+        \"\"\"puzzle.png専用の詳細テスト\"\"\"\r\n+        selected_devices = self.get_selected_devices()\r\n+        if not selected_devices:\r\n+            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n+            return\r\n+        \r\n+        device_id = selected_devices[0]\r\n+        \r\n+        self.log(\"=== puzzle.png詳細検出テスト ===\", device_id)\r\n+        \r\n+        # 画像ファイルの確認\r\n+        puzzle_path = self.image_paths['puzzle']\r\n+        if not os.path.exists(puzzle_path):\r\n+            self.log(f\"❌ puzzle.pngが見つかりません: {puzzle_path}\", device_id)\r\n+            return\r\n+        \r\n+        # 画像読み込みテスト\r\n+        template = cv2.imread(puzzle_path)\r\n+        if template is None:\r\n+            self.log(f\"❌ puzzle.png読み込み失敗\", device_id)\r\n+            return\r\n+        \r\n+        height, width = template.shape[:2]\r\n+        self.log(f\"✅ puzzle.png読み込み成功: {width}x{height}\", device_id)\r\n+        \r\n+        # 現在の画面を取得\r\n+        screenshot = self.fast_screenshot_to_memory(device_id)\r\n+        if screenshot is None:\r\n+            self.log(\"❌ スクリーンショット取得失敗\", device_id)\r\n+            return\r\n+        \r\n+        screen_h, screen_w = screenshot.shape[:2]\r\n+        self.log(f\"画面サイズ: {screen_w}x{screen_h}\", device_id)\r\n+        \r\n+        # 様々な閾値でテスト\r\n+        test_thresholds = [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3]\r\n+        \r\n+        for threshold in test_thresholds:\r\n+            try:\r\n+                result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n+                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+                \r\n+                if max_val >= threshold:\r\n+                    h, w = template.shape[:2]\r\n+                    center_x = max_loc[0] + w // 2\r\n+                    center_y = max_loc[1] + h // 2\r\n+                    self.log(f\"✅ 閾値{threshold:.1f}: 検出成功 信頼度{max_val:.3f} 位置({center_x}, {center_y})\", device_id)\r\n+                else:\r\n+                    self.log(f\"❌ 閾値{threshold:.1f}: 検出失敗 最大信頼度{max_val:.3f}\", device_id)\r\n+                    \r\n+            except Exception as e:\r\n+                self.log(f\"❌ 閾値{threshold:.1f}: エラー {str(e)}\", device_id)\r\n+        \r\n+        # 強化検知テスト\r\n+        self.log(\"--- 強化検知テスト ---\", device_id)\r\n+        enhanced_result = self.find_puzzle_with_enhanced_detection(device_id)\r\n+        if enhanced_result:\r\n+            self.log(f\"✅ 強化検知成功: {enhanced_result}\", device_id)\r\n+        else:\r\n+            self.log(\"❌ 強化検知失敗\", device_id)\r\n+        \r\n+        self.log(\"=== puzzle.png テスト終了 ===\", device_id)\r\n+    \r\n     def find_puzzle_with_enhanced_detection(self, device_id):\r\n         \"\"\"puzzle.png専用の強化検知機能\"\"\"\r\n         # より低い閾値でpuzzle検索\r\n         thresholds = [self.similarity_var.get(), 0.7, 0.6, 0.5, 0.4]\r\n"
                },
                {
                    "date": 1750491265223,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,16 +47,19 @@\n         }\r\n         \r\n         # スクリーンショットキャッシュ\r\n         self.screenshot_cache = {}\r\n-        self.last_screenshot_time = {}\r\n-          # メモリ直接アクセス用の設定\r\n+        self.last_screenshot_time = {}          # メモリ直接アクセス用の設定\r\n         self.use_memory_capture = True  # メモリ直接取得を有効化\r\n         self.minicap_connections = {}  # デバイスごとのminicap接続\r\n         self.raw_capture_enabled = False  # RAWキャプチャフラグ\r\n         self.device_compatibility = {}  # デバイス互換性情報\r\n         self.fallback_count = {}  # フォールバック回数の記録\r\n         \r\n+        # リアルタイム監視用\r\n+        self.realtime_monitoring = False\r\n+        self.realtime_monitor_thread = None\r\n+        \r\n         self.create_widgets()\r\n         self.refresh_devices()\r\n         \r\n     def create_widgets(self):\r\n@@ -119,11 +122,16 @@\n         ttk.Button(control_frame, text=\"メモリ診断\", command=self.run_memory_diagnostic).grid(row=2, column=0, columnspan=2, pady=(0, 5))\r\n         \r\n         ttk.Button(control_frame, text=\"画像検出テスト\", command=self.test_image_detection).grid(row=3, column=0, columnspan=2, pady=(0, 5))\r\n         \r\n-        ttk.Button(control_frame, text=\"設定保存\", command=self.save_settings).grid(row=4, column=0, padx=(0, 5))\r\n-        ttk.Button(control_frame, text=\"設定読込\", command=self.load_settings).grid(row=4, column=1)\r\n+        ttk.Button(control_frame, text=\"puzzle専用テスト\", command=self.test_puzzle_detection_specifically).grid(row=4, column=0, columnspan=2, pady=(0, 5))\r\n         \r\n+        self.realtime_monitor_button = ttk.Button(control_frame, text=\"リアルタイム監視\", command=self.toggle_realtime_monitor)\r\n+        self.realtime_monitor_button.grid(row=5, column=0, columnspan=2, pady=(0, 5))\r\n+        \r\n+        ttk.Button(control_frame, text=\"設定保存\", command=self.save_settings).grid(row=6, column=0, padx=(0, 5))\r\n+        ttk.Button(control_frame, text=\"設定読込\", command=self.load_settings).grid(row=6, column=1)\r\n+        \r\n         # ログフレーム\r\n         log_frame = ttk.LabelFrame(main_frame, text=\"ログ\", padding=\"5\")\r\n         log_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(10, 0))\r\n         \r\n@@ -468,20 +476,22 @@\n                 time.sleep(self.check_interval_var.get())\r\n                 \r\n             except Exception as e:\r\n                 self.log(f\"自動化エラー: {str(e)}\", device_id)\r\n-                time.sleep(0.5)\r\n-        \r\n+                time.sleep(0.5)        \r\n         self.device_status[device_id] = \"停止\"\r\n         self.log(\"自動化停止\", device_id)\r\n         \r\n     def battle_loop(self, device_id, initial_puzzle_count=0):\r\n-        \"\"\"バトル中のループ処理（③④の最適化）\"\"\"\r\n+        \"\"\"バトル中のループ処理（③④の最適化・puzzle検知強化）\"\"\"\r\n         puzzle_tap_count = initial_puzzle_count\r\n         battle_start_time = time.time()\r\n         max_battle_time = 60  # 最大バトル時間（秒）\r\n         stage_45_in_battle = False\r\n+        puzzle_search_attempts = 0  # puzzle検索試行回数\r\n         \r\n+        self.log(f\"バトル開始 (初期puzzle回数: {puzzle_tap_count})\", device_id)\r\n+        \r\n         while self.running and device_id in self.threads:\r\n             # 最大時間チェック\r\n             if time.time() - battle_start_time > max_battle_time:\r\n                 self.log(\"バトル時間超過 - 次のサイクルに移行\", device_id)\r\n@@ -523,38 +533,50 @@\n             # next.pngが検出されたらバトル終了\r\n             if 'next' in detected:\r\n                 pos = detected['next']['pos']\r\n                 self.smart_tap_screen(pos[0], pos[1], device_id, \"next\")\r\n-                break\r\n-              # puzzle.pngをタップ（回数制限あり・強化検知）\r\n+                break              # puzzle.pngをタップ（回数制限あり・超強化検知）\r\n             if puzzle_tap_count < self.puzzle_count_var.get():\r\n+                puzzle_detected = False\r\n+                \r\n                 # 通常の検知を試行\r\n                 if 'puzzle' in detected:\r\n                     pos = detected['puzzle']['pos']\r\n                     self.log(f\"puzzle通常検出 (回数: {puzzle_tap_count + 1}/{self.puzzle_count_var.get()})\", device_id)\r\n                     self.smart_tap_screen(pos[0], pos[1], device_id, \"puzzle\")\r\n                     puzzle_tap_count += 1\r\n-                    continue\r\n+                    puzzle_detected = True\r\n                 else:\r\n-                    # 強化検知を試行\r\n+                    # 強化検知を試行（毎回実行）\r\n                     puzzle_pos = self.find_puzzle_with_enhanced_detection(device_id)\r\n                     if puzzle_pos:\r\n                         self.log(f\"puzzle強化検出 (回数: {puzzle_tap_count + 1}/{self.puzzle_count_var.get()})\", device_id)\r\n                         self.smart_tap_screen(puzzle_pos[0], puzzle_pos[1], device_id, \"puzzle\")\r\n                         puzzle_tap_count += 1\r\n-                        continue\r\n-                    else:\r\n-                        # puzzle検出失敗時は少し待ってから次のループ\r\n-                        if puzzle_tap_count == 0:  # 初回失敗のみログ\r\n-                            self.log(\"puzzle検出失敗 - waza_okを待機中\", device_id)\r\n+                        puzzle_detected = True\r\n+                \r\n+                # puzzle検出成功時は短いスリープで次のループへ\r\n+                if puzzle_detected:\r\n+                    time.sleep(0.3)  # 短いディレイでpuzzleを連続検索\r\n+                    continue\r\n+                else:\r\n+                    # puzzle検出失敗時の処理（ログ頻度を制御）\r\n+                    puzzle_search_attempts += 1\r\n+                    if puzzle_search_attempts % 5 == 1:  # 5回に1回だけログ\r\n+                        self.log(f\"puzzle検出失敗 ({puzzle_search_attempts}回目) - waza_okを待機中\", device_id)\r\n             \r\n             # waza_ok.pngをタップ\r\n             if 'waza_ok' in detected:\r\n                 pos = detected['waza_ok']['pos']\r\n                 self.smart_tap_screen(pos[0], pos[1], device_id, \"waza_ok\")\r\n                 puzzle_tap_count = 0  # パズルカウンターリセット\r\n+                puzzle_search_attempts = 0  # 検索試行回数もリセット\r\n             \r\n-            time.sleep(self.check_interval_var.get())\r\n+            # puzzleが必要な場合は短い間隔、そうでなければ通常間隔\r\n+            if puzzle_tap_count < self.puzzle_count_var.get():\r\n+                time.sleep(max(0.2, self.check_interval_var.get() * 0.5))  # puzzle検索時は高速\r\n+            else:\r\n+                time.sleep(self.check_interval_var.get())\r\n         \r\n     def start_automation(self):\r\n         \"\"\"自動化開始\"\"\"\r\n         selected_devices = self.get_selected_devices()\r\n@@ -1051,10 +1073,9 @@\n                     \r\n             except Exception as e:\r\n                 self.log(f\"❌ 閾値{threshold:.1f}: エラー {str(e)}\", device_id)\r\n         \r\n-        # 強化検知テスト\r\n-        self.log(\"--- 強化検知テスト ---\", device_id)\r\n+        # 強化検知テスト        self.log(\"--- 強化検知テスト ---\", device_id)\r\n         enhanced_result = self.find_puzzle_with_enhanced_detection(device_id)\r\n         if enhanced_result:\r\n             self.log(f\"✅ 強化検知成功: {enhanced_result}\", device_id)\r\n         else:\r\n@@ -1062,42 +1083,366 @@\n         \r\n         self.log(\"=== puzzle.png テスト終了 ===\", device_id)\r\n     \r\n     def find_puzzle_with_enhanced_detection(self, device_id):\r\n-        \"\"\"puzzle.png専用の強化検知機能\"\"\"\r\n-        # より低い閾値でpuzzle検索\r\n-        thresholds = [self.similarity_var.get(), 0.7, 0.6, 0.5, 0.4]\r\n+        \"\"\"puzzle.png専用の超強化検知機能\"\"\"\r\n+        screenshot = self.fast_screenshot_to_memory(device_id)\r\n+        if screenshot is None:\r\n+            return None\r\n         \r\n+        template = cv2.imread(self.image_paths['puzzle'])\r\n+        if template is None:\r\n+            self.log(\"puzzle画像ファイルが読み込めません\", device_id)\r\n+            return None\r\n+        \r\n+        # 検出方法1: 段階的閾値検索\r\n+        thresholds = [self.similarity_var.get(), 0.8, 0.7, 0.6, 0.5, 0.4, 0.3]\r\n         for i, threshold in enumerate(thresholds):\r\n-            result = self.find_image_on_screen_optimized(self.image_paths['puzzle'], device_id, threshold)\r\n-            if result:\r\n-                self.log(f\"puzzle検出成功 (閾値: {threshold:.2f}, 試行{i+1}回目): {result}\", device_id)\r\n-                return result\r\n-            else:\r\n-                self.log(f\"puzzle未検出 (閾値: {threshold:.2f})\", device_id)\r\n+            result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n+            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+            \r\n+            if max_val >= threshold:\r\n+                h, w = template.shape[:2]\r\n+                center_x = max_loc[0] + w // 2\r\n+                center_y = max_loc[1] + h // 2\r\n+                self.log(f\"puzzle検出成功-方法1 (閾値: {threshold:.2f}, 信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n+                return (center_x, center_y)\r\n         \r\n-        # 最後の手段：画面全体を再取得して検索\r\n-        self.log(\"puzzle検出失敗 - 画面再取得で再試行\", device_id)\r\n-        screenshot = self.fast_screenshot_to_memory(device_id)\r\n-        if screenshot is not None:\r\n+        # 検出方法2: 複数マッチング手法\r\n+        matching_methods = [\r\n+            cv2.TM_CCOEFF_NORMED,\r\n+            cv2.TM_CCORR_NORMED,\r\n+            cv2.TM_SQDIFF_NORMED\r\n+        ]\r\n+        \r\n+        for method_idx, method in enumerate(matching_methods):\r\n             try:\r\n-                template = cv2.imread(self.image_paths['puzzle'])\r\n-                if template is not None:\r\n-                    # より緩い条件でマッチング\r\n-                    result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n-                    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-                    \r\n-                    if max_val >= 0.3:  # 非常に低い閾値\r\n+                result = cv2.matchTemplate(screenshot, template, method)\r\n+                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+                \r\n+                # TM_SQDIFF_NORMEDの場合は最小値を使用\r\n+                if method == cv2.TM_SQDIFF_NORMED:\r\n+                    if min_val <= 0.4:  # 低い値が良いマッチ\r\n                         h, w = template.shape[:2]\r\n+                        center_x = min_loc[0] + w // 2\r\n+                        center_y = min_loc[1] + h // 2\r\n+                        self.log(f\"puzzle検出成功-方法2-{method_idx+1} (信頼度: {1-min_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n+                        return (center_x, center_y)\r\n+                else:\r\n+                    if max_val >= 0.3:\r\n+                        h, w = template.shape[:2]\r\n                         center_x = max_loc[0] + w // 2\r\n                         center_y = max_loc[1] + h // 2\r\n-                        self.log(f\"puzzle低閾値検出 (信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n+                        self.log(f\"puzzle検出成功-方法2-{method_idx+1} (信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n                         return (center_x, center_y)\r\n             except Exception as e:\r\n-                self.log(f\"puzzle再試行エラー: {str(e)}\", device_id)\r\n+                continue\r\n         \r\n+        # 検出方法3: スケール変換対応\r\n+        scales = [1.0, 0.9, 1.1, 0.8, 1.2, 0.7, 1.3]\r\n+        for scale in scales:\r\n+            try:\r\n+                if scale != 1.0:\r\n+                    h, w = template.shape[:2]\r\n+                    new_h, new_w = int(h * scale), int(w * scale)\r\n+                    scaled_template = cv2.resize(template, (new_w, new_h))\r\n+                else:\r\n+                    scaled_template = template\r\n+                \r\n+                result = cv2.matchTemplate(screenshot, scaled_template, cv2.TM_CCOEFF_NORMED)\r\n+                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+                \r\n+                if max_val >= 0.3:\r\n+                    h, w = scaled_template.shape[:2]\r\n+                    center_x = max_loc[0] + w // 2\r\n+                    center_y = max_loc[1] + h // 2\r\n+                    self.log(f\"puzzle検出成功-方法3 (スケール: {scale:.1f}, 信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n+                    return (center_x, center_y)\r\n+            except Exception as e:\r\n+                continue\r\n+        \r\n+        # 検出方法4: グレースケール＋エッジ検出\r\n+        try:\r\n+            gray_screenshot = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)\r\n+            gray_template = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)\r\n+            \r\n+            # エッジ検出\r\n+            screenshot_edges = cv2.Canny(gray_screenshot, 50, 150)\r\n+            template_edges = cv2.Canny(gray_template, 50, 150)\r\n+            \r\n+            result = cv2.matchTemplate(screenshot_edges, template_edges, cv2.TM_CCOEFF_NORMED)\r\n+            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+            \r\n+            if max_val >= 0.2:  # エッジ検出は閾値を下げる\r\n+                h, w = template_edges.shape[:2]\r\n+                center_x = max_loc[0] + w // 2\r\n+                center_y = max_loc[1] + h // 2\r\n+                self.log(f\"puzzle検出成功-方法4 (エッジ検出, 信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n+                return (center_x, center_y)\r\n+        except Exception as e:\r\n+            pass\r\n+        \r\n+        # 検出方法5: HSV色空間での検索\r\n+        try:\r\n+            hsv_screenshot = cv2.cvtColor(screenshot, cv2.COLOR_BGR2HSV)\r\n+            hsv_template = cv2.cvtColor(template, cv2.COLOR_BGR2HSV)\r\n+            \r\n+            result = cv2.matchTemplate(hsv_screenshot, hsv_template, cv2.TM_CCOEFF_NORMED)\r\n+            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+            \r\n+            if max_val >= 0.25:\r\n+                h, w = hsv_template.shape[:2]\r\n+                center_x = max_loc[0] + w // 2\r\n+                center_y = max_loc[1] + h // 2\r\n+                self.log(f\"puzzle検出成功-方法5 (HSV, 信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n+                return (center_x, center_y)\r\n+        except Exception as e:\r\n+            pass\r\n+        \r\n+        # 検出方法6: 画像の明度調整\r\n+        try:\r\n+            # 明度を調整したバージョンで試行\r\n+            brightness_adjustments = [1.2, 0.8, 1.5, 0.6]\r\n+            for brightness in brightness_adjustments:\r\n+                adjusted_screenshot = cv2.convertScaleAbs(screenshot, alpha=brightness, beta=0)\r\n+                result = cv2.matchTemplate(adjusted_screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n+                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+                \r\n+                if max_val >= 0.3:\r\n+                    h, w = template.shape[:2]\r\n+                    center_x = max_loc[0] + w // 2\r\n+                    center_y = max_loc[1] + h // 2\r\n+                    self.log(f\"puzzle検出成功-方法6 (明度調整: {brightness:.1f}, 信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n+                    return (center_x, center_y)\r\n+        except Exception as e:\r\n+            pass\r\n+        \r\n+        self.log(\"❌ puzzle検出失敗 - 全ての検出方法で未検出\", device_id)\r\n         return None\r\n \r\n+    def toggle_realtime_monitor(self):\r\n+        \"\"\"リアルタイム監視の開始/停止\"\"\"\r\n+        if not self.realtime_monitoring:\r\n+            selected_devices = self.get_selected_devices()\r\n+            if not selected_devices:\r\n+                messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n+                return\r\n+            \r\n+            self.realtime_monitoring = True\r\n+            self.realtime_monitor_button.config(text=\"監視停止\")\r\n+            \r\n+            # 監視スレッドを開始\r\n+            self.realtime_monitor_thread = threading.Thread(\r\n+                target=self.realtime_monitor_loop, \r\n+                args=(selected_devices[0],)\r\n+            )\r\n+            self.realtime_monitor_thread.daemon = True\r\n+            self.realtime_monitor_thread.start()\r\n+            \r\n+            self.log(\"リアルタイム監視開始\")\r\n+        else:\r\n+            self.realtime_monitoring = False\r\n+            self.realtime_monitor_button.config(text=\"リアルタイム監視\")\r\n+            self.log(\"リアルタイム監視停止\")\r\n+    \r\n+    def realtime_monitor_loop(self, device_id):\r\n+        \"\"\"リアルタイム監視のメインループ\"\"\"\r\n+        last_detection_status = {}\r\n+        \r\n+        while self.realtime_monitoring:\r\n+            try:\r\n+                # 全画像を同時検索\r\n+                all_images = self.image_paths.copy()\r\n+                detected = self.find_multiple_images_on_screen_optimized(all_images, device_id)\r\n+                \r\n+                # 検出状況の変化をログ\r\n+                current_status = {}\r\n+                for name in all_images.keys():\r\n+                    current_status[name] = name in detected\r\n+                    \r\n+                    # 状態が変化した場合のみログ\r\n+                    if name not in last_detection_status or last_detection_status[name] != current_status[name]:\r\n+                        if current_status[name]:\r\n+                            confidence = detected[name]['confidence']\r\n+                            pos = detected[name]['pos']\r\n+                            self.log(f\"🔍 検出: {name} (信頼度: {confidence:.3f}, 位置: {pos})\", device_id)\r\n+                        else:\r\n+                            self.log(f\"❌ 消失: {name}\", device_id)\r\n+                \r\n+                # puzzle.pngが検出されていない場合は強化検知を試行\r\n+                if not current_status.get('puzzle', False):\r\n+                    puzzle_pos = self.find_puzzle_with_enhanced_detection(device_id)\r\n+                    if puzzle_pos:\r\n+                        self.log(f\"🔍 強化検出: puzzle (位置: {puzzle_pos})\", device_id)\r\n+                        current_status['puzzle'] = True\r\n+                \r\n+                last_detection_status = current_status.copy()\r\n+                \r\n+                # 1秒間隔で監視\r\n+                time.sleep(1.0)\r\n+                \r\n+            except Exception as e:\r\n+                self.log(f\"監視エラー: {str(e)}\", device_id)\r\n+                time.sleep(1.0)\r\n+    \r\n+    def enhanced_puzzle_detection_test(self, device_id):\r\n+        \"\"\"puzzle.png検出テストの全バリエーション\"\"\"\r\n+        self.log(\"=== puzzle.png 超詳細テスト ===\", device_id)\r\n+        \r\n+        # 画像ファイルの確認\r\n+        if not os.path.exists(self.image_paths['puzzle']):\r\n+            self.log(\"❌ puzzle.pngファイルが存在しません\", device_id)\r\n+            return\r\n+        \r\n+        template = cv2.imread(self.image_paths['puzzle'])\r\n+        if template is None:\r\n+            self.log(\"❌ puzzle.png読み込み失敗\", device_id)\r\n+            return\r\n+        \r\n+        template_h, template_w = template.shape[:2]\r\n+        self.log(f\"✅ puzzle.pngサイズ: {template_w}x{template_h}\", device_id)\r\n+        \r\n+        # スクリーンショット取得\r\n+        screenshot = self.fast_screenshot_to_memory(device_id)\r\n+        if screenshot is None:\r\n+            self.log(\"❌ スクリーンショット取得失敗\", device_id)\r\n+            return\r\n+        \r\n+        screenshot_h, screenshot_w = screenshot.shape[:2]\r\n+        self.log(f\"✅ スクリーンショットサイズ: {screenshot_w}x{screenshot_h}\", device_id)\r\n+        \r\n+        # 各検出方法をテスト\r\n+        methods = [\r\n+            (\"方法1: 通常マッチング\", self.test_normal_matching),\r\n+            (\"方法2: 複数アルゴリズム\", self.test_multiple_algorithms),\r\n+            (\"方法3: スケール変換\", self.test_scale_matching),\r\n+            (\"方法4: エッジ検出\", self.test_edge_matching),\r\n+            (\"方法5: HSV色空間\", self.test_hsv_matching),\r\n+            (\"方法6: 明度調整\", self.test_brightness_matching)\r\n+        ]\r\n+        \r\n+        for method_name, test_func in methods:\r\n+            self.log(f\"--- {method_name} ---\", device_id)\r\n+            result = test_func(screenshot, template, device_id)\r\n+            if result:\r\n+                self.log(f\"✅ {method_name}: 成功 {result}\", device_id)\r\n+            else:\r\n+                self.log(f\"❌ {method_name}: 失敗\", device_id)\r\n+        \r\n+        self.log(\"=== puzzle.png 超詳細テスト 終了 ===\", device_id)\r\n+    \r\n+    def test_normal_matching(self, screenshot, template, device_id):\r\n+        \"\"\"通常マッチングテスト\"\"\"\r\n+        thresholds = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2]\r\n+        for threshold in thresholds:\r\n+            result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n+            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+            if max_val >= threshold:\r\n+                h, w = template.shape[:2]\r\n+                center_x, center_y = max_loc[0] + w // 2, max_loc[1] + h // 2\r\n+                return f\"(閾値: {threshold:.1f}, 信頼度: {max_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n+        return None\r\n+    \r\n+    def test_multiple_algorithms(self, screenshot, template, device_id):\r\n+        \"\"\"複数アルゴリズムテスト\"\"\"\r\n+        algorithms = [\r\n+            (cv2.TM_CCOEFF_NORMED, \"CCOEFF_NORMED\"),\r\n+            (cv2.TM_CCORR_NORMED, \"CCORR_NORMED\"),\r\n+            (cv2.TM_SQDIFF_NORMED, \"SQDIFF_NORMED\")\r\n+        ]\r\n+        \r\n+        for method, name in algorithms:\r\n+            try:\r\n+                result = cv2.matchTemplate(screenshot, template, method)\r\n+                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+                \r\n+                if method == cv2.TM_SQDIFF_NORMED:\r\n+                    if min_val <= 0.4:\r\n+                        h, w = template.shape[:2]\r\n+                        center_x, center_y = min_loc[0] + w // 2, min_loc[1] + h // 2\r\n+                        return f\"({name}, 信頼度: {1-min_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n+                else:\r\n+                    if max_val >= 0.3:\r\n+                        h, w = template.shape[:2]\r\n+                        center_x, center_y = max_loc[0] + w // 2, max_loc[1] + h // 2\r\n+                        return f\"({name}, 信頼度: {max_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n+            except:\r\n+                continue\r\n+        return None\r\n+    \r\n+    def test_scale_matching(self, screenshot, template, device_id):\r\n+        \"\"\"スケールマッチングテスト\"\"\"\r\n+        scales = [1.0, 0.9, 1.1, 0.8, 1.2, 0.7, 1.3]\r\n+        for scale in scales:\r\n+            try:\r\n+                h, w = template.shape[:2]\r\n+                new_h, new_w = int(h * scale), int(w * scale)\r\n+                if new_w > 0 and new_h > 0:\r\n+                    scaled_template = cv2.resize(template, (new_w, new_h))\r\n+                    result = cv2.matchTemplate(screenshot, scaled_template, cv2.TM_CCOEFF_NORMED)\r\n+                    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+                    if max_val >= 0.3:\r\n+                        sh, sw = scaled_template.shape[:2]\r\n+                        center_x, center_y = max_loc[0] + sw // 2, max_loc[1] + sh // 2\r\n+                        return f\"(スケール: {scale:.1f}, 信頼度: {max_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n+            except:\r\n+                continue\r\n+        return None\r\n+    \r\n+    def test_edge_matching(self, screenshot, template, device_id):\r\n+        \"\"\"エッジマッチングテスト\"\"\"\r\n+        try:\r\n+            gray_screenshot = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)\r\n+            gray_template = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)\r\n+            \r\n+            screenshot_edges = cv2.Canny(gray_screenshot, 50, 150)\r\n+            template_edges = cv2.Canny(gray_template, 50, 150)\r\n+            \r\n+            result = cv2.matchTemplate(screenshot_edges, template_edges, cv2.TM_CCOEFF_NORMED)\r\n+            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+            \r\n+            if max_val >= 0.2:\r\n+                h, w = template_edges.shape[:2]\r\n+                center_x, center_y = max_loc[0] + w // 2, max_loc[1] + h // 2\r\n+                return f\"(エッジ検出, 信頼度: {max_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n+        except:\r\n+            pass\r\n+        return None\r\n+    \r\n+    def test_hsv_matching(self, screenshot, template, device_id):\r\n+        \"\"\"HSVマッチングテスト\"\"\"\r\n+        try:\r\n+            hsv_screenshot = cv2.cvtColor(screenshot, cv2.COLOR_BGR2HSV)\r\n+            hsv_template = cv2.cvtColor(template, cv2.COLOR_BGR2HSV)\r\n+            \r\n+            result = cv2.matchTemplate(hsv_screenshot, hsv_template, cv2.TM_CCOEFF_NORMED)\r\n+            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+            \r\n+            if max_val >= 0.25:\r\n+                h, w = hsv_template.shape[:2]\r\n+                center_x, center_y = max_loc[0] + w // 2, max_loc[1] + h // 2\r\n+                return f\"(HSV色空間, 信頼度: {max_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n+        except:\r\n+            pass\r\n+        return None\r\n+    \r\n+    def test_brightness_matching(self, screenshot, template, device_id):\r\n+        \"\"\"明度調整マッチングテスト\"\"\"\r\n+        brightness_values = [1.2, 0.8, 1.5, 0.6, 1.8, 0.4]\r\n+        for brightness in brightness_values:\r\n+            try:\r\n+                adjusted_screenshot = cv2.convertScaleAbs(screenshot, alpha=brightness, beta=0)\r\n+                result = cv2.matchTemplate(adjusted_screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n+                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n+                \r\n+                if max_val >= 0.3:\r\n+                    h, w = template.shape[:2]\r\n+                    center_x, center_y = max_loc[0] + w // 2, max_loc[1] + h // 2\r\n+                    return f\"(明度: {brightness:.1f}, 信頼度: {max_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n+            except:\r\n+                continue\r\n+        return None\r\n+\r\n def main():\r\n     root = tk.Tk()\r\n     app = PuniPuniAutoPlayer(root)\r\n     \r\n"
                },
                {
                    "date": 1750491686053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -502,13 +502,12 @@\n                 stage_45_pos = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n                 if stage_45_pos:\r\n                     stage_45_in_battle = True\r\n                     self.log(\"バトル中ステージ45検出 - close系監視停止\", device_id)\r\n-            \r\n-            # バトル関連の画像を同時検索\r\n+              # バトル関連の画像を同時検索（puzzle優先順序）\r\n             battle_images = {\r\n+                'puzzle': self.image_paths['puzzle'],  # puzzleを最初に配置\r\n                 'next': self.image_paths['next'],\r\n-                'puzzle': self.image_paths['puzzle'],\r\n                 'waza_ok': self.image_paths['waza_ok']\r\n             }\r\n             \r\n             # stage_45が検出されていない場合のみclose系を追加\r\n@@ -517,66 +516,86 @@\n                 battle_images['close_mini'] = self.image_paths['close_mini']\r\n             \r\n             detected = self.find_multiple_images_on_screen_optimized(battle_images, device_id)\r\n             \r\n-            # close系の処理（stage_45が検出されていない場合のみ）\r\n-            if not stage_45_in_battle:\r\n-                if 'close' in detected:\r\n-                    pos = detected['close']['pos']\r\n-                    self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n-                    continue\r\n-                    \r\n-                if 'close_mini' in detected:\r\n-                    pos = detected['close_mini']['pos']\r\n-                    self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n-                    continue\r\n-            \r\n-            # next.pngが検出されたらバトル終了\r\n-            if 'next' in detected:\r\n-                pos = detected['next']['pos']\r\n-                self.smart_tap_screen(pos[0], pos[1], device_id, \"next\")\r\n-                break              # puzzle.pngをタップ（回数制限あり・超強化検知）\r\n+            # 最優先: puzzle.pngをタップ（回数制限あり・超積極的検知）# puzzle.pngをタップ（回数制限あり・超積極的検知）\r\n             if puzzle_tap_count < self.puzzle_count_var.get():\r\n                 puzzle_detected = False\r\n                 \r\n-                # 通常の検知を試行\r\n+                # 方法1: 通常の検知を試行\r\n                 if 'puzzle' in detected:\r\n                     pos = detected['puzzle']['pos']\r\n-                    self.log(f\"puzzle通常検出 (回数: {puzzle_tap_count + 1}/{self.puzzle_count_var.get()})\", device_id)\r\n+                    confidence = detected['puzzle']['confidence']\r\n+                    self.log(f\"puzzle通常検出 (回数: {puzzle_tap_count + 1}/{self.puzzle_count_var.get()}, 信頼度: {confidence:.3f})\", device_id)\r\n                     self.smart_tap_screen(pos[0], pos[1], device_id, \"puzzle\")\r\n                     puzzle_tap_count += 1\r\n                     puzzle_detected = True\r\n-                else:\r\n-                    # 強化検知を試行（毎回実行）\r\n+                \r\n+                # 方法2: 通常検知で失敗した場合、すぐに強化検知を試行\r\n+                if not puzzle_detected:\r\n                     puzzle_pos = self.find_puzzle_with_enhanced_detection(device_id)\r\n                     if puzzle_pos:\r\n                         self.log(f\"puzzle強化検出 (回数: {puzzle_tap_count + 1}/{self.puzzle_count_var.get()})\", device_id)\r\n                         self.smart_tap_screen(puzzle_pos[0], puzzle_pos[1], device_id, \"puzzle\")\r\n                         puzzle_tap_count += 1\r\n                         puzzle_detected = True\r\n                 \r\n+                # 方法3: それでも失敗した場合、低閾値で最後の試行\r\n+                if not puzzle_detected and puzzle_search_attempts % 3 == 0:  # 3回に1回だけ\r\n+                    low_threshold_pos = self.find_image_on_screen_optimized(\r\n+                        self.image_paths['puzzle'], device_id, threshold=0.5\r\n+                    )\r\n+                    if low_threshold_pos:\r\n+                        self.log(f\"puzzle低閾値検出 (回数: {puzzle_tap_count + 1}/{self.puzzle_count_var.get()})\", device_id)\r\n+                        self.smart_tap_screen(low_threshold_pos[0], low_threshold_pos[1], device_id, \"puzzle\")\r\n+                        puzzle_tap_count += 1\r\n+                        puzzle_detected = True\r\n+                \r\n                 # puzzle検出成功時は短いスリープで次のループへ\r\n                 if puzzle_detected:\r\n-                    time.sleep(0.3)  # 短いディレイでpuzzleを連続検索\r\n+                    time.sleep(0.2)  # さらに短いディレイでpuzzleを連続検索\r\n                     continue\r\n                 else:\r\n                     # puzzle検出失敗時の処理（ログ頻度を制御）\r\n                     puzzle_search_attempts += 1\r\n-                    if puzzle_search_attempts % 5 == 1:  # 5回に1回だけログ\r\n-                        self.log(f\"puzzle検出失敗 ({puzzle_search_attempts}回目) - waza_okを待機中\", device_id)\r\n+                    if puzzle_search_attempts % 3 == 1:  # 3回に1回ログ（頻度を上げる）\r\n+                        self.log(f\"puzzle全検出失敗 ({puzzle_search_attempts}回目) - waza_okを待機中\", device_id)\r\n+                        # 失敗時はリアルタイム状況をログ\r\n+                        if puzzle_search_attempts % 9 == 1:  # 9回に1回は詳細ログ\r\n+                            current_images = self.find_multiple_images_on_screen_optimized(\r\n+                                {'waza_ok': self.image_paths['waza_ok'], 'next': self.image_paths['next']}, device_id\r\n+                            )\r\n+                            detected_names = list(current_images.keys())\r\n+                            self.log(f\"現在検出中の画像: {detected_names if detected_names else 'なし'}\", device_id)\r\n             \r\n             # waza_ok.pngをタップ\r\n             if 'waza_ok' in detected:\r\n                 pos = detected['waza_ok']['pos']\r\n                 self.smart_tap_screen(pos[0], pos[1], device_id, \"waza_ok\")\r\n                 puzzle_tap_count = 0  # パズルカウンターリセット\r\n                 puzzle_search_attempts = 0  # 検索試行回数もリセット\r\n+                continue\r\n             \r\n-            # puzzleが必要な場合は短い間隔、そうでなければ通常間隔\r\n-            if puzzle_tap_count < self.puzzle_count_var.get():\r\n-                time.sleep(max(0.2, self.check_interval_var.get() * 0.5))  # puzzle検索時は高速\r\n-            else:\r\n-                time.sleep(self.check_interval_var.get())\r\n+            # close系の処理（stage_45が検出されていない場合のみ）\r\n+            if not stage_45_in_battle:\r\n+                if 'close' in detected:\r\n+                    pos = detected['close']['pos']\r\n+                    self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n+                    continue\r\n+                    \r\n+                if 'close_mini' in detected:\r\n+                    pos = detected['close_mini']['pos']\r\n+                    self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n+                    continue\r\n+            \r\n+            # 最後: next.pngが検出されたらバトル終了\r\n+            if 'next' in detected:\r\n+                pos = detected['next']['pos']\r\n+                self.smart_tap_screen(pos[0], pos[1], device_id, \"next\")\r\n+                break\r\n+                \r\n+            # 短い間隔で次のチェック\r\n+            time.sleep(self.check_interval_var.get())\r\n         \r\n     def start_automation(self):\r\n         \"\"\"自動化開始\"\"\"\r\n         selected_devices = self.get_selected_devices()\r\n@@ -1015,74 +1034,20 @@\n             result = self.find_image_with_multiple_thresholds(path, device_id)\r\n             if result:\r\n                 self.log(f\"✅ 検出成功: {name} at {result}\", device_id)\r\n             else:\r\n-                self.log(f\"❌ 検出失敗: {name}\", device_id)\r\n-        \r\n+                self.log(f\"❌ 検出失敗: {name}\", device_id)        \r\n         self.log(\"=== テスト終了 ===\", device_id)\r\n     \r\n     def test_puzzle_detection_specifically(self):\r\n-        \"\"\"puzzle.png専用の詳細テスト\"\"\"\r\n+        \"\"\"puzzle.png超詳細テスト（全検出方法）\"\"\"\r\n         selected_devices = self.get_selected_devices()\r\n         if not selected_devices:\r\n             messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n             return\r\n         \r\n         device_id = selected_devices[0]\r\n-        \r\n-        self.log(\"=== puzzle.png詳細検出テスト ===\", device_id)\r\n-        \r\n-        # 画像ファイルの確認\r\n-        puzzle_path = self.image_paths['puzzle']\r\n-        if not os.path.exists(puzzle_path):\r\n-            self.log(f\"❌ puzzle.pngが見つかりません: {puzzle_path}\", device_id)\r\n-            return\r\n-        \r\n-        # 画像読み込みテスト\r\n-        template = cv2.imread(puzzle_path)\r\n-        if template is None:\r\n-            self.log(f\"❌ puzzle.png読み込み失敗\", device_id)\r\n-            return\r\n-        \r\n-        height, width = template.shape[:2]\r\n-        self.log(f\"✅ puzzle.png読み込み成功: {width}x{height}\", device_id)\r\n-        \r\n-        # 現在の画面を取得\r\n-        screenshot = self.fast_screenshot_to_memory(device_id)\r\n-        if screenshot is None:\r\n-            self.log(\"❌ スクリーンショット取得失敗\", device_id)\r\n-            return\r\n-        \r\n-        screen_h, screen_w = screenshot.shape[:2]\r\n-        self.log(f\"画面サイズ: {screen_w}x{screen_h}\", device_id)\r\n-        \r\n-        # 様々な閾値でテスト\r\n-        test_thresholds = [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3]\r\n-        \r\n-        for threshold in test_thresholds:\r\n-            try:\r\n-                result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n-                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-                \r\n-                if max_val >= threshold:\r\n-                    h, w = template.shape[:2]\r\n-                    center_x = max_loc[0] + w // 2\r\n-                    center_y = max_loc[1] + h // 2\r\n-                    self.log(f\"✅ 閾値{threshold:.1f}: 検出成功 信頼度{max_val:.3f} 位置({center_x}, {center_y})\", device_id)\r\n-                else:\r\n-                    self.log(f\"❌ 閾値{threshold:.1f}: 検出失敗 最大信頼度{max_val:.3f}\", device_id)\r\n-                    \r\n-            except Exception as e:\r\n-                self.log(f\"❌ 閾値{threshold:.1f}: エラー {str(e)}\", device_id)\r\n-        \r\n-        # 強化検知テスト        self.log(\"--- 強化検知テスト ---\", device_id)\r\n-        enhanced_result = self.find_puzzle_with_enhanced_detection(device_id)\r\n-        if enhanced_result:\r\n-            self.log(f\"✅ 強化検知成功: {enhanced_result}\", device_id)\r\n-        else:\r\n-            self.log(\"❌ 強化検知失敗\", device_id)\r\n-        \r\n-        self.log(\"=== puzzle.png テスト終了 ===\", device_id)\r\n+        self.enhanced_puzzle_detection_test(device_id)\r\n     \r\n     def find_puzzle_with_enhanced_detection(self, device_id):\r\n         \"\"\"puzzle.png専用の超強化検知機能\"\"\"\r\n         screenshot = self.fast_screenshot_to_memory(device_id)\r\n@@ -1448,8 +1413,10 @@\n     \r\n     def on_closing():\r\n         if app.running:\r\n             app.stop_automation()\r\n+        if app.realtime_monitoring:\r\n+            app.realtime_monitoring = False\r\n         root.destroy()\r\n     \r\n     root.protocol(\"WM_DELETE_WINDOW\", on_closing)\r\n     root.mainloop()\r\n"
                },
                {
                    "date": 1750493471459,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,23 +8,20 @@\n import os\r\n from datetime import datetime\r\n import json\r\n import struct\r\n-import socket\r\n \r\n+# 分割したモジュールをインポート\r\n+from image_detector import ImageDetector\r\n+from device_controller import DeviceController\r\n+from automation_engine import AutomationEngine\r\n+\r\n class PuniPuniAutoPlayer:\r\n     def __init__(self, root):\r\n         self.root = root\r\n         self.root.title(\"妖怪ウォッチぷにぷに自動周回ソフト\")\r\n         self.root.geometry(\"800x600\")\r\n         \r\n-        # 変数の初期化\r\n-        self.devices = []\r\n-        self.selected_devices = []\r\n-        self.running = False\r\n-        self.threads = {}\r\n-        self.device_status = {}\r\n-        \r\n         # 画像ファイルパス\r\n         self.image_paths = {\r\n             'boss': 'image/boss.jpg',\r\n             'play': 'image/play.png',\r\n@@ -34,31 +31,30 @@\n             'close': 'image/close.png',\r\n             'close_mini': 'image/close_mini.png',\r\n             'stage_45': 'image/stage_45.png'\r\n         }\r\n-          # 設定\r\n+        \r\n+        # 設定\r\n         self.settings = {\r\n             'similarity_threshold': 0.8,\r\n             'tap_delay': 0.3,  # 実際のタップに近い遅延\r\n             'puzzle_tap_count': 2,\r\n             'check_interval': 0.1,  # 高速チェック間隔\r\n             'screenshot_cache_time': 0.05,  # スクリーンショットキャッシュ時間\r\n             'human_like_delay_min': 0.15,  # 人間らしい遅延の最小値\r\n-            'human_like_delay_max': 0.4   # 人間らしい遅延の最大値\r\n+            'human_like_delay_max': 0.4,   # 人間らしい遅延の最大値\r\n+            'use_memory_capture': True  # メモリ直接取得を有効化\r\n         }\r\n         \r\n-        # スクリーンショットキャッシュ\r\n-        self.screenshot_cache = {}\r\n-        self.last_screenshot_time = {}          # メモリ直接アクセス用の設定\r\n-        self.use_memory_capture = True  # メモリ直接取得を有効化\r\n-        self.minicap_connections = {}  # デバイスごとのminicap接続\r\n-        self.raw_capture_enabled = False  # RAWキャプチャフラグ\r\n-        self.device_compatibility = {}  # デバイス互換性情報\r\n-        self.fallback_count = {}  # フォールバック回数の記録\r\n+        # 分割したモジュールのインスタンスを作成\r\n+        self.image_detector = ImageDetector(self.settings['similarity_threshold'])\r\n+        self.device_controller = DeviceController()\r\n+        self.automation_engine = AutomationEngine(self.image_paths, self.settings, self.log)\r\n         \r\n-        # リアルタイム監視用\r\n-        self.realtime_monitoring = False\r\n-        self.realtime_monitor_thread = None\r\n+        # 変数の初期化\r\n+        self.devices = []\r\n+        self.selected_devices = []\r\n+        self.running = False\r\n         \r\n         self.create_widgets()\r\n         self.refresh_devices()\r\n         \r\n@@ -161,28 +157,17 @@\n         print(log_message.strip())\r\n         \r\n     def refresh_devices(self):\r\n         \"\"\"ADBデバイスを更新\"\"\"\r\n-        try:\r\n-            result = subprocess.run(['adb', 'devices'], capture_output=True, text=True)\r\n-            lines = result.stdout.strip().split('\\n')[1:]  # ヘッダーを除く\r\n-            \r\n-            self.devices = []\r\n-            for line in lines:\r\n-                if line.strip() and 'device' in line:\r\n-                    device_id = line.split('\\t')[0]\r\n-                    self.devices.append(device_id)\r\n-            \r\n-            # リストボックスを更新\r\n-            self.device_listbox.delete(0, tk.END)\r\n-            for device in self.devices:\r\n-                self.device_listbox.insert(tk.END, device)\r\n-            \r\n-            self.log(f\"デバイス検出: {len(self.devices)}台\")\r\n-            \r\n-        except Exception as e:\r\n-            self.log(f\"デバイス検出エラー: {str(e)}\")\r\n-            \r\n+        self.devices = self.device_controller.refresh_devices()\r\n+        \r\n+        # リストボックスを更新\r\n+        self.device_listbox.delete(0, tk.END)\r\n+        for device in self.devices:\r\n+            self.device_listbox.insert(tk.END, device)\r\n+        \r\n+        self.log(f\"デバイス検出: {len(self.devices)}台\")\r\n+        \r\n     def get_selected_devices(self):\r\n         \"\"\"選択されたデバイスを取得\"\"\"\r\n         selected_indices = self.device_listbox.curselection()\r\n         return [self.devices[i] for i in selected_indices]\r\n@@ -195,116 +180,44 @@\n                 messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n                 return\r\n             device_id = devices[0]\r\n         \r\n-        current_time = time.time()\r\n+        # device_controllerのtake_screenshotメソッドを使用\r\n+        use_memory = self.memory_capture_var.get() if hasattr(self, 'memory_capture_var') else self.settings.get('use_memory_capture', True)\r\n+        screenshot = self.device_controller.take_screenshot(device_id, force_new, use_memory)\r\n         \r\n-        # キャッシュチェック（強制更新でない場合）\r\n-        if not force_new and device_id in self.last_screenshot_time:\r\n-            if current_time - self.last_screenshot_time[device_id] < self.settings['screenshot_cache_time']:\r\n-                if device_id in self.screenshot_cache:\r\n-                    return self.screenshot_cache[device_id]\r\n+        if screenshot is not None:\r\n+            self.log(f\"スクリーンショット取得成功\", device_id)\r\n+            return screenshot\r\n+        else:\r\n+            self.log(f\"スクリーンショット取得失敗\", device_id)\r\n+            return None\r\n         \r\n-        try:\r\n-            # スクリーンショットを取得\r\n-            screenshot_path = f'screenshot_{device_id}.png'\r\n-            subprocess.run(['adb', '-s', device_id, 'shell', 'screencap', '/sdcard/screenshot.png'], \r\n-                         check=True, capture_output=True)\r\n-            subprocess.run(['adb', '-s', device_id, 'pull', '/sdcard/screenshot.png', screenshot_path], \r\n-                         check=True, capture_output=True)\r\n-            \r\n-            # キャッシュに保存\r\n-            self.screenshot_cache[device_id] = screenshot_path\r\n-            self.last_screenshot_time[device_id] = current_time\r\n-            \r\n-            return screenshot_path\r\n-        except Exception as e:\r\n-            self.log(f\"スクリーンショットエラー: {str(e)}\", device_id)\r\n-            return None\r\n-            \r\n     def find_image_on_screen_optimized(self, template_path, device_id, threshold=None):\r\n         \"\"\"最適化された画像検索（メモリ直接対応）\"\"\"\r\n         if threshold is None:\r\n             threshold = self.similarity_var.get()\r\n             \r\n-        # メモリから直接スクリーンショットを取得\r\n-        screenshot = self.fast_screenshot_to_memory(device_id)\r\n+        # スクリーンショットを取得\r\n+        screenshot = self.take_screenshot(device_id)\r\n         if screenshot is None:\r\n             return None\r\n+        \r\n+        # image_detectorを使用して画像検索\r\n+        return self.image_detector.find_image_on_screen_optimized(template_path, screenshot, threshold)\r\n             \r\n-        try:\r\n-            template = cv2.imread(template_path)\r\n-            if template is None:\r\n-                self.log(f\"テンプレート読み込みエラー: {template_path}\", device_id)\r\n-                return None\r\n-            \r\n-            # テンプレートマッチング（高速化）\r\n-            result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n-            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-            \r\n-            if max_val >= threshold:\r\n-                h, w = template.shape[:2]\r\n-                center_x = max_loc[0] + w // 2\r\n-                center_y = max_loc[1] + h // 2\r\n-                \r\n-                return (center_x, center_y)\r\n-            else:\r\n-                return None\r\n-                \r\n-        except Exception as e:\r\n-            self.log(f\"最適化画像検索エラー: {str(e)}\", device_id)\r\n-            return None\r\n-            \r\n     def find_multiple_images_on_screen_optimized(self, template_paths, device_id, threshold=None):\r\n         \"\"\"最適化された複数画像同時検索（メモリ直接対応）\"\"\"\r\n         if threshold is None:\r\n             threshold = self.similarity_var.get()\r\n             \r\n-        # メモリから直接スクリーンショットを取得\r\n-        screenshot = self.fast_screenshot_to_memory(device_id)\r\n+        # スクリーンショットを取得\r\n+        screenshot = self.take_screenshot(device_id)\r\n         if screenshot is None:\r\n             return {}\r\n-            \r\n-        try:\r\n-            results = {}\r\n-            for name, template_path in template_paths.items():\r\n-                template = cv2.imread(template_path)\r\n-                if template is None:\r\n-                    continue\r\n-                \r\n-                # テンプレートマッチング（高速化）\r\n-                result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n-                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-                \r\n-                if max_val >= threshold:\r\n-                    h, w = template.shape[:2]\r\n-                    center_x = max_loc[0] + w // 2\r\n-                    center_y = max_loc[1] + h // 2\r\n-                    \r\n-                    results[name] = {\r\n-                        'pos': (center_x, center_y),\r\n-                        'confidence': max_val\r\n-                    }\r\n-                    \r\n-                    # ログは最高精度のもののみ表示（ログ量削減）\r\n-                    if max_val > 0.9:\r\n-                        self.log(f\"高精度検出: {name} ({max_val:.3f})\", device_id)\r\n-            \r\n-            return results\r\n-                \r\n-        except Exception as e:\r\n-            self.log(f\"最適化複数画像検索エラー: {str(e)}\", device_id)\r\n-            return {}\r\n-        \"\"\"画面にタップ\"\"\"\r\n-        try:\r\n-            subprocess.run(['adb', '-s', device_id, 'shell', 'input', 'tap', str(x), str(y)], check=True)\r\n-            self.log(f\"タップ: ({x}, {y})\", device_id)\r\n-            time.sleep(self.delay_var.get())\r\n-            return True\r\n-        except Exception as e:\r\n-            self.log(f\"タップエラー: {str(e)}\", device_id)\r\n-            return False\r\n-            \r\n+          # image_detectorを使用して複数画像検索\r\n+        return self.image_detector.find_multiple_images_on_screen_optimized(template_paths, screenshot, threshold)\r\n+        \r\n     def human_like_delay(self):\r\n         \"\"\"人間らしいランダムな遅延\"\"\"\r\n         import random\r\n         delay = random.uniform(\r\n@@ -314,289 +227,18 @@\n         time.sleep(delay)\r\n         \r\n     def smart_tap_screen(self, x, y, device_id, tap_type=\"normal\"):\r\n         \"\"\"スマートタップ機能（タップ種類に応じて遅延を調整）\"\"\"\r\n-        try:\r\n-            subprocess.run(['adb', '-s', device_id, 'shell', 'input', 'tap', str(x), str(y)], \r\n-                         check=True, capture_output=True)\r\n+        # device_controllerのsmart_tap_screenメソッドを使用\r\n+        delay_multiplier = self.delay_var.get() if hasattr(self, 'delay_var') else self.settings['tap_delay']\r\n+        success = self.device_controller.smart_tap_screen(x, y, device_id, tap_type, delay_multiplier)\r\n+        \r\n+        if success:\r\n             self.log(f\"タップ: ({x}, {y}) [{tap_type}]\", device_id)\r\n-            \r\n-            # タップ種類に応じた遅延\r\n-            if tap_type == \"boss\":\r\n-                time.sleep(self.delay_var.get() * 1.5)  # ボス選択は少し長め\r\n-            elif tap_type == \"play\":\r\n-                time.sleep(self.delay_var.get() * 2.0)  # プレイボタンは読み込み時間考慮\r\n-            elif tap_type == \"puzzle\":\r\n-                time.sleep(self.delay_var.get() * 0.8)  # パズルは短め\r\n-            elif tap_type == \"close\":\r\n-                time.sleep(self.delay_var.get() * 0.5)  # 閉じるボタンは最短\r\n-            else:\r\n-                time.sleep(self.delay_var.get())\r\n-            \r\n-            # 人間らしい微小な遅延を追加\r\n-            self.human_like_delay()\r\n-            return True\r\n-        except Exception as e:\r\n-            self.log(f\"タップエラー: {str(e)}\", device_id)\r\n-            return False\r\n-            \r\n-    def automation_loop(self, device_id):\r\n-        \"\"\"最適化されたメインの自動化ループ\"\"\"\r\n-        self.device_status[device_id] = \"実行中\"\r\n-        puzzle_tap_count = 0\r\n-        stage_45_detected = False\r\n+        else:\r\n+            self.log(f\"タップ失敗: ({x}, {y}) [{tap_type}]\", device_id)\r\n+        return success\r\n         \r\n-        while self.running and device_id in self.threads:\r\n-            try:                # 優先度の高い画像を同時検索\r\n-                priority_images = {}\r\n-                \r\n-                # stage_45.pngを最初にチェック\r\n-                stage_45_pos = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n-                if stage_45_pos and not stage_45_detected:\r\n-                    stage_45_detected = True\r\n-                    self.log(\"ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n-                elif not stage_45_pos and stage_45_detected:\r\n-                    stage_45_detected = False\r\n-                    self.log(\"ステージ45終了 - close系ボタンの監視を再開\", device_id)\r\n-                \r\n-                # close系の監視（stage_45検出時は除く）\r\n-                if not stage_45_detected:\r\n-                    priority_images['close'] = self.image_paths['close']\r\n-                    priority_images['close_mini'] = self.image_paths['close_mini']\r\n-                \r\n-                # 現在の状態に応じた画像を追加\r\n-                priority_images['boss'] = self.image_paths['boss']\r\n-                priority_images['play'] = self.image_paths['play']\r\n-                priority_images['next'] = self.image_paths['next']                # 複数画像を同時検索（最適化版）\r\n-                detected_images = self.find_multiple_images_on_screen_optimized(priority_images, device_id)\r\n-                \r\n-                # playボタンを直接検出した場合の処理を追加\r\n-                if 'play' in detected_images:\r\n-                    self.log(\"playボタンを直接検出しました\", device_id)\r\n-                    pos = detected_images['play']['pos']\r\n-                    \r\n-                    # play.pngをタップ前に再度stage_45.pngをチェック\r\n-                    stage_45_pos = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n-                    if stage_45_pos:\r\n-                        stage_45_detected = True\r\n-                        self.log(\"プレイ前ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n-                    \r\n-                    self.smart_tap_screen(pos[0], pos[1], device_id, \"play\")\r\n-                    \r\n-                    # プレイ後も再度チェック\r\n-                    time.sleep(self.delay_var.get() * 0.5)\r\n-                    stage_45_pos_after = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n-                    if stage_45_pos_after and not stage_45_detected:\r\n-                        stage_45_detected = True\r\n-                        self.log(\"プレイ後ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n-                    \r\n-                    # バトルループ（③④の処理）\r\n-                    self.battle_loop(device_id, puzzle_tap_count)\r\n-                    puzzle_tap_count = 0\r\n-                    continue\r\n-                \r\n-                # 優先順位に従って処理\r\n-                if 'close' in detected_images and not stage_45_detected:\r\n-                    pos = detected_images['close']['pos']\r\n-                    self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n-                    continue\r\n-                    \r\n-                if 'close_mini' in detected_images and not stage_45_detected:\r\n-                    pos = detected_images['close_mini']['pos']\r\n-                    self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n-                    continue\r\n-                \r\n-                # next.pngが検出された場合（最優先）\r\n-                if 'next' in detected_images:\r\n-                    pos = detected_images['next']['pos']\r\n-                    self.smart_tap_screen(pos[0], pos[1], device_id, \"next\")\r\n-                    stage_45_detected = False  # リセット\r\n-                    puzzle_tap_count = 0\r\n-                    continue\r\n-                  # boss.pngが検出された場合\r\n-                if 'boss' in detected_images:\r\n-                    pos = detected_images['boss']['pos']\r\n-                    self.smart_tap_screen(pos[0], pos[1], device_id, \"boss\")\r\n-                    \r\n-                    # play.pngを待機して検索（最適化版・強化）\r\n-                    self.log(\"boss検出後、playボタンを検索中...\", device_id)\r\n-                    play_found = False\r\n-                    max_attempts = 10  # 最大試行回数\r\n-                    \r\n-                    for attempt in range(max_attempts):\r\n-                        time.sleep(0.5)  # 画面遷移を待つ\r\n-                        # 段階的閾値検索を使用\r\n-                        play_pos = self.find_image_with_multiple_thresholds(self.image_paths['play'], device_id)\r\n-                        \r\n-                        if play_pos:\r\n-                            self.log(f\"playボタン検出成功 (試行{attempt + 1}回目): {play_pos}\", device_id)\r\n-                            play_found = True\r\n-                            \r\n-                            # play.pngをタップ前に再度stage_45.pngをチェック\r\n-                            stage_45_pos = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n-                            if stage_45_pos:\r\n-                                stage_45_detected = True\r\n-                                self.log(\"プレイ前ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n-                            \r\n-                            self.smart_tap_screen(play_pos[0], play_pos[1], device_id, \"play\")\r\n-                            \r\n-                            # プレイ後も再度チェック\r\n-                            time.sleep(self.delay_var.get() * 0.5)\r\n-                            stage_45_pos_after = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n-                            if stage_45_pos_after and not stage_45_detected:\r\n-                                stage_45_detected = True\r\n-                                self.log(\"プレイ後ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n-                            \r\n-                            # バトルループ（③④の処理）\r\n-                            self.battle_loop(device_id, puzzle_tap_count)\r\n-                            puzzle_tap_count = 0\r\n-                            break\r\n-                        else:\r\n-                            self.log(f\"playボタン未検出 (試行{attempt + 1}回目)\", device_id)\r\n-                            \r\n-                            # close系ボタンがあればタップして再試行\r\n-                            close_images = {\r\n-                                'close': self.image_paths['close'],\r\n-                                'close_mini': self.image_paths['close_mini']\r\n-                            }\r\n-                            close_detected = self.find_multiple_images_on_screen_optimized(close_images, device_id)\r\n-                            \r\n-                            if 'close' in close_detected:\r\n-                                self.log(\"playボタン待機中にcloseボタンを検出、タップします\", device_id)\r\n-                                close_pos = close_detected['close']['pos']\r\n-                                self.smart_tap_screen(close_pos[0], close_pos[1], device_id, \"close\")\r\n-                            elif 'close_mini' in close_detected:\r\n-                                self.log(\"playボタン待機中にclose_miniボタンを検出、タップします\", device_id)\r\n-                                close_pos = close_detected['close_mini']['pos']\r\n-                                self.smart_tap_screen(close_pos[0], close_pos[1], device_id, \"close\")\r\n-                    \r\n-                    if not play_found:\r\n-                        self.log(f\"playボタンが見つかりませんでした（{max_attempts}回試行）\", device_id)\r\n-                \r\n-                # 短い間隔で次のチェック\r\n-                time.sleep(self.check_interval_var.get())\r\n-                \r\n-            except Exception as e:\r\n-                self.log(f\"自動化エラー: {str(e)}\", device_id)\r\n-                time.sleep(0.5)        \r\n-        self.device_status[device_id] = \"停止\"\r\n-        self.log(\"自動化停止\", device_id)\r\n-        \r\n-    def battle_loop(self, device_id, initial_puzzle_count=0):\r\n-        \"\"\"バトル中のループ処理（③④の最適化・puzzle検知強化）\"\"\"\r\n-        puzzle_tap_count = initial_puzzle_count\r\n-        battle_start_time = time.time()\r\n-        max_battle_time = 60  # 最大バトル時間（秒）\r\n-        stage_45_in_battle = False\r\n-        puzzle_search_attempts = 0  # puzzle検索試行回数\r\n-        \r\n-        self.log(f\"バトル開始 (初期puzzle回数: {puzzle_tap_count})\", device_id)\r\n-        \r\n-        while self.running and device_id in self.threads:\r\n-            # 最大時間チェック\r\n-            if time.time() - battle_start_time > max_battle_time:\r\n-                self.log(\"バトル時間超過 - 次のサイクルに移行\", device_id)\r\n-                break\r\n-            \r\n-            # バトル開始時にstage_45をチェック\r\n-            if not stage_45_in_battle:\r\n-                stage_45_pos = self.find_image_on_screen_optimized(self.image_paths['stage_45'], device_id)\r\n-                if stage_45_pos:\r\n-                    stage_45_in_battle = True\r\n-                    self.log(\"バトル中ステージ45検出 - close系監視停止\", device_id)\r\n-              # バトル関連の画像を同時検索（puzzle優先順序）\r\n-            battle_images = {\r\n-                'puzzle': self.image_paths['puzzle'],  # puzzleを最初に配置\r\n-                'next': self.image_paths['next'],\r\n-                'waza_ok': self.image_paths['waza_ok']\r\n-            }\r\n-            \r\n-            # stage_45が検出されていない場合のみclose系を追加\r\n-            if not stage_45_in_battle:\r\n-                battle_images['close'] = self.image_paths['close']\r\n-                battle_images['close_mini'] = self.image_paths['close_mini']\r\n-            \r\n-            detected = self.find_multiple_images_on_screen_optimized(battle_images, device_id)\r\n-            \r\n-            # 最優先: puzzle.pngをタップ（回数制限あり・超積極的検知）# puzzle.pngをタップ（回数制限あり・超積極的検知）\r\n-            if puzzle_tap_count < self.puzzle_count_var.get():\r\n-                puzzle_detected = False\r\n-                \r\n-                # 方法1: 通常の検知を試行\r\n-                if 'puzzle' in detected:\r\n-                    pos = detected['puzzle']['pos']\r\n-                    confidence = detected['puzzle']['confidence']\r\n-                    self.log(f\"puzzle通常検出 (回数: {puzzle_tap_count + 1}/{self.puzzle_count_var.get()}, 信頼度: {confidence:.3f})\", device_id)\r\n-                    self.smart_tap_screen(pos[0], pos[1], device_id, \"puzzle\")\r\n-                    puzzle_tap_count += 1\r\n-                    puzzle_detected = True\r\n-                \r\n-                # 方法2: 通常検知で失敗した場合、すぐに強化検知を試行\r\n-                if not puzzle_detected:\r\n-                    puzzle_pos = self.find_puzzle_with_enhanced_detection(device_id)\r\n-                    if puzzle_pos:\r\n-                        self.log(f\"puzzle強化検出 (回数: {puzzle_tap_count + 1}/{self.puzzle_count_var.get()})\", device_id)\r\n-                        self.smart_tap_screen(puzzle_pos[0], puzzle_pos[1], device_id, \"puzzle\")\r\n-                        puzzle_tap_count += 1\r\n-                        puzzle_detected = True\r\n-                \r\n-                # 方法3: それでも失敗した場合、低閾値で最後の試行\r\n-                if not puzzle_detected and puzzle_search_attempts % 3 == 0:  # 3回に1回だけ\r\n-                    low_threshold_pos = self.find_image_on_screen_optimized(\r\n-                        self.image_paths['puzzle'], device_id, threshold=0.5\r\n-                    )\r\n-                    if low_threshold_pos:\r\n-                        self.log(f\"puzzle低閾値検出 (回数: {puzzle_tap_count + 1}/{self.puzzle_count_var.get()})\", device_id)\r\n-                        self.smart_tap_screen(low_threshold_pos[0], low_threshold_pos[1], device_id, \"puzzle\")\r\n-                        puzzle_tap_count += 1\r\n-                        puzzle_detected = True\r\n-                \r\n-                # puzzle検出成功時は短いスリープで次のループへ\r\n-                if puzzle_detected:\r\n-                    time.sleep(0.2)  # さらに短いディレイでpuzzleを連続検索\r\n-                    continue\r\n-                else:\r\n-                    # puzzle検出失敗時の処理（ログ頻度を制御）\r\n-                    puzzle_search_attempts += 1\r\n-                    if puzzle_search_attempts % 3 == 1:  # 3回に1回ログ（頻度を上げる）\r\n-                        self.log(f\"puzzle全検出失敗 ({puzzle_search_attempts}回目) - waza_okを待機中\", device_id)\r\n-                        # 失敗時はリアルタイム状況をログ\r\n-                        if puzzle_search_attempts % 9 == 1:  # 9回に1回は詳細ログ\r\n-                            current_images = self.find_multiple_images_on_screen_optimized(\r\n-                                {'waza_ok': self.image_paths['waza_ok'], 'next': self.image_paths['next']}, device_id\r\n-                            )\r\n-                            detected_names = list(current_images.keys())\r\n-                            self.log(f\"現在検出中の画像: {detected_names if detected_names else 'なし'}\", device_id)\r\n-            \r\n-            # waza_ok.pngをタップ\r\n-            if 'waza_ok' in detected:\r\n-                pos = detected['waza_ok']['pos']\r\n-                self.smart_tap_screen(pos[0], pos[1], device_id, \"waza_ok\")\r\n-                puzzle_tap_count = 0  # パズルカウンターリセット\r\n-                puzzle_search_attempts = 0  # 検索試行回数もリセット\r\n-                continue\r\n-            \r\n-            # close系の処理（stage_45が検出されていない場合のみ）\r\n-            if not stage_45_in_battle:\r\n-                if 'close' in detected:\r\n-                    pos = detected['close']['pos']\r\n-                    self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n-                    continue\r\n-                    \r\n-                if 'close_mini' in detected:\r\n-                    pos = detected['close_mini']['pos']\r\n-                    self.smart_tap_screen(pos[0], pos[1], device_id, \"close\")\r\n-                    continue\r\n-            \r\n-            # 最後: next.pngが検出されたらバトル終了\r\n-            if 'next' in detected:\r\n-                pos = detected['next']['pos']\r\n-                self.smart_tap_screen(pos[0], pos[1], device_id, \"next\")\r\n-                break\r\n-                \r\n-            # 短い間隔で次のチェック\r\n-            time.sleep(self.check_interval_var.get())\r\n-        \r\n     def start_automation(self):\r\n         \"\"\"自動化開始\"\"\"\r\n         selected_devices = self.get_selected_devices()\r\n         if not selected_devices:\r\n@@ -612,45 +254,33 @@\n         if missing_files:\r\n             messagebox.showerror(\"エラー\", f\"画像ファイルが見つかりません:\\n\" + \"\\n\".join(missing_files))\r\n             return\r\n         \r\n-        self.running = True\r\n-        self.start_button.config(state=tk.DISABLED)\r\n-        self.stop_button.config(state=tk.NORMAL)\r\n-        \r\n         # 設定を更新\r\n         self.settings['similarity_threshold'] = self.similarity_var.get()\r\n         self.settings['tap_delay'] = self.delay_var.get()\r\n         self.settings['puzzle_tap_count'] = self.puzzle_count_var.get()\r\n         self.settings['check_interval'] = self.check_interval_var.get()\r\n         self.settings['use_memory_capture'] = self.memory_capture_var.get()\r\n-          # デバイス互換性チェック\r\n-        for device_id in selected_devices:\r\n-            self.log_device_compatibility(device_id)\r\n-            \r\n-        # メモリ直接取得の警告\r\n-        if self.memory_capture_var.get():\r\n-            memory_supported_devices = [\r\n-                device_id for device_id in selected_devices \r\n-                if self.device_compatibility.get(device_id, {}).get('memory_capture_supported', False)\r\n-            ]\r\n-            if not memory_supported_devices:\r\n-                self.log(\"警告: メモリ直接取得をサポートするデバイスがありません\")\r\n-                self.log(\"すべてのデバイスでファイル方式を使用します\")\r\n         \r\n-        # 各デバイスでスレッドを開始\r\n-        for device_id in selected_devices:\r\n-            thread = threading.Thread(target=self.automation_loop, args=(device_id,))\r\n-            thread.daemon = True\r\n-            self.threads[device_id] = thread\r\n-            thread.start()\r\n-            self.log(\"自動化開始\", device_id)\r\n-            \r\n+        # automation_engineに設定を更新\r\n+        self.automation_engine.update_settings(self.settings)\r\n+        \r\n+        # automation_engineを使用して自動化開始\r\n+        self.automation_engine.start_automation(selected_devices)\r\n+        \r\n+        self.running = True\r\n+        self.start_button.config(state=tk.DISABLED)\r\n+        self.stop_button.config(state=tk.NORMAL)\r\n+        \r\n+        self.log(\"自動化開始\")\r\n     def stop_automation(self):\r\n         \"\"\"自動化停止\"\"\"\r\n         self.running = False\r\n-        self.threads.clear()\r\n         \r\n+        # automation_engineの停止\r\n+        self.automation_engine.stop_automation()\r\n+        \r\n         self.start_button.config(state=tk.NORMAL)\r\n         self.stop_button.config(state=tk.DISABLED)\r\n         \r\n         self.log(\"全デバイスの自動化を停止\")\r\n"
                },
                {
                    "date": 1750495704821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1055 +1,595 @@\n-import tkinter as tk\r\n-from tkinter import ttk, scrolledtext, messagebox\r\n-import cv2\r\n-import numpy as np\r\n-import subprocess\r\n-import threading\r\n-import time\r\n-import os\r\n-from datetime import datetime\r\n-import json\r\n-import struct\r\n+import sys\r\n+import asyncio\r\n+import logging\r\n+from typing import List, Dict\r\n+from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, \r\n+                           QHBoxLayout, QLabel, QPushButton, QTextEdit, QComboBox,\r\n+                           QSpinBox, QDoubleSpinBox, QCheckBox, QGroupBox, QTabWidget,\r\n+                           QTableWidget, QTableWidgetItem, QHeaderView, QProgressBar,\r\n+                           QSplitter, QFrame, QGridLayout, QMessageBox, QSystemTrayIcon,\r\n+                           QMenu, QAction)\r\n+from PyQt5.QtCore import QThread, pyqtSignal, QTimer, Qt, QSize\r\n+from PyQt5.QtGui import QIcon, QFont, QPalette, QColor, QPixmap\r\n \r\n-# 分割したモジュールをインポート\r\n-from image_detector import ImageDetector\r\n+from automation_engine import AutomationEngine\r\n+from config_manager import ConfigManager, setup_logging\r\n from device_controller import DeviceController\r\n-from automation_engine import AutomationEngine\r\n \r\n-class PuniPuniAutoPlayer:\r\n-    def __init__(self, root):\r\n-        self.root = root\r\n-        self.root.title(\"妖怪ウォッチぷにぷに自動周回ソフト\")\r\n-        self.root.geometry(\"800x600\")\r\n+\r\n+class AutomationWorker(QThread):\r\n+    \"\"\"自動化処理用ワーカースレッド\"\"\"\r\n+    \r\n+    log_signal = pyqtSignal(str)\r\n+    stats_signal = pyqtSignal(dict)\r\n+    error_signal = pyqtSignal(str)\r\n+    \r\n+    def __init__(self, automation_engine):\r\n+        super().__init__()\r\n+        self.automation_engine = automation_engine\r\n+        self.loop = None\r\n         \r\n-        # 画像ファイルパス\r\n-        self.image_paths = {\r\n-            'boss': 'image/boss.jpg',\r\n-            'play': 'image/play.png',\r\n-            'puzzle': 'image/puzzle.png',\r\n-            'waza_ok': 'image/waza_ok.png',\r\n-            'next': 'image/next.png',\r\n-            'close': 'image/close.png',\r\n-            'close_mini': 'image/close_mini.png',\r\n-            'stage_45': 'image/stage_45.png'\r\n-        }\r\n+    def run(self):\r\n+        \"\"\"ワーカースレッドのメインループ\"\"\"\r\n+        try:\r\n+            self.loop = asyncio.new_event_loop()\r\n+            asyncio.set_event_loop(self.loop)\r\n+            self.loop.run_until_complete(self.automation_engine.start_automation())\r\n+        except Exception as e:\r\n+            self.error_signal.emit(f\"自動化エラー: {str(e)}\")\r\n+        finally:\r\n+            if self.loop:\r\n+                self.loop.close()\r\n+    \r\n+    def stop(self):\r\n+        \"\"\"ワーカースレッドを停止\"\"\"\r\n+        if self.automation_engine.is_running:\r\n+            self.automation_engine.stop_automation()\r\n         \r\n-        # 設定\r\n-        self.settings = {\r\n-            'similarity_threshold': 0.8,\r\n-            'tap_delay': 0.3,  # 実際のタップに近い遅延\r\n-            'puzzle_tap_count': 2,\r\n-            'check_interval': 0.1,  # 高速チェック間隔\r\n-            'screenshot_cache_time': 0.05,  # スクリーンショットキャッシュ時間\r\n-            'human_like_delay_min': 0.15,  # 人間らしい遅延の最小値\r\n-            'human_like_delay_max': 0.4,   # 人間らしい遅延の最大値\r\n-            'use_memory_capture': True  # メモリ直接取得を有効化\r\n-        }\r\n-        \r\n-        # 分割したモジュールのインスタンスを作成\r\n-        self.image_detector = ImageDetector(self.settings['similarity_threshold'])\r\n-        self.device_controller = DeviceController()\r\n-        self.automation_engine = AutomationEngine(self.image_paths, self.settings, self.log)\r\n-        \r\n-        # 変数の初期化\r\n-        self.devices = []\r\n-        self.selected_devices = []\r\n-        self.running = False\r\n-        \r\n-        self.create_widgets()\r\n+        if self.loop and self.loop.is_running():\r\n+            self.loop.call_soon_threadsafe(self.loop.stop)\r\n+\r\n+\r\n+class DeviceManagementWidget(QWidget):\r\n+    \"\"\"デバイス管理ウィジェット\"\"\"\r\n+    \r\n+    def __init__(self, automation_engine):\r\n+        super().__init__()\r\n+        self.automation_engine = automation_engine\r\n+        self.init_ui()\r\n         self.refresh_devices()\r\n+    \r\n+    def init_ui(self):\r\n+        layout = QVBoxLayout()\r\n         \r\n-    def create_widgets(self):\r\n-        # メインフレーム\r\n-        main_frame = ttk.Frame(self.root, padding=\"10\")\r\n-        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n+        # デバイス検出ボタン\r\n+        self.detect_button = QPushButton(\"デバイスを検出\")\r\n+        self.detect_button.clicked.connect(self.detect_devices)\r\n+        layout.addWidget(self.detect_button)\r\n         \r\n-        # デバイス選択フレーム\r\n-        device_frame = ttk.LabelFrame(main_frame, text=\"デバイス選択\", padding=\"5\")\r\n-        device_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))\r\n+        # デバイス一覧テーブル\r\n+        self.device_table = QTableWidget()\r\n+        self.device_table.setColumnCount(4)\r\n+        self.device_table.setHorizontalHeaderLabels([\"デバイスID\", \"状態\", \"アクティブ\", \"操作\"])\r\n+        self.device_table.horizontalHeader().setStretchLastSection(True)\r\n+        layout.addWidget(self.device_table)\r\n         \r\n-        ttk.Button(device_frame, text=\"デバイス更新\", command=self.refresh_devices).grid(row=0, column=0, padx=(0, 10))\r\n+        # デバイス追加\r\n+        add_layout = QHBoxLayout()\r\n+        self.device_input = QComboBox()\r\n+        self.device_input.setEditable(True)\r\n+        self.add_button = QPushButton(\"追加\")\r\n+        self.add_button.clicked.connect(self.add_device)\r\n+        add_layout.addWidget(QLabel(\"デバイス:\"))\r\n+        add_layout.addWidget(self.device_input)\r\n+        add_layout.addWidget(self.add_button)\r\n+        layout.addLayout(add_layout)\r\n         \r\n-        self.device_listbox = tk.Listbox(device_frame, height=4, selectmode=tk.MULTIPLE)\r\n-        self.device_listbox.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(5, 0))\r\n+        self.setLayout(layout)\r\n+    \r\n+    def detect_devices(self):\r\n+        \"\"\"デバイスを検出\"\"\"\r\n+        try:\r\n+            controller = DeviceController()\r\n+            devices = controller.get_connected_devices()\r\n+            \r\n+            self.device_input.clear()\r\n+            self.device_input.addItems(devices)\r\n+            \r\n+            if devices:\r\n+                QMessageBox.information(self, \"検出完了\", f\"{len(devices)}個のデバイスが見つかりました\")\r\n+            else:\r\n+                QMessageBox.warning(self, \"検出結果\", \"デバイスが見つかりませんでした\")\r\n+                \r\n+        except Exception as e:\r\n+            QMessageBox.critical(self, \"エラー\", f\"デバイス検出エラー: {str(e)}\")\r\n+    \r\n+    def add_device(self):\r\n+        \"\"\"デバイスを追加\"\"\"\r\n+        device_id = self.device_input.currentText().strip()\r\n+        if not device_id:\r\n+            return\r\n         \r\n-        # 設定フレーム\r\n-        settings_frame = ttk.LabelFrame(main_frame, text=\"設定\", padding=\"5\")\r\n-        settings_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N), padx=(0, 10))\r\n+        if self.automation_engine.add_device(device_id):\r\n+            self.refresh_devices()\r\n+            QMessageBox.information(self, \"成功\", f\"デバイス '{device_id}' を追加しました\")\r\n+        else:\r\n+            QMessageBox.warning(self, \"失敗\", f\"デバイス '{device_id}' の追加に失敗しました\")\r\n+    \r\n+    def remove_device(self, device_id):\r\n+        \"\"\"デバイスを削除\"\"\"\r\n+        self.automation_engine.remove_device(device_id)\r\n+        self.refresh_devices()\r\n+        QMessageBox.information(self, \"削除完了\", f\"デバイス '{device_id}' を削除しました\")\r\n+    \r\n+    def toggle_device_active(self, device_id, active):\r\n+        \"\"\"デバイスのアクティブ状態を切り替え\"\"\"\r\n+        self.automation_engine.set_device_active(device_id, active)\r\n+    \r\n+    def refresh_devices(self):\r\n+        \"\"\"デバイス一覧を更新\"\"\"\r\n+        devices = self.automation_engine.get_device_list()\r\n+        self.device_table.setRowCount(len(devices))\r\n         \r\n-        ttk.Label(settings_frame, text=\"類似度閾値:\").grid(row=0, column=0, sticky=tk.W)\r\n-        self.similarity_var = tk.DoubleVar(value=self.settings['similarity_threshold'])\r\n-        ttk.Scale(settings_frame, from_=0.5, to=1.0, variable=self.similarity_var, \r\n-                 orient=tk.HORIZONTAL, length=150).grid(row=0, column=1, padx=(5, 0))\r\n-        ttk.Label(settings_frame, textvariable=self.similarity_var).grid(row=0, column=2, padx=(5, 0))\r\n-        \r\n-        ttk.Label(settings_frame, text=\"タップ間隔(秒):\").grid(row=1, column=0, sticky=tk.W)\r\n-        self.delay_var = tk.DoubleVar(value=self.settings['tap_delay'])\r\n-        ttk.Scale(settings_frame, from_=0.1, to=2.0, variable=self.delay_var, \r\n-                 orient=tk.HORIZONTAL, length=150).grid(row=1, column=1, padx=(5, 0))\r\n-        ttk.Label(settings_frame, textvariable=self.delay_var).grid(row=1, column=2, padx=(5, 0))\r\n-        \r\n-        ttk.Label(settings_frame, text=\"パズルタップ回数:\").grid(row=2, column=0, sticky=tk.W)\r\n-        self.puzzle_count_var = tk.IntVar(value=self.settings['puzzle_tap_count'])\r\n-        ttk.Spinbox(settings_frame, from_=1, to=10, textvariable=self.puzzle_count_var, \r\n-                   width=10).grid(row=2, column=1, sticky=tk.W, padx=(5, 0))\r\n-        \r\n-        ttk.Label(settings_frame, text=\"検知間隔(秒):\").grid(row=3, column=0, sticky=tk.W)\r\n-        self.check_interval_var = tk.DoubleVar(value=self.settings['check_interval'])\r\n-        ttk.Scale(settings_frame, from_=0.05, to=1.0, variable=self.check_interval_var, \r\n-                 orient=tk.HORIZONTAL, length=150).grid(row=3, column=1, padx=(5, 0))\r\n-        ttk.Label(settings_frame, textvariable=self.check_interval_var).grid(row=3, column=2, padx=(5, 0))\r\n-        \r\n-        # メモリ直接取得設定\r\n-        self.memory_capture_var = tk.BooleanVar(value=self.settings.get('use_memory_capture', True))\r\n-        ttk.Checkbutton(settings_frame, text=\"メモリ直接取得\", variable=self.memory_capture_var).grid(row=4, column=0, columnspan=2, sticky=tk.W, pady=(5, 0))\r\n+        for i, device_id in enumerate(devices):\r\n+            state = self.automation_engine.get_device_state(device_id)\r\n+            \r\n+            # デバイスID\r\n+            self.device_table.setItem(i, 0, QTableWidgetItem(device_id))\r\n+            \r\n+            # 状態\r\n+            status = state.current_state.value if state else \"不明\"\r\n+            self.device_table.setItem(i, 1, QTableWidgetItem(status))\r\n+            \r\n+            # アクティブチェックボックス\r\n+            active_checkbox = QCheckBox()\r\n+            active_checkbox.setChecked(state.is_active if state else False)\r\n+            active_checkbox.stateChanged.connect(\r\n+                lambda checked, dev_id=device_id: self.toggle_device_active(dev_id, checked == Qt.Checked)\r\n+            )\r\n+            self.device_table.setCellWidget(i, 2, active_checkbox)\r\n+            \r\n+            # 削除ボタン\r\n+            remove_button = QPushButton(\"削除\")\r\n+            remove_button.clicked.connect(lambda checked, dev_id=device_id: self.remove_device(dev_id))\r\n+            self.device_table.setCellWidget(i, 3, remove_button)\r\n \r\n-        # コントロールフレーム\r\n-        control_frame = ttk.LabelFrame(main_frame, text=\"制御\", padding=\"5\")\r\n-        control_frame.grid(row=1, column=1, sticky=(tk.W, tk.E, tk.N))\r\n+\r\n+class SettingsWidget(QWidget):\r\n+    \"\"\"設定ウィジェット\"\"\"\r\n+    \r\n+    def __init__(self, automation_engine, config_manager):\r\n+        super().__init__()\r\n+        self.automation_engine = automation_engine\r\n+        self.config_manager = config_manager\r\n+        self.init_ui()\r\n+        self.load_settings()\r\n+    \r\n+    def init_ui(self):\r\n+        layout = QVBoxLayout()\r\n         \r\n-        self.start_button = ttk.Button(control_frame, text=\"開始\", command=self.start_automation)\r\n-        self.start_button.grid(row=0, column=0, padx=(0, 5), pady=(0, 5))\r\n+        # 検出設定\r\n+        detection_group = QGroupBox(\"検出設定\")\r\n+        detection_layout = QGridLayout()\r\n         \r\n-        self.stop_button = ttk.Button(control_frame, text=\"停止\", command=self.stop_automation, state=tk.DISABLED)\r\n-        self.stop_button.grid(row=0, column=1, pady=(0, 5))\r\n+        detection_layout.addWidget(QLabel(\"検出閾値:\"), 0, 0)\r\n+        self.threshold_spin = QDoubleSpinBox()\r\n+        self.threshold_spin.setRange(0.1, 1.0)\r\n+        self.threshold_spin.setSingleStep(0.1)\r\n+        self.threshold_spin.setDecimals(1)\r\n+        detection_layout.addWidget(self.threshold_spin, 0, 1)\r\n         \r\n-        ttk.Button(control_frame, text=\"スクリーンショット\", command=self.take_screenshot).grid(row=1, column=0, columnspan=2, pady=(0, 5))\r\n+        detection_layout.addWidget(QLabel(\"タップ間隔(秒):\"), 1, 0)\r\n+        self.cooldown_spin = QDoubleSpinBox()\r\n+        self.cooldown_spin.setRange(0.1, 5.0)\r\n+        self.cooldown_spin.setSingleStep(0.1)\r\n+        self.cooldown_spin.setDecimals(1)\r\n+        detection_layout.addWidget(self.cooldown_spin, 1, 1)\r\n         \r\n-        ttk.Button(control_frame, text=\"メモリ診断\", command=self.run_memory_diagnostic).grid(row=2, column=0, columnspan=2, pady=(0, 5))\r\n+        detection_layout.addWidget(QLabel(\"キャプチャ間隔(秒):\"), 2, 0)\r\n+        self.capture_spin = QDoubleSpinBox()\r\n+        self.capture_spin.setRange(0.05, 1.0)\r\n+        self.capture_spin.setSingleStep(0.05)\r\n+        self.capture_spin.setDecimals(2)\r\n+        detection_layout.addWidget(self.capture_spin, 2, 1)\r\n         \r\n-        ttk.Button(control_frame, text=\"画像検出テスト\", command=self.test_image_detection).grid(row=3, column=0, columnspan=2, pady=(0, 5))\r\n+        detection_layout.addWidget(QLabel(\"最大エラー回数:\"), 3, 0)\r\n+        self.error_spin = QSpinBox()\r\n+        self.error_spin.setRange(1, 20)\r\n+        detection_layout.addWidget(self.error_spin, 3, 1)\r\n         \r\n-        ttk.Button(control_frame, text=\"puzzle専用テスト\", command=self.test_puzzle_detection_specifically).grid(row=4, column=0, columnspan=2, pady=(0, 5))\r\n+        detection_group.setLayout(detection_layout)\r\n+        layout.addWidget(detection_group)\r\n         \r\n-        self.realtime_monitor_button = ttk.Button(control_frame, text=\"リアルタイム監視\", command=self.toggle_realtime_monitor)\r\n-        self.realtime_monitor_button.grid(row=5, column=0, columnspan=2, pady=(0, 5))\r\n+        # 保存ボタン\r\n+        save_buttons = QHBoxLayout()\r\n+        self.save_button = QPushButton(\"設定を保存\")\r\n+        self.save_button.clicked.connect(self.save_settings)\r\n+        self.reload_button = QPushButton(\"設定を再読込\")\r\n+        self.reload_button.clicked.connect(self.load_settings)\r\n+        save_buttons.addWidget(self.save_button)\r\n+        save_buttons.addWidget(self.reload_button)\r\n+        layout.addLayout(save_buttons)\r\n         \r\n-        ttk.Button(control_frame, text=\"設定保存\", command=self.save_settings).grid(row=6, column=0, padx=(0, 5))\r\n-        ttk.Button(control_frame, text=\"設定読込\", command=self.load_settings).grid(row=6, column=1)\r\n+        layout.addStretch()\r\n+        self.setLayout(layout)\r\n+    \r\n+    def load_settings(self):\r\n+        \"\"\"設定を読み込み\"\"\"\r\n+        settings = self.config_manager.get_detection_settings()\r\n         \r\n-        # ログフレーム\r\n-        log_frame = ttk.LabelFrame(main_frame, text=\"ログ\", padding=\"5\")\r\n-        log_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(10, 0))\r\n+        self.threshold_spin.setValue(settings['threshold'])\r\n+        self.cooldown_spin.setValue(settings['tap_cooldown'])\r\n+        self.capture_spin.setValue(settings['capture_interval'])\r\n+        self.error_spin.setValue(settings['max_error_count'])\r\n+    \r\n+    def save_settings(self):\r\n+        \"\"\"設定を保存\"\"\"\r\n+        settings = {\r\n+            'threshold': self.threshold_spin.value(),\r\n+            'tap_cooldown': self.cooldown_spin.value(),\r\n+            'capture_interval': self.capture_spin.value(),\r\n+            'max_error_count': self.error_spin.value()\r\n+        }\r\n         \r\n-        self.log_text = scrolledtext.ScrolledText(log_frame, height=15, width=80)\r\n-        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n+        self.config_manager.set_detection_settings(settings)\r\n         \r\n-        # グリッドの重み設定\r\n-        self.root.columnconfigure(0, weight=1)\r\n-        self.root.rowconfigure(0, weight=1)\r\n-        main_frame.columnconfigure(0, weight=1)\r\n-        main_frame.columnconfigure(1, weight=1)\r\n-        main_frame.rowconfigure(2, weight=1)\r\n-        device_frame.columnconfigure(0, weight=1)\r\n-        log_frame.columnconfigure(0, weight=1)\r\n-        log_frame.rowconfigure(0, weight=1)\r\n+        # エンジンに設定を適用\r\n+        self.automation_engine.set_detection_threshold(settings['threshold'])\r\n+        self.automation_engine.set_tap_cooldown(settings['tap_cooldown'])\r\n+        self.automation_engine.set_capture_interval(settings['capture_interval'])\r\n         \r\n-    def log(self, message, device_id=None):\r\n-        \"\"\"ログメッセージを表示\"\"\"\r\n-        timestamp = datetime.now().strftime(\"%H:%M:%S\")\r\n-        if device_id:\r\n-            log_message = f\"[{timestamp}] [{device_id}] {message}\\n\"\r\n-        else:\r\n-            log_message = f\"[{timestamp}] {message}\\n\"\r\n+        QMessageBox.information(self, \"保存完了\", \"設定を保存しました\")\r\n+\r\n+\r\n+class StatisticsWidget(QWidget):\r\n+    \"\"\"統計情報ウィジェット\"\"\"\r\n+    \r\n+    def __init__(self, automation_engine):\r\n+        super().__init__()\r\n+        self.automation_engine = automation_engine\r\n+        self.init_ui()\r\n         \r\n-        self.log_text.insert(tk.END, log_message)\r\n-        self.log_text.see(tk.END)\r\n-        print(log_message.strip())\r\n+        # 統計更新タイマー\r\n+        self.timer = QTimer()\r\n+        self.timer.timeout.connect(self.update_statistics)\r\n+        self.timer.start(1000)  # 1秒ごとに更新\r\n+    \r\n+    def init_ui(self):\r\n+        layout = QVBoxLayout()\r\n         \r\n-    def refresh_devices(self):\r\n-        \"\"\"ADBデバイスを更新\"\"\"\r\n-        self.devices = self.device_controller.refresh_devices()\r\n+        # 全体統計\r\n+        overall_group = QGroupBox(\"全体統計\")\r\n+        overall_layout = QGridLayout()\r\n         \r\n-        # リストボックスを更新\r\n-        self.device_listbox.delete(0, tk.END)\r\n-        for device in self.devices:\r\n-            self.device_listbox.insert(tk.END, device)\r\n+        self.total_loops_label = QLabel(\"0\")\r\n+        self.elapsed_time_label = QLabel(\"00:00:00\")\r\n+        self.loops_per_hour_label = QLabel(\"0.0\")\r\n+        self.active_devices_label = QLabel(\"0\")\r\n         \r\n-        self.log(f\"デバイス検出: {len(self.devices)}台\")\r\n+        overall_layout.addWidget(QLabel(\"総ループ数:\"), 0, 0)\r\n+        overall_layout.addWidget(self.total_loops_label, 0, 1)\r\n+        overall_layout.addWidget(QLabel(\"経過時間:\"), 1, 0)\r\n+        overall_layout.addWidget(self.elapsed_time_label, 1, 1)\r\n+        overall_layout.addWidget(QLabel(\"時間あたりループ数:\"), 2, 0)\r\n+        overall_layout.addWidget(self.loops_per_hour_label, 2, 1)\r\n+        overall_layout.addWidget(QLabel(\"アクティブデバイス数:\"), 3, 0)\r\n+        overall_layout.addWidget(self.active_devices_label, 3, 1)\r\n         \r\n-    def get_selected_devices(self):\r\n-        \"\"\"選択されたデバイスを取得\"\"\"\r\n-        selected_indices = self.device_listbox.curselection()\r\n-        return [self.devices[i] for i in selected_indices]\r\n+        overall_group.setLayout(overall_layout)\r\n+        layout.addWidget(overall_group)\r\n         \r\n-    def take_screenshot(self, device_id=None, force_new=False):\r\n-        \"\"\"スクリーンショットを取得（キャッシュ機能付き）\"\"\"\r\n-        if not device_id:\r\n-            devices = self.get_selected_devices()\r\n-            if not devices:\r\n-                messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n-                return\r\n-            device_id = devices[0]\r\n+        # デバイス別統計\r\n+        device_group = QGroupBox(\"デバイス別統計\")\r\n+        device_layout = QVBoxLayout()\r\n         \r\n-        # device_controllerのtake_screenshotメソッドを使用\r\n-        use_memory = self.memory_capture_var.get() if hasattr(self, 'memory_capture_var') else self.settings.get('use_memory_capture', True)\r\n-        screenshot = self.device_controller.take_screenshot(device_id, force_new, use_memory)\r\n-        \r\n-        if screenshot is not None:\r\n-            self.log(f\"スクリーンショット取得成功\", device_id)\r\n-            return screenshot\r\n-        else:\r\n-            self.log(f\"スクリーンショット取得失敗\", device_id)\r\n-            return None\r\n-        \r\n-    def find_image_on_screen_optimized(self, template_path, device_id, threshold=None):\r\n-        \"\"\"最適化された画像検索（メモリ直接対応）\"\"\"\r\n-        if threshold is None:\r\n-            threshold = self.similarity_var.get()\r\n-            \r\n-        # スクリーンショットを取得\r\n-        screenshot = self.take_screenshot(device_id)\r\n-        if screenshot is None:\r\n-            return None\r\n-        \r\n-        # image_detectorを使用して画像検索\r\n-        return self.image_detector.find_image_on_screen_optimized(template_path, screenshot, threshold)\r\n-            \r\n-    def find_multiple_images_on_screen_optimized(self, template_paths, device_id, threshold=None):\r\n-        \"\"\"最適化された複数画像同時検索（メモリ直接対応）\"\"\"\r\n-        if threshold is None:\r\n-            threshold = self.similarity_var.get()\r\n-            \r\n-        # スクリーンショットを取得\r\n-        screenshot = self.take_screenshot(device_id)\r\n-        if screenshot is None:\r\n-            return {}\r\n-          # image_detectorを使用して複数画像検索\r\n-        return self.image_detector.find_multiple_images_on_screen_optimized(template_paths, screenshot, threshold)\r\n-        \r\n-    def human_like_delay(self):\r\n-        \"\"\"人間らしいランダムな遅延\"\"\"\r\n-        import random\r\n-        delay = random.uniform(\r\n-            self.settings['human_like_delay_min'], \r\n-            self.settings['human_like_delay_max']\r\n+        self.device_stats_table = QTableWidget()\r\n+        self.device_stats_table.setColumnCount(5)\r\n+        self.device_stats_table.setHorizontalHeaderLabels(\r\n+            [\"デバイスID\", \"状態\", \"タップ数\", \"エラー数\", \"最終動作時刻\"]\r\n         )\r\n-        time.sleep(delay)\r\n+        self.device_stats_table.horizontalHeader().setStretchLastSection(True)\r\n+        device_layout.addWidget(self.device_stats_table)\r\n         \r\n-    def smart_tap_screen(self, x, y, device_id, tap_type=\"normal\"):\r\n-        \"\"\"スマートタップ機能（タップ種類に応じて遅延を調整）\"\"\"\r\n-        # device_controllerのsmart_tap_screenメソッドを使用\r\n-        delay_multiplier = self.delay_var.get() if hasattr(self, 'delay_var') else self.settings['tap_delay']\r\n-        success = self.device_controller.smart_tap_screen(x, y, device_id, tap_type, delay_multiplier)\r\n+        device_group.setLayout(device_layout)\r\n+        layout.addWidget(device_group)\r\n         \r\n-        if success:\r\n-            self.log(f\"タップ: ({x}, {y}) [{tap_type}]\", device_id)\r\n-        else:\r\n-            self.log(f\"タップ失敗: ({x}, {y}) [{tap_type}]\", device_id)\r\n-        return success\r\n+        # リセットボタン\r\n+        reset_button = QPushButton(\"統計をリセット\")\r\n+        reset_button.clicked.connect(self.reset_statistics)\r\n+        layout.addWidget(reset_button)\r\n         \r\n-    def start_automation(self):\r\n-        \"\"\"自動化開始\"\"\"\r\n-        selected_devices = self.get_selected_devices()\r\n-        if not selected_devices:\r\n-            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n-            return\r\n-        \r\n-        # 画像ファイルの確認\r\n-        missing_files = []\r\n-        for name, path in self.image_paths.items():\r\n-            if not os.path.exists(path):\r\n-                missing_files.append(path)\r\n-        \r\n-        if missing_files:\r\n-            messagebox.showerror(\"エラー\", f\"画像ファイルが見つかりません:\\n\" + \"\\n\".join(missing_files))\r\n-            return\r\n-        \r\n-        # 設定を更新\r\n-        self.settings['similarity_threshold'] = self.similarity_var.get()\r\n-        self.settings['tap_delay'] = self.delay_var.get()\r\n-        self.settings['puzzle_tap_count'] = self.puzzle_count_var.get()\r\n-        self.settings['check_interval'] = self.check_interval_var.get()\r\n-        self.settings['use_memory_capture'] = self.memory_capture_var.get()\r\n-        \r\n-        # automation_engineに設定を更新\r\n-        self.automation_engine.update_settings(self.settings)\r\n-        \r\n-        # automation_engineを使用して自動化開始\r\n-        self.automation_engine.start_automation(selected_devices)\r\n-        \r\n-        self.running = True\r\n-        self.start_button.config(state=tk.DISABLED)\r\n-        self.stop_button.config(state=tk.NORMAL)\r\n-        \r\n-        self.log(\"自動化開始\")\r\n-    def stop_automation(self):\r\n-        \"\"\"自動化停止\"\"\"\r\n-        self.running = False\r\n-        \r\n-        # automation_engineの停止\r\n-        self.automation_engine.stop_automation()\r\n-        \r\n-        self.start_button.config(state=tk.NORMAL)\r\n-        self.stop_button.config(state=tk.DISABLED)\r\n-        \r\n-        self.log(\"全デバイスの自動化を停止\")\r\n-        \r\n-    def save_settings(self):\r\n-        \"\"\"設定保存\"\"\"\r\n-        settings = {\r\n-            'similarity_threshold': self.similarity_var.get(),\r\n-            'tap_delay': self.delay_var.get(),\r\n-            'puzzle_tap_count': self.puzzle_count_var.get(),\r\n-            'check_interval': self.check_interval_var.get(),\r\n-            'use_memory_capture': self.memory_capture_var.get()\r\n-        }\r\n-        \r\n+        self.setLayout(layout)\r\n+    \r\n+    def update_statistics(self):\r\n+        \"\"\"統計情報を更新\"\"\"\r\n         try:\r\n-            with open('settings.json', 'w', encoding='utf-8') as f:\r\n-                json.dump(settings, f, indent=2, ensure_ascii=False)\r\n-            self.log(\"設定を保存しました\")\r\n-        except Exception as e:\r\n-            self.log(f\"設定保存エラー: {str(e)}\")\r\n+            stats = self.automation_engine.get_statistics()\r\n             \r\n-    def load_settings(self):\r\n-        \"\"\"設定読込\"\"\"\r\n-        try:\r\n-            with open('settings.json', 'r', encoding='utf-8') as f:\r\n-                settings = json.load(f)\r\n+            # 全体統計\r\n+            self.total_loops_label.setText(str(stats['total_loops']))\r\n             \r\n-            self.similarity_var.set(settings.get('similarity_threshold', 0.8))\r\n-            self.delay_var.set(settings.get('tap_delay', 0.3))\r\n-            self.puzzle_count_var.set(settings.get('puzzle_tap_count', 2))\r\n-            self.check_interval_var.set(settings.get('check_interval', 0.1))\r\n-            self.memory_capture_var.set(settings.get('use_memory_capture', True))\r\n+            # 経過時間をフォーマット\r\n+            elapsed = int(stats['elapsed_time'])\r\n+            hours = elapsed // 3600\r\n+            minutes = (elapsed % 3600) // 60\r\n+            seconds = elapsed % 60\r\n+            self.elapsed_time_label.setText(f\"{hours:02d}:{minutes:02d}:{seconds:02d}\")\r\n             \r\n-            self.log(\"設定を読み込みました\")\r\n-        except FileNotFoundError:\r\n-            self.log(\"設定ファイルが見つかりません\")\r\n-        except Exception as e:\r\n-            self.log(f\"設定読込エラー: {str(e)}\")\r\n-\r\n-    def setup_memory_capture(self, device_id):\r\n-        \"\"\"メモリ直接キャプチャのセットアップ\"\"\"\r\n-        try:\r\n-            # scrcpyのRAWモードを使用してメモリから直接取得\r\n-            cmd = [\r\n-                'adb', '-s', device_id, 'exec-out', \r\n-                'screencap'\r\n-            ]\r\n+            self.loops_per_hour_label.setText(f\"{stats['loops_per_hour']:.1f}\")\r\n+            self.active_devices_label.setText(f\"{stats['active_devices']}/{stats['total_devices']}\")\r\n             \r\n-            # プロセスを開始（継続的にデータを取得）\r\n-            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\r\n-            self.minicap_connections[device_id] = process\r\n+            # デバイス別統計\r\n+            device_details = stats['device_details']\r\n+            self.device_stats_table.setRowCount(len(device_details))\r\n             \r\n-            self.log(f\"メモリ直接キャプチャセットアップ完了\", device_id)\r\n-            return True\r\n-            \r\n-        except Exception as e:\r\n-            self.log(f\"メモリキャプチャセットアップエラー: {str(e)}\", device_id)\r\n-            return False\r\n-    def get_memory_screenshot(self, device_id):\r\n-        \"\"\"メモリから直接スクリーンショットを取得（改良版）\"\"\"\r\n-        try:\r\n-            # 方法1: ADB exec-outを使用してRAWデータを直接取得\r\n-            result = subprocess.run([\r\n-                'adb', '-s', device_id, 'exec-out', 'screencap'\r\n-            ], capture_output=True, timeout=3)\r\n-            \r\n-            if result.returncode == 0 and len(result.stdout) > 0:\r\n-                raw_data = result.stdout\r\n+            for i, (device_id, details) in enumerate(device_details.items()):\r\n+                self.device_stats_table.setItem(i, 0, QTableWidgetItem(device_id))\r\n+                self.device_stats_table.setItem(i, 1, QTableWidgetItem(details['state']))\r\n+                self.device_stats_table.setItem(i, 2, QTableWidgetItem(str(details['tap_count'])))\r\n+                self.device_stats_table.setItem(i, 3, QTableWidgetItem(str(details['error_count'])))\r\n                 \r\n-                # PNGヘッダーをチェック\r\n-                if raw_data[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n-                    # PNG形式の場合\r\n-                    nparr = np.frombuffer(raw_data, np.uint8)\r\n-                    screenshot = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\r\n-                    if screenshot is not None:\r\n-                        return screenshot\r\n+                # 最終動作時刻\r\n+                import datetime\r\n+                if details['last_action_time'] > 0:\r\n+                    last_time = datetime.datetime.fromtimestamp(details['last_action_time'])\r\n+                    time_str = last_time.strftime(\"%H:%M:%S\")\r\n+                else:\r\n+                    time_str = \"未実行\"\r\n+                self.device_stats_table.setItem(i, 4, QTableWidgetItem(time_str))\r\n                 \r\n-                # RAW形式の場合のパース（Android 4.4以降）\r\n-                if len(raw_data) >= 12:\r\n-                    # ヘッダー情報を解析\r\n-                    width = struct.unpack('<I', raw_data[0:4])[0]\r\n-                    height = struct.unpack('<I', raw_data[4:8])[0]\r\n-                    pixel_format = struct.unpack('<I', raw_data[8:12])[0]\r\n-                    \r\n-                    # 妥当性チェック\r\n-                    if 100 <= width <= 4096 and 100 <= height <= 4096:\r\n-                        if pixel_format == 1:  # RGBA_8888\r\n-                            expected_size = width * height * 4 + 12\r\n-                            if len(raw_data) >= expected_size:\r\n-                                # RGBA データを抽出\r\n-                                image_data = raw_data[12:12 + width * height * 4]\r\n-                                # numpy配列に変換\r\n-                                img_array = np.frombuffer(image_data, dtype=np.uint8)\r\n-                                img_array = img_array.reshape((height, width, 4))\r\n-                                # BGRAからBGRに変換（Alphaチャンネル削除）\r\n-                                screenshot = cv2.cvtColor(img_array, cv2.COLOR_RGBA2BGR)\r\n-                                return screenshot\r\n-            \r\n-            # 方法2: shellコマンドでscreencapを実行してファイル取得を避ける\r\n-            result2 = subprocess.run([\r\n-                'adb', '-s', device_id, 'shell', 'screencap', '-p'\r\n-            ], capture_output=True, timeout=3)\r\n-            \r\n-            if result2.returncode == 0 and len(result2.stdout) > 0:\r\n-                # base64形式でない場合の処理\r\n-                raw_data = result2.stdout\r\n-                if raw_data[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n-                    nparr = np.frombuffer(raw_data, np.uint8)\r\n-                    screenshot = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\r\n-                    if screenshot is not None:\r\n-                        return screenshot\r\n-                        \r\n-            return None\r\n-            \r\n-        except subprocess.TimeoutExpired:\r\n-            self.log(f\"メモリキャプチャタイムアウト\", device_id)\r\n-            return None\r\n         except Exception as e:\r\n-            self.log(f\"メモリキャプチャエラー: {str(e)}\", device_id)\r\n-            return None\r\n+            logging.error(f\"統計更新エラー: {e}\")\r\n     \r\n-    def fast_screenshot_to_memory(self, device_id):\r\n-        \"\"\"高速スクリーンショット（メモリ直接 or ファイル）改良版\"\"\"\r\n-        # 互換性チェック\r\n-        if device_id not in self.device_compatibility:\r\n-            self.log_device_compatibility(device_id)\r\n+    def reset_statistics(self):\r\n+        \"\"\"統計をリセット\"\"\"\r\n+        reply = QMessageBox.question(self, \"確認\", \"統計情報をリセットしますか？\",\r\n+                                   QMessageBox.Yes | QMessageBox.No)\r\n+        if reply == QMessageBox.Yes:\r\n+            self.automation_engine.reset_statistics()\r\n+\r\n+\r\n+class MainWindow(QMainWindow):\r\n+    \"\"\"メインウィンドウ\"\"\"\r\n+    \r\n+    def __init__(self):\r\n+        super().__init__()\r\n+        self.config_manager = ConfigManager()\r\n+        setup_logging(self.config_manager)\r\n         \r\n-        # メモリ直接取得を試行（サポートされている場合のみ）\r\n-        if (self.memory_capture_var.get() and \r\n-            self.device_compatibility.get(device_id, {}).get('memory_capture_supported', False)):\r\n-            \r\n-            screenshot = self.get_memory_screenshot(device_id)\r\n-            if screenshot is not None:\r\n-                # メモリ取得成功のログ（初回のみ）\r\n-                if not hasattr(self, '_memory_success_logged'):\r\n-                    self.log(f\"メモリ直接取得成功\", device_id)\r\n-                    self._memory_success_logged = True\r\n-                return screenshot\r\n-            else:\r\n-                # フォールバック回数を記録\r\n-                self.fallback_count[device_id] = self.fallback_count.get(device_id, 0) + 1\r\n-                \r\n-                # 連続失敗時は一時的にメモリ取得を無効化\r\n-                if self.fallback_count[device_id] >= 5:\r\n-                    self.device_compatibility[device_id]['memory_capture_supported'] = False\r\n-                    self.log(\"メモリ取得を一時無効化（連続失敗）\", device_id)\r\n+        self.automation_engine = AutomationEngine()\r\n+        self.automation_worker = None\r\n         \r\n-        # 従来のファイル方式（高速化版）\r\n-        screenshot_path = self.take_screenshot_fast(device_id)\r\n-        if screenshot_path:\r\n-            return cv2.imread(screenshot_path)\r\n+        self.init_ui()\r\n+        self.init_tray()\r\n+        self.load_gui_settings()\r\n         \r\n-        return None\r\n+        # ログハンドラーを追加\r\n+        self.log_handler = LogHandler()\r\n+        self.log_handler.log_signal.connect(self.append_log)\r\n+        logging.getLogger().addHandler(self.log_handler)\r\n     \r\n-    def take_screenshot_fast(self, device_id):\r\n-        \"\"\"高速ファイルベーススクリーンショット\"\"\"\r\n-        try:\r\n-            # テンポラリファイル名を使用\r\n-            temp_name = f'/sdcard/temp_screenshot_{int(time.time() * 1000) % 10000}.png'\r\n-            local_path = f'temp_screenshot_{device_id}.png'\r\n-            \r\n-            # 高速スクリーンショット取得\r\n-            subprocess.run(['adb', '-s', device_id, 'shell', 'screencap', temp_name], \r\n-                         check=True, capture_output=True, timeout=3)\r\n-            subprocess.run(['adb', '-s', device_id, 'pull', temp_name, local_path], \r\n-                         check=True, capture_output=True, timeout=3)\r\n-            \r\n-            # デバイス上のテンポラリファイルを削除\r\n-            subprocess.run(['adb', '-s', device_id, 'shell', 'rm', temp_name], \r\n-                         capture_output=True, timeout=1)\r\n-            \r\n-            return local_path\r\n-            \r\n-        except (subprocess.TimeoutExpired, subprocess.CalledProcessError) as e:\r\n-            self.log(f\"高速スクリーンショットエラー: {str(e)}\", device_id)\r\n-            return None\r\n-    def check_device_memory_support(self, device_id):\r\n-        \"\"\"デバイスのメモリ直接取得サポートをチェック\"\"\"\r\n-        try:\r\n-            # Androidバージョンを取得\r\n-            result = subprocess.run([\r\n-                'adb', '-s', device_id, 'shell', 'getprop', 'ro.build.version.release'\r\n-            ], capture_output=True, text=True, timeout=5)\r\n-            \r\n-            if result.returncode == 0:\r\n-                android_version = result.stdout.strip()\r\n-                self.log(f\"Androidバージョン: {android_version}\", device_id)\r\n-                \r\n-                # Android 4.4以降でexec-outをサポート\r\n-                try:\r\n-                    version_num = float(android_version.split('.')[0])\r\n-                    if version_num >= 4:\r\n-                        return True\r\n-                except:\r\n-                    pass\r\n-            \r\n-            # exec-outコマンドが使用可能かテスト\r\n-            test_result = subprocess.run([\r\n-                'adb', '-s', device_id, 'exec-out', 'echo', 'test'\r\n-            ], capture_output=True, timeout=3)\r\n-            \r\n-            if test_result.returncode == 0 and b'test' in test_result.stdout:\r\n-                self.log(f\"exec-outコマンド利用可能\", device_id)\r\n-                return True\r\n-            else:\r\n-                self.log(f\"exec-outコマンド利用不可 - ファイル方式を使用\", device_id)\r\n-                return False\r\n-                \r\n-        except Exception as e:\r\n-            self.log(f\"デバイス互換性チェックエラー: {str(e)}\", device_id)\r\n-            return False\r\n-    def check_device_compatibility(self, device_id):\r\n-        \"\"\"デバイスの互換性チェック\"\"\"\r\n-        if device_id in self.device_compatibility:\r\n-            return self.device_compatibility[device_id]\r\n+    def init_ui(self):\r\n+        self.setWindowTitle(\"妖怪ウォッチぷにぷに 自動周回ツール\")\r\n+        self.setMinimumSize(800, 600)\r\n         \r\n-        compatibility = {\r\n-            'exec_out_supported': False,\r\n-            'android_version': 'unknown',\r\n-            'memory_capture_supported': False,\r\n-            'reason': ''\r\n-        }\r\n+        # 中央ウィジェット\r\n+        central_widget = QWidget()\r\n+        self.setCentralWidget(central_widget)\r\n         \r\n-        try:\r\n-            # Androidバージョンを取得\r\n-            result = subprocess.run(['adb', '-s', device_id, 'shell', 'getprop', 'ro.build.version.release'],\r\n-                                  capture_output=True, text=True, timeout=10)\r\n-            if result.returncode == 0:\r\n-                compatibility['android_version'] = result.stdout.strip()\r\n-            \r\n-            # exec-out screencapコマンドの動作テスト\r\n-            result = subprocess.run(['adb', '-s', device_id, 'exec-out', 'screencap', '-p'],\r\n-                                  capture_output=True, timeout=15)\r\n-            \r\n-            if result.returncode == 0 and len(result.stdout) > 1000:  # 最小限の画像データサイズ\r\n-                compatibility['exec_out_supported'] = True\r\n-                compatibility['memory_capture_supported'] = True\r\n-                compatibility['reason'] = 'Memory capture fully supported'\r\n-            else:\r\n-                compatibility['reason'] = f'exec-out failed (returncode: {result.returncode})'\r\n-                \r\n-        except subprocess.TimeoutExpired:\r\n-            compatibility['reason'] = 'Command timeout'\r\n-        except Exception as e:\r\n-            compatibility['reason'] = f'Error: {str(e)}'\r\n+        # メインレイアウト\r\n+        main_layout = QHBoxLayout()\r\n         \r\n-        self.device_compatibility[device_id] = compatibility\r\n-        return compatibility\r\n-\r\n-    def log_device_compatibility(self, device_id):\r\n-        \"\"\"デバイス互換性情報をログ出力\"\"\"\r\n-        compat = self.check_device_compatibility(device_id)\r\n-        self.log(f\"デバイス互換性チェック: Android {compat['android_version']}\", device_id)\r\n-        if compat['memory_capture_supported']:\r\n-            self.log(\"メモリ直接取得: サポート\", device_id)\r\n-        else:\r\n-            self.log(f\"メモリ直接取得: 非サポート - {compat['reason']}\", device_id)\r\n-            self.log(\"通常のファイル方式を使用します\", device_id)\r\n-    def diagnostic_memory_capture(self, device_id):\r\n-        \"\"\"メモリ直接取得の診断情報を表示\"\"\"\r\n-        self.log(\"=== メモリ直接取得診断 ===\", device_id)\r\n+        # 左側：制御パネル\r\n+        control_panel = QVBoxLayout()\r\n         \r\n-        try:\r\n-            # 1. デバイス情報取得\r\n-            info_cmd = ['adb', '-s', device_id, 'shell', 'getprop']\r\n-            result = subprocess.run(info_cmd, capture_output=True, text=True, timeout=5)\r\n-            if result.returncode == 0:\r\n-                lines = result.stdout.split('\\n')\r\n-                for line in lines:\r\n-                    if 'ro.build.version.release' in line or 'ro.build.version.sdk' in line:\r\n-                        self.log(f\"デバイス情報: {line.strip()}\", device_id)\r\n-            \r\n-            # 2. exec-outコマンドのサポート確認\r\n-            test_cmd = ['adb', '-s', device_id, 'exec-out', 'echo', 'test']\r\n-            result = subprocess.run(test_cmd, capture_output=True, timeout=3)\r\n-            if result.returncode == 0:\r\n-                self.log(\"exec-out コマンド: サポート\", device_id)\r\n-            else:\r\n-                self.log(f\"exec-out コマンド: 非サポート (code: {result.returncode})\", device_id)\r\n-            \r\n-            # 3. screencapコマンドの直接実行\r\n-            screencap_cmd = ['adb', '-s', device_id, 'shell', 'screencap', '-h']\r\n-            result = subprocess.run(screencap_cmd, capture_output=True, text=True, timeout=3)\r\n-            if result.returncode == 0:\r\n-                self.log(\"screencap コマンド: 利用可能\", device_id)\r\n-            else:\r\n-                self.log(f\"screencap コマンド: エラー (code: {result.returncode})\", device_id)\r\n-            \r\n-            # 4. 実際のメモリ取得を試行\r\n-            memory_cmd = ['adb', '-s', device_id, 'exec-out', 'screencap']\r\n-            result = subprocess.run(memory_cmd, capture_output=True, timeout=5)\r\n-            \r\n-            if result.returncode == 0:\r\n-                data_size = len(result.stdout)\r\n-                self.log(f\"メモリ取得: 成功 (データサイズ: {data_size} bytes)\", device_id)\r\n-                \r\n-                if data_size > 0:\r\n-                    # データ形式を確認\r\n-                    header = result.stdout[:16]\r\n-                    self.log(f\"データヘッダー: {header}\", device_id)\r\n-                    \r\n-                    if header[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n-                        self.log(\"データ形式: PNG\", device_id)\r\n-                    else:\r\n-                        self.log(\"データ形式: RAW (もしくは不明)\", device_id)\r\n-                else:\r\n-                    self.log(\"メモリ取得: データが空\", device_id)\r\n-            else:\r\n-                self.log(f\"メモリ取得: 失敗 (code: {result.returncode})\", device_id)\r\n-                if result.stderr:\r\n-                    error_msg = result.stderr.decode('utf-8', errors='ignore')\r\n-                    self.log(f\"エラー詳細: {error_msg}\", device_id)\r\n-            \r\n-        except Exception as e:\r\n-            self.log(f\"診断エラー: {str(e)}\", device_id)\r\n+        # 開始/停止ボタン\r\n+        self.start_button = QPushButton(\"自動化開始\")\r\n+        self.start_button.setStyleSheet(\"QPushButton { background-color: #4CAF50; color: white; font-size: 14px; padding: 10px; }\")\r\n+        self.start_button.clicked.connect(self.start_automation)\r\n         \r\n-        self.log(\"=== 診断終了 ===\", device_id)\r\n-    \r\n-    def run_memory_diagnostic(self):\r\n-        \"\"\"メモリ診断を実行\"\"\"\r\n-        selected_devices = self.get_selected_devices()\r\n-        if not selected_devices:\r\n-            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n-            return\r\n+        self.stop_button = QPushButton(\"自動化停止\")\r\n+        self.stop_button.setStyleSheet(\"QPushButton { background-color: #f44336; color: white; font-size: 14px; padding: 10px; }\")\r\n+        self.stop_button.clicked.connect(self.stop_automation)\r\n+        self.stop_button.setEnabled(False)\r\n         \r\n-        self.log(\"メモリ直接取得の診断を開始します\")\r\n-        for device_id in selected_devices:\r\n-            self.diagnostic_memory_capture(device_id)\r\n-    \r\n-    def find_image_with_multiple_thresholds(self, template_path, device_id, initial_threshold=None):\r\n-        \"\"\"複数の閾値でplayボタンを検索（段階的に閾値を下げる）\"\"\"\r\n-        if initial_threshold is None:\r\n-            initial_threshold = self.similarity_var.get()\r\n+        control_panel.addWidget(self.start_button)\r\n+        control_panel.addWidget(self.stop_button)\r\n         \r\n-        # 段階的に閾値を下げて検索\r\n-        thresholds = [initial_threshold, initial_threshold - 0.1, initial_threshold - 0.2, 0.6]\r\n+        # ログ表示\r\n+        log_group = QGroupBox(\"ログ\")\r\n+        log_layout = QVBoxLayout()\r\n         \r\n-        for threshold in thresholds:\r\n-            if threshold < 0.5:  # 最低限の閾値\r\n-                break\r\n-                \r\n-            result = self.find_image_on_screen_optimized(template_path, device_id, threshold)\r\n-            if result:\r\n-                self.log(f\"画像検出成功 (閾値: {threshold:.2f}): {template_path}\", device_id)\r\n-                return result\r\n-            else:\r\n-                self.log(f\"画像未検出 (閾値: {threshold:.2f}): {template_path}\", device_id)\r\n+        self.log_text = QTextEdit()\r\n+        self.log_text.setReadOnly(True)\r\n+        self.log_text.setMaximumBlockCount(1000)  # 最大1000行\r\n+        log_layout.addWidget(self.log_text)\r\n         \r\n-        return None\r\n-\r\n-    def test_image_detection(self):\r\n-        \"\"\"画像検出のテスト機能\"\"\"\r\n-        selected_devices = self.get_selected_devices()\r\n-        if not selected_devices:\r\n-            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n-            return\r\n+        log_group.setLayout(log_layout)\r\n+        control_panel.addWidget(log_group)\r\n         \r\n-        device_id = selected_devices[0]\r\n+        # 右側：タブウィジェット\r\n+        self.tab_widget = QTabWidget()\r\n         \r\n-        self.log(\"=== 画像検出テスト ===\", device_id)\r\n+        # デバイス管理タブ\r\n+        self.device_widget = DeviceManagementWidget(self.automation_engine)\r\n+        self.tab_widget.addTab(self.device_widget, \"デバイス管理\")\r\n         \r\n-        # すべての画像ファイルをテスト\r\n-        for name, path in self.image_paths.items():\r\n-            self.log(f\"テスト対象: {name} ({path})\", device_id)\r\n-            \r\n-            # 画像ファイルの存在確認\r\n-            if not os.path.exists(path):\r\n-                self.log(f\"❌ ファイルが存在しません: {path}\", device_id)\r\n-                continue\r\n-            \r\n-            # 画像の読み込みテスト\r\n-            template = cv2.imread(path)\r\n-            if template is None:\r\n-                self.log(f\"❌ 画像読み込み失敗: {path}\", device_id)\r\n-                continue\r\n-            \r\n-            height, width = template.shape[:2]\r\n-            self.log(f\"✅ 画像読み込み成功: {width}x{height}\", device_id)\r\n-            \r\n-            # 現在の画面で検索テスト\r\n-            result = self.find_image_with_multiple_thresholds(path, device_id)\r\n-            if result:\r\n-                self.log(f\"✅ 検出成功: {name} at {result}\", device_id)\r\n-            else:\r\n-                self.log(f\"❌ 検出失敗: {name}\", device_id)        \r\n-        self.log(\"=== テスト終了 ===\", device_id)\r\n-    \r\n-    def test_puzzle_detection_specifically(self):\r\n-        \"\"\"puzzle.png超詳細テスト（全検出方法）\"\"\"\r\n-        selected_devices = self.get_selected_devices()\r\n-        if not selected_devices:\r\n-            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n-            return\r\n+        # 設定タブ\r\n+        self.settings_widget = SettingsWidget(self.automation_engine, self.config_manager)\r\n+        self.tab_widget.addTab(self.settings_widget, \"設定\")\r\n         \r\n-        device_id = selected_devices[0]\r\n-        self.enhanced_puzzle_detection_test(device_id)\r\n-    \r\n-    def find_puzzle_with_enhanced_detection(self, device_id):\r\n-        \"\"\"puzzle.png専用の超強化検知機能\"\"\"\r\n-        screenshot = self.fast_screenshot_to_memory(device_id)\r\n-        if screenshot is None:\r\n-            return None\r\n+        # 統計タブ\r\n+        self.stats_widget = StatisticsWidget(self.automation_engine)\r\n+        self.tab_widget.addTab(self.stats_widget, \"統計\")\r\n         \r\n-        template = cv2.imread(self.image_paths['puzzle'])\r\n-        if template is None:\r\n-            self.log(\"puzzle画像ファイルが読み込めません\", device_id)\r\n-            return None\r\n+        # レイアウト配置\r\n+        left_widget = QWidget()\r\n+        left_widget.setLayout(control_panel)\r\n+        left_widget.setMaximumWidth(400)\r\n         \r\n-        # 検出方法1: 段階的閾値検索\r\n-        thresholds = [self.similarity_var.get(), 0.8, 0.7, 0.6, 0.5, 0.4, 0.3]\r\n-        for i, threshold in enumerate(thresholds):\r\n-            result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n-            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-            \r\n-            if max_val >= threshold:\r\n-                h, w = template.shape[:2]\r\n-                center_x = max_loc[0] + w // 2\r\n-                center_y = max_loc[1] + h // 2\r\n-                self.log(f\"puzzle検出成功-方法1 (閾値: {threshold:.2f}, 信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n-                return (center_x, center_y)\r\n+        main_layout.addWidget(left_widget)\r\n+        main_layout.addWidget(self.tab_widget)\r\n         \r\n-        # 検出方法2: 複数マッチング手法\r\n-        matching_methods = [\r\n-            cv2.TM_CCOEFF_NORMED,\r\n-            cv2.TM_CCORR_NORMED,\r\n-            cv2.TM_SQDIFF_NORMED\r\n-        ]\r\n+        central_widget.setLayout(main_layout)\r\n         \r\n-        for method_idx, method in enumerate(matching_methods):\r\n-            try:\r\n-                result = cv2.matchTemplate(screenshot, template, method)\r\n-                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-                \r\n-                # TM_SQDIFF_NORMEDの場合は最小値を使用\r\n-                if method == cv2.TM_SQDIFF_NORMED:\r\n-                    if min_val <= 0.4:  # 低い値が良いマッチ\r\n-                        h, w = template.shape[:2]\r\n-                        center_x = min_loc[0] + w // 2\r\n-                        center_y = min_loc[1] + h // 2\r\n-                        self.log(f\"puzzle検出成功-方法2-{method_idx+1} (信頼度: {1-min_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n-                        return (center_x, center_y)\r\n-                else:\r\n-                    if max_val >= 0.3:\r\n-                        h, w = template.shape[:2]\r\n-                        center_x = max_loc[0] + w // 2\r\n-                        center_y = max_loc[1] + h // 2\r\n-                        self.log(f\"puzzle検出成功-方法2-{method_idx+1} (信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n-                        return (center_x, center_y)\r\n-            except Exception as e:\r\n-                continue\r\n+        # ステータスバー\r\n+        self.statusBar().showMessage(\"準備完了\")\r\n+    \r\n+    def init_tray(self):\r\n+        \"\"\"システムトレイを初期化\"\"\"\r\n+        self.tray_icon = QSystemTrayIcon(self)\r\n         \r\n-        # 検出方法3: スケール変換対応\r\n-        scales = [1.0, 0.9, 1.1, 0.8, 1.2, 0.7, 1.3]\r\n-        for scale in scales:\r\n-            try:\r\n-                if scale != 1.0:\r\n-                    h, w = template.shape[:2]\r\n-                    new_h, new_w = int(h * scale), int(w * scale)\r\n-                    scaled_template = cv2.resize(template, (new_w, new_h))\r\n-                else:\r\n-                    scaled_template = template\r\n-                \r\n-                result = cv2.matchTemplate(screenshot, scaled_template, cv2.TM_CCOEFF_NORMED)\r\n-                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-                \r\n-                if max_val >= 0.3:\r\n-                    h, w = scaled_template.shape[:2]\r\n-                    center_x = max_loc[0] + w // 2\r\n-                    center_y = max_loc[1] + h // 2\r\n-                    self.log(f\"puzzle検出成功-方法3 (スケール: {scale:.1f}, 信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n-                    return (center_x, center_y)\r\n-            except Exception as e:\r\n-                continue\r\n+        # トレイメニュー\r\n+        tray_menu = QMenu()\r\n         \r\n-        # 検出方法4: グレースケール＋エッジ検出\r\n-        try:\r\n-            gray_screenshot = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)\r\n-            gray_template = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)\r\n-            \r\n-            # エッジ検出\r\n-            screenshot_edges = cv2.Canny(gray_screenshot, 50, 150)\r\n-            template_edges = cv2.Canny(gray_template, 50, 150)\r\n-            \r\n-            result = cv2.matchTemplate(screenshot_edges, template_edges, cv2.TM_CCOEFF_NORMED)\r\n-            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-            \r\n-            if max_val >= 0.2:  # エッジ検出は閾値を下げる\r\n-                h, w = template_edges.shape[:2]\r\n-                center_x = max_loc[0] + w // 2\r\n-                center_y = max_loc[1] + h // 2\r\n-                self.log(f\"puzzle検出成功-方法4 (エッジ検出, 信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n-                return (center_x, center_y)\r\n-        except Exception as e:\r\n-            pass\r\n+        show_action = QAction(\"表示\", self)\r\n+        show_action.triggered.connect(self.show)\r\n+        tray_menu.addAction(show_action)\r\n         \r\n-        # 検出方法5: HSV色空間での検索\r\n-        try:\r\n-            hsv_screenshot = cv2.cvtColor(screenshot, cv2.COLOR_BGR2HSV)\r\n-            hsv_template = cv2.cvtColor(template, cv2.COLOR_BGR2HSV)\r\n-            \r\n-            result = cv2.matchTemplate(hsv_screenshot, hsv_template, cv2.TM_CCOEFF_NORMED)\r\n-            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-            \r\n-            if max_val >= 0.25:\r\n-                h, w = hsv_template.shape[:2]\r\n-                center_x = max_loc[0] + w // 2\r\n-                center_y = max_loc[1] + h // 2\r\n-                self.log(f\"puzzle検出成功-方法5 (HSV, 信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n-                return (center_x, center_y)\r\n-        except Exception as e:\r\n-            pass\r\n+        hide_action = QAction(\"非表示\", self)\r\n+        hide_action.triggered.connect(self.hide)\r\n+        tray_menu.addAction(hide_action)\r\n         \r\n-        # 検出方法6: 画像の明度調整\r\n-        try:\r\n-            # 明度を調整したバージョンで試行\r\n-            brightness_adjustments = [1.2, 0.8, 1.5, 0.6]\r\n-            for brightness in brightness_adjustments:\r\n-                adjusted_screenshot = cv2.convertScaleAbs(screenshot, alpha=brightness, beta=0)\r\n-                result = cv2.matchTemplate(adjusted_screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n-                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-                \r\n-                if max_val >= 0.3:\r\n-                    h, w = template.shape[:2]\r\n-                    center_x = max_loc[0] + w // 2\r\n-                    center_y = max_loc[1] + h // 2\r\n-                    self.log(f\"puzzle検出成功-方法6 (明度調整: {brightness:.1f}, 信頼度: {max_val:.3f}): ({center_x}, {center_y})\", device_id)\r\n-                    return (center_x, center_y)\r\n-        except Exception as e:\r\n-            pass\r\n+        tray_menu.addSeparator()\r\n         \r\n-        self.log(\"❌ puzzle検出失敗 - 全ての検出方法で未検出\", device_id)\r\n-        return None\r\n-\r\n-    def toggle_realtime_monitor(self):\r\n-        \"\"\"リアルタイム監視の開始/停止\"\"\"\r\n-        if not self.realtime_monitoring:\r\n-            selected_devices = self.get_selected_devices()\r\n-            if not selected_devices:\r\n-                messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n-                return\r\n-            \r\n-            self.realtime_monitoring = True\r\n-            self.realtime_monitor_button.config(text=\"監視停止\")\r\n-            \r\n-            # 監視スレッドを開始\r\n-            self.realtime_monitor_thread = threading.Thread(\r\n-                target=self.realtime_monitor_loop, \r\n-                args=(selected_devices[0],)\r\n-            )\r\n-            self.realtime_monitor_thread.daemon = True\r\n-            self.realtime_monitor_thread.start()\r\n-            \r\n-            self.log(\"リアルタイム監視開始\")\r\n-        else:\r\n-            self.realtime_monitoring = False\r\n-            self.realtime_monitor_button.config(text=\"リアルタイム監視\")\r\n-            self.log(\"リアルタイム監視停止\")\r\n-    \r\n-    def realtime_monitor_loop(self, device_id):\r\n-        \"\"\"リアルタイム監視のメインループ\"\"\"\r\n-        last_detection_status = {}\r\n+        quit_action = QAction(\"終了\", self)\r\n+        quit_action.triggered.connect(self.quit_application)\r\n+        tray_menu.addAction(quit_action)\r\n         \r\n-        while self.realtime_monitoring:\r\n-            try:\r\n-                # 全画像を同時検索\r\n-                all_images = self.image_paths.copy()\r\n-                detected = self.find_multiple_images_on_screen_optimized(all_images, device_id)\r\n-                \r\n-                # 検出状況の変化をログ\r\n-                current_status = {}\r\n-                for name in all_images.keys():\r\n-                    current_status[name] = name in detected\r\n-                    \r\n-                    # 状態が変化した場合のみログ\r\n-                    if name not in last_detection_status or last_detection_status[name] != current_status[name]:\r\n-                        if current_status[name]:\r\n-                            confidence = detected[name]['confidence']\r\n-                            pos = detected[name]['pos']\r\n-                            self.log(f\"🔍 検出: {name} (信頼度: {confidence:.3f}, 位置: {pos})\", device_id)\r\n-                        else:\r\n-                            self.log(f\"❌ 消失: {name}\", device_id)\r\n-                \r\n-                # puzzle.pngが検出されていない場合は強化検知を試行\r\n-                if not current_status.get('puzzle', False):\r\n-                    puzzle_pos = self.find_puzzle_with_enhanced_detection(device_id)\r\n-                    if puzzle_pos:\r\n-                        self.log(f\"🔍 強化検出: puzzle (位置: {puzzle_pos})\", device_id)\r\n-                        current_status['puzzle'] = True\r\n-                \r\n-                last_detection_status = current_status.copy()\r\n-                \r\n-                # 1秒間隔で監視\r\n-                time.sleep(1.0)\r\n-                \r\n-            except Exception as e:\r\n-                self.log(f\"監視エラー: {str(e)}\", device_id)\r\n-                time.sleep(1.0)\r\n+        self.tray_icon.setContextMenu(tray_menu)\r\n+        self.tray_icon.activated.connect(self.tray_icon_activated)\r\n+        \r\n+        # アイコンを設定（デフォルトアイコン）\r\n+        self.tray_icon.setIcon(self.style().standardIcon(self.style().SP_ComputerIcon))\r\n+        self.tray_icon.show()\r\n     \r\n-    def enhanced_puzzle_detection_test(self, device_id):\r\n-        \"\"\"puzzle.png検出テストの全バリエーション\"\"\"\r\n-        self.log(\"=== puzzle.png 超詳細テスト ===\", device_id)\r\n+    def tray_icon_activated(self, reason):\r\n+        \"\"\"トレイアイコンがクリックされた時の処理\"\"\"\r\n+        if reason == QSystemTrayIcon.DoubleClick:\r\n+            self.show()\r\n+    \r\n+    def load_gui_settings(self):\r\n+        \"\"\"GUI設定を読み込み\"\"\"\r\n+        gui_settings = self.config_manager.get_gui_settings()\r\n         \r\n-        # 画像ファイルの確認\r\n-        if not os.path.exists(self.image_paths['puzzle']):\r\n-            self.log(\"❌ puzzle.pngファイルが存在しません\", device_id)\r\n-            return\r\n+        self.resize(gui_settings['window_width'], gui_settings['window_height'])\r\n         \r\n-        template = cv2.imread(self.image_paths['puzzle'])\r\n-        if template is None:\r\n-            self.log(\"❌ puzzle.png読み込み失敗\", device_id)\r\n+        if gui_settings['always_on_top']:\r\n+            self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)\r\n+    \r\n+    def start_automation(self):\r\n+        \"\"\"自動化を開始\"\"\"\r\n+        if not self.automation_engine.get_device_list():\r\n+            QMessageBox.warning(self, \"警告\", \"デバイスが登録されていません\")\r\n             return\r\n         \r\n-        template_h, template_w = template.shape[:2]\r\n-        self.log(f\"✅ puzzle.pngサイズ: {template_w}x{template_h}\", device_id)\r\n+        self.automation_worker = AutomationWorker(self.automation_engine)\r\n+        self.automation_worker.log_signal.connect(self.append_log)\r\n+        self.automation_worker.error_signal.connect(self.show_error)\r\n+        self.automation_worker.start()\r\n         \r\n-        # スクリーンショット取得\r\n-        screenshot = self.fast_screenshot_to_memory(device_id)\r\n-        if screenshot is None:\r\n-            self.log(\"❌ スクリーンショット取得失敗\", device_id)\r\n-            return\r\n+        self.start_button.setEnabled(False)\r\n+        self.stop_button.setEnabled(True)\r\n+        self.statusBar().showMessage(\"自動化実行中...\")\r\n         \r\n-        screenshot_h, screenshot_w = screenshot.shape[:2]\r\n-        self.log(f\"✅ スクリーンショットサイズ: {screenshot_w}x{screenshot_h}\", device_id)\r\n+        self.append_log(\"自動化を開始しました\")\r\n+    \r\n+    def stop_automation(self):\r\n+        \"\"\"自動化を停止\"\"\"\r\n+        if self.automation_worker:\r\n+            self.automation_worker.stop()\r\n+            self.automation_worker.wait()\r\n+            self.automation_worker = None\r\n         \r\n-        # 各検出方法をテスト\r\n-        methods = [\r\n-            (\"方法1: 通常マッチング\", self.test_normal_matching),\r\n-            (\"方法2: 複数アルゴリズム\", self.test_multiple_algorithms),\r\n-            (\"方法3: スケール変換\", self.test_scale_matching),\r\n-            (\"方法4: エッジ検出\", self.test_edge_matching),\r\n-            (\"方法5: HSV色空間\", self.test_hsv_matching),\r\n-            (\"方法6: 明度調整\", self.test_brightness_matching)\r\n-        ]\r\n+        self.start_button.setEnabled(True)\r\n+        self.stop_button.setEnabled(False)\r\n+        self.statusBar().showMessage(\"自動化停止\")\r\n         \r\n-        for method_name, test_func in methods:\r\n-            self.log(f\"--- {method_name} ---\", device_id)\r\n-            result = test_func(screenshot, template, device_id)\r\n-            if result:\r\n-                self.log(f\"✅ {method_name}: 成功 {result}\", device_id)\r\n-            else:\r\n-                self.log(f\"❌ {method_name}: 失敗\", device_id)\r\n-        \r\n-        self.log(\"=== puzzle.png 超詳細テスト 終了 ===\", device_id)\r\n+        self.append_log(\"自動化を停止しました\")\r\n     \r\n-    def test_normal_matching(self, screenshot, template, device_id):\r\n-        \"\"\"通常マッチングテスト\"\"\"\r\n-        thresholds = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2]\r\n-        for threshold in thresholds:\r\n-            result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n-            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-            if max_val >= threshold:\r\n-                h, w = template.shape[:2]\r\n-                center_x, center_y = max_loc[0] + w // 2, max_loc[1] + h // 2\r\n-                return f\"(閾値: {threshold:.1f}, 信頼度: {max_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n-        return None\r\n+    def append_log(self, message):\r\n+        \"\"\"ログを追加\"\"\"\r\n+        import datetime\r\n+        timestamp = datetime.datetime.now().strftime(\"%H:%M:%S\")\r\n+        self.log_text.append(f\"[{timestamp}] {message}\")\r\n     \r\n-    def test_multiple_algorithms(self, screenshot, template, device_id):\r\n-        \"\"\"複数アルゴリズムテスト\"\"\"\r\n-        algorithms = [\r\n-            (cv2.TM_CCOEFF_NORMED, \"CCOEFF_NORMED\"),\r\n-            (cv2.TM_CCORR_NORMED, \"CCORR_NORMED\"),\r\n-            (cv2.TM_SQDIFF_NORMED, \"SQDIFF_NORMED\")\r\n-        ]\r\n+    def show_error(self, message):\r\n+        \"\"\"エラーを表示\"\"\"\r\n+        QMessageBox.critical(self, \"エラー\", message)\r\n+        self.append_log(f\"エラー: {message}\")\r\n+    \r\n+    def closeEvent(self, event):\r\n+        \"\"\"ウィンドウを閉じる時の処理\"\"\"\r\n+        gui_settings = self.config_manager.get_gui_settings()\r\n         \r\n-        for method, name in algorithms:\r\n-            try:\r\n-                result = cv2.matchTemplate(screenshot, template, method)\r\n-                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-                \r\n-                if method == cv2.TM_SQDIFF_NORMED:\r\n-                    if min_val <= 0.4:\r\n-                        h, w = template.shape[:2]\r\n-                        center_x, center_y = min_loc[0] + w // 2, min_loc[1] + h // 2\r\n-                        return f\"({name}, 信頼度: {1-min_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n-                else:\r\n-                    if max_val >= 0.3:\r\n-                        h, w = template.shape[:2]\r\n-                        center_x, center_y = max_loc[0] + w // 2, max_loc[1] + h // 2\r\n-                        return f\"({name}, 信頼度: {max_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n-            except:\r\n-                continue\r\n-        return None\r\n+        if gui_settings['minimize_to_tray'] and self.tray_icon.isVisible():\r\n+            self.hide()\r\n+            event.ignore()\r\n+        else:\r\n+            self.quit_application()\r\n     \r\n-    def test_scale_matching(self, screenshot, template, device_id):\r\n-        \"\"\"スケールマッチングテスト\"\"\"\r\n-        scales = [1.0, 0.9, 1.1, 0.8, 1.2, 0.7, 1.3]\r\n-        for scale in scales:\r\n-            try:\r\n-                h, w = template.shape[:2]\r\n-                new_h, new_w = int(h * scale), int(w * scale)\r\n-                if new_w > 0 and new_h > 0:\r\n-                    scaled_template = cv2.resize(template, (new_w, new_h))\r\n-                    result = cv2.matchTemplate(screenshot, scaled_template, cv2.TM_CCOEFF_NORMED)\r\n-                    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-                    if max_val >= 0.3:\r\n-                        sh, sw = scaled_template.shape[:2]\r\n-                        center_x, center_y = max_loc[0] + sw // 2, max_loc[1] + sh // 2\r\n-                        return f\"(スケール: {scale:.1f}, 信頼度: {max_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n-            except:\r\n-                continue\r\n-        return None\r\n+    def quit_application(self):\r\n+        \"\"\"アプリケーションを終了\"\"\"\r\n+        if self.automation_worker:\r\n+            self.stop_automation()\r\n+        \r\n+        # 設定を保存\r\n+        gui_settings = {\r\n+            'window_width': self.width(),\r\n+            'window_height': self.height(),\r\n+            'always_on_top': bool(self.windowFlags() & Qt.WindowStaysOnTopHint),\r\n+            'minimize_to_tray': True\r\n+        }\r\n+        self.config_manager.set_gui_settings(gui_settings)\r\n+        \r\n+        QApplication.quit()\r\n+\r\n+\r\n+class LogHandler(logging.Handler):\r\n+    \"\"\"ログをGUIに表示するためのハンドラー\"\"\"\r\n     \r\n-    def test_edge_matching(self, screenshot, template, device_id):\r\n-        \"\"\"エッジマッチングテスト\"\"\"\r\n-        try:\r\n-            gray_screenshot = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)\r\n-            gray_template = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)\r\n-            \r\n-            screenshot_edges = cv2.Canny(gray_screenshot, 50, 150)\r\n-            template_edges = cv2.Canny(gray_template, 50, 150)\r\n-            \r\n-            result = cv2.matchTemplate(screenshot_edges, template_edges, cv2.TM_CCOEFF_NORMED)\r\n-            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-            \r\n-            if max_val >= 0.2:\r\n-                h, w = template_edges.shape[:2]\r\n-                center_x, center_y = max_loc[0] + w // 2, max_loc[1] + h // 2\r\n-                return f\"(エッジ検出, 信頼度: {max_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n-        except:\r\n-            pass\r\n-        return None\r\n+    log_signal = pyqtSignal(str)\r\n     \r\n-    def test_hsv_matching(self, screenshot, template, device_id):\r\n-        \"\"\"HSVマッチングテスト\"\"\"\r\n-        try:\r\n-            hsv_screenshot = cv2.cvtColor(screenshot, cv2.COLOR_BGR2HSV)\r\n-            hsv_template = cv2.cvtColor(template, cv2.COLOR_BGR2HSV)\r\n-            \r\n-            result = cv2.matchTemplate(hsv_screenshot, hsv_template, cv2.TM_CCOEFF_NORMED)\r\n-            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-            \r\n-            if max_val >= 0.25:\r\n-                h, w = hsv_template.shape[:2]\r\n-                center_x, center_y = max_loc[0] + w // 2, max_loc[1] + h // 2\r\n-                return f\"(HSV色空間, 信頼度: {max_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n-        except:\r\n-            pass\r\n-        return None\r\n-    \r\n-    def test_brightness_matching(self, screenshot, template, device_id):\r\n-        \"\"\"明度調整マッチングテスト\"\"\"\r\n-        brightness_values = [1.2, 0.8, 1.5, 0.6, 1.8, 0.4]\r\n-        for brightness in brightness_values:\r\n-            try:\r\n-                adjusted_screenshot = cv2.convertScaleAbs(screenshot, alpha=brightness, beta=0)\r\n-                result = cv2.matchTemplate(adjusted_screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n-                min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n-                \r\n-                if max_val >= 0.3:\r\n-                    h, w = template.shape[:2]\r\n-                    center_x, center_y = max_loc[0] + w // 2, max_loc[1] + h // 2\r\n-                    return f\"(明度: {brightness:.1f}, 信頼度: {max_val:.3f}, 位置: ({center_x}, {center_y}))\"\r\n-            except:\r\n-                continue\r\n-        return None\r\n+    def __init__(self):\r\n+        super().__init__()\r\n+        \r\n+    def emit(self, record):\r\n+        msg = self.format(record)\r\n+        self.log_signal.emit(msg)\r\n \r\n+\r\n def main():\r\n-    root = tk.Tk()\r\n-    app = PuniPuniAutoPlayer(root)\r\n+    app = QApplication(sys.argv)\r\n+    app.setQuitOnLastWindowClosed(False)  # トレイアイコンのため\r\n     \r\n-    def on_closing():\r\n-        if app.running:\r\n-            app.stop_automation()\r\n-        if app.realtime_monitoring:\r\n-            app.realtime_monitoring = False\r\n-        root.destroy()\r\n+    # アプリケーション情報\r\n+    app.setApplicationName(\"妖怪ウォッチぷにぷに自動周回ツール\")\r\n+    app.setApplicationVersion(\"1.0.0\")\r\n     \r\n-    root.protocol(\"WM_DELETE_WINDOW\", on_closing)\r\n-    root.mainloop()\r\n+    # ダークテーマの設定\r\n+    app.setStyle(\"Fusion\")\r\n+    palette = QPalette()\r\n+    palette.setColor(QPalette.Window, QColor(53, 53, 53))\r\n+    palette.setColor(QPalette.WindowText, Qt.white)\r\n+    palette.setColor(QPalette.Base, QColor(25, 25, 25))\r\n+    palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))\r\n+    palette.setColor(QPalette.ToolTipBase, Qt.white)\r\n+    palette.setColor(QPalette.ToolTipText, Qt.white)\r\n+    palette.setColor(QPalette.Text, Qt.white)\r\n+    palette.setColor(QPalette.Button, QColor(53, 53, 53))\r\n+    palette.setColor(QPalette.ButtonText, Qt.white)\r\n+    palette.setColor(QPalette.BrightText, Qt.red)\r\n+    palette.setColor(QPalette.Link, QColor(42, 130, 218))\r\n+    palette.setColor(QPalette.Highlight, QColor(42, 130, 218))\r\n+    palette.setColor(QPalette.HighlightedText, Qt.black)\r\n+    app.setPalette(palette)\r\n+    \r\n+    # メインウィンドウ\r\n+    window = MainWindow()\r\n+    window.show()\r\n+    \r\n+    sys.exit(app.exec_())\r\n \r\n+\r\n if __name__ == \"__main__\":\r\n     main()\r\n"
                },
                {
                    "date": 1750495922601,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n                            QSpinBox, QDoubleSpinBox, QCheckBox, QGroupBox, QTabWidget,\r\n                            QTableWidget, QTableWidgetItem, QHeaderView, QProgressBar,\r\n                            QSplitter, QFrame, QGridLayout, QMessageBox, QSystemTrayIcon,\r\n                            QMenu, QAction)\r\n-from PyQt5.QtCore import QThread, pyqtSignal, QTimer, Qt, QSize\r\n+from PyQt5.QtCore import QThread, pyqtSignal, QTimer, Qt, QSize, QObject\r\n from PyQt5.QtGui import QIcon, QFont, QPalette, QColor, QPixmap\r\n \r\n from automation_engine import AutomationEngine\r\n from config_manager import ConfigManager, setup_logging\r\n@@ -393,16 +393,16 @@\n         self.stop_button.setEnabled(False)\r\n         \r\n         control_panel.addWidget(self.start_button)\r\n         control_panel.addWidget(self.stop_button)\r\n-        \r\n-        # ログ表示\r\n+          # ログ表示\r\n         log_group = QGroupBox(\"ログ\")\r\n         log_layout = QVBoxLayout()\r\n         \r\n         self.log_text = QTextEdit()\r\n         self.log_text.setReadOnly(True)\r\n-        self.log_text.setMaximumBlockCount(1000)  # 最大1000行\r\n+        # 最大行数の制限はQTextEditにはないため、コメントアウト\r\n+        # self.log_text.setMaximumBlockCount(1000)  # 最大1000行\r\n         log_layout.addWidget(self.log_text)\r\n         \r\n         log_group.setLayout(log_layout)\r\n         control_panel.addWidget(log_group)\r\n@@ -544,15 +544,16 @@\n         \r\n         QApplication.quit()\r\n \r\n \r\n-class LogHandler(logging.Handler):\r\n+class LogHandler(logging.Handler, QObject):\r\n     \"\"\"ログをGUIに表示するためのハンドラー\"\"\"\r\n     \r\n     log_signal = pyqtSignal(str)\r\n     \r\n     def __init__(self):\r\n-        super().__init__()\r\n+        logging.Handler.__init__(self)\r\n+        QObject.__init__(self)\r\n         \r\n     def emit(self, record):\r\n         msg = self.format(record)\r\n         self.log_signal.emit(msg)\r\n"
                },
                {
                    "date": 1750496229539,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,17 @@\n         if self.automation_engine.is_running:\r\n             self.automation_engine.stop_automation()\r\n         \r\n         if self.loop and self.loop.is_running():\r\n-            self.loop.call_soon_threadsafe(self.loop.stop)\r\n+            # より安全な停止処理\r\n+            try:\r\n+                self.loop.call_soon_threadsafe(self.loop.stop)\r\n+                # ループが停止するまで少し待つ\r\n+                import time\r\n+                time.sleep(0.1)\r\n+            except RuntimeError:\r\n+                # イベントループが既に閉じられている場合\r\n+                pass\r\n \r\n \r\n class DeviceManagementWidget(QWidget):\r\n     \"\"\"デバイス管理ウィジェット\"\"\"\r\n@@ -380,10 +388,9 @@\n         main_layout = QHBoxLayout()\r\n         \r\n         # 左側：制御パネル\r\n         control_panel = QVBoxLayout()\r\n-        \r\n-        # 開始/停止ボタン\r\n+          # 開始/停止ボタン\r\n         self.start_button = QPushButton(\"自動化開始\")\r\n         self.start_button.setStyleSheet(\"QPushButton { background-color: #4CAF50; color: white; font-size: 14px; padding: 10px; }\")\r\n         self.start_button.clicked.connect(self.start_automation)\r\n         \r\n@@ -393,9 +400,10 @@\n         self.stop_button.setEnabled(False)\r\n         \r\n         control_panel.addWidget(self.start_button)\r\n         control_panel.addWidget(self.stop_button)\r\n-          # ログ表示\r\n+        \r\n+        # ログ表示\r\n         log_group = QGroupBox(\"ログ\")\r\n         log_layout = QVBoxLayout()\r\n         \r\n         self.log_text = QTextEdit()\r\n"
                },
                {
                    "date": 1750499271592,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,26 +36,46 @@\n             self.loop.run_until_complete(self.automation_engine.start_automation())\r\n         except Exception as e:\r\n             self.error_signal.emit(f\"自動化エラー: {str(e)}\")\r\n         finally:\r\n-            if self.loop:\r\n-                self.loop.close()\r\n+            self._cleanup_loop()\r\n     \r\n     def stop(self):\r\n         \"\"\"ワーカースレッドを停止\"\"\"\r\n         if self.automation_engine.is_running:\r\n             self.automation_engine.stop_automation()\r\n         \r\n-        if self.loop and self.loop.is_running():\r\n-            # より安全な停止処理\r\n+        # 停止要求をイベントループに送信\r\n+        if self.loop and not self.loop.is_closed():\r\n             try:\r\n-                self.loop.call_soon_threadsafe(self.loop.stop)\r\n-                # ループが停止するまで少し待つ\r\n-                import time\r\n-                time.sleep(0.1)\r\n-            except RuntimeError:\r\n-                # イベントループが既に閉じられている場合\r\n+                if self.loop.is_running():\r\n+                    self.loop.call_soon_threadsafe(self.loop.stop)\r\n+            except (RuntimeError, AttributeError):\r\n                 pass\r\n+    \r\n+    def _cleanup_loop(self):\r\n+        \"\"\"イベントループの安全なクリーンアップ\"\"\"\r\n+        if self.loop and not self.loop.is_closed():\r\n+            try:\r\n+                # 実行中のタスクをキャンセル\r\n+                pending_tasks = [task for task in asyncio.all_tasks(self.loop) if not task.done()]\r\n+                if pending_tasks:\r\n+                    for task in pending_tasks:\r\n+                        task.cancel()\r\n+                    \r\n+                    # キャンセルされたタスクの完了を待つ\r\n+                    try:\r\n+                        self.loop.run_until_complete(asyncio.gather(*pending_tasks, return_exceptions=True))\r\n+                    except:\r\n+                        pass\r\n+                \r\n+                self.loop.close()\r\n+            except Exception:\r\n+                # エラーが発生しても無視してループを閉じる\r\n+                try:\r\n+                    self.loop.close()\r\n+                except:\r\n+                    pass\r\n \r\n \r\n class DeviceManagementWidget(QWidget):\r\n     \"\"\"デバイス管理ウィジェット\"\"\"\r\n@@ -505,9 +525,17 @@\n     def stop_automation(self):\r\n         \"\"\"自動化を停止\"\"\"\r\n         if self.automation_worker:\r\n             self.automation_worker.stop()\r\n-            self.automation_worker.wait()\r\n+            \r\n+            # 最大5秒間待機\r\n+            if not self.automation_worker.wait(5000):  # 5秒（ミリ秒）\r\n+                self.append_log(\"警告: ワーカースレッドの停止に時間がかかっています\")\r\n+                # 強制終了を試行\r\n+                if self.automation_worker.isRunning():\r\n+                    self.automation_worker.terminate()\r\n+                    self.automation_worker.wait(2000)  # さらに2秒待機\r\n+            \r\n             self.automation_worker = None\r\n         \r\n         self.start_button.setEnabled(True)\r\n         self.stop_button.setEnabled(False)\r\n"
                },
                {
                    "date": 1750499362905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,46 +36,26 @@\n             self.loop.run_until_complete(self.automation_engine.start_automation())\r\n         except Exception as e:\r\n             self.error_signal.emit(f\"自動化エラー: {str(e)}\")\r\n         finally:\r\n-            self._cleanup_loop()\r\n+            if self.loop:\r\n+                self.loop.close()\r\n     \r\n     def stop(self):\r\n         \"\"\"ワーカースレッドを停止\"\"\"\r\n         if self.automation_engine.is_running:\r\n             self.automation_engine.stop_automation()\r\n         \r\n-        # 停止要求をイベントループに送信\r\n-        if self.loop and not self.loop.is_closed():\r\n+        if self.loop and self.loop.is_running():\r\n+            # より安全な停止処理\r\n             try:\r\n-                if self.loop.is_running():\r\n-                    self.loop.call_soon_threadsafe(self.loop.stop)\r\n-            except (RuntimeError, AttributeError):\r\n+                self.loop.call_soon_threadsafe(self.loop.stop)\r\n+                # ループが停止するまで少し待つ\r\n+                import time\r\n+                time.sleep(0.1)\r\n+            except RuntimeError:\r\n+                # イベントループが既に閉じられている場合\r\n                 pass\r\n-    \r\n-    def _cleanup_loop(self):\r\n-        \"\"\"イベントループの安全なクリーンアップ\"\"\"\r\n-        if self.loop and not self.loop.is_closed():\r\n-            try:\r\n-                # 実行中のタスクをキャンセル\r\n-                pending_tasks = [task for task in asyncio.all_tasks(self.loop) if not task.done()]\r\n-                if pending_tasks:\r\n-                    for task in pending_tasks:\r\n-                        task.cancel()\r\n-                    \r\n-                    # キャンセルされたタスクの完了を待つ\r\n-                    try:\r\n-                        self.loop.run_until_complete(asyncio.gather(*pending_tasks, return_exceptions=True))\r\n-                    except:\r\n-                        pass\r\n-                \r\n-                self.loop.close()\r\n-            except Exception:\r\n-                # エラーが発生しても無視してループを閉じる\r\n-                try:\r\n-                    self.loop.close()\r\n-                except:\r\n-                    pass\r\n \r\n \r\n class DeviceManagementWidget(QWidget):\r\n     \"\"\"デバイス管理ウィジェット\"\"\"\r\n@@ -525,17 +505,9 @@\n     def stop_automation(self):\r\n         \"\"\"自動化を停止\"\"\"\r\n         if self.automation_worker:\r\n             self.automation_worker.stop()\r\n-            \r\n-            # 最大5秒間待機\r\n-            if not self.automation_worker.wait(5000):  # 5秒（ミリ秒）\r\n-                self.append_log(\"警告: ワーカースレッドの停止に時間がかかっています\")\r\n-                # 強制終了を試行\r\n-                if self.automation_worker.isRunning():\r\n-                    self.automation_worker.terminate()\r\n-                    self.automation_worker.wait(2000)  # さらに2秒待機\r\n-            \r\n+            self.automation_worker.wait()\r\n             self.automation_worker = None\r\n         \r\n         self.start_button.setEnabled(True)\r\n         self.stop_button.setEnabled(False)\r\n"
                },
                {
                    "date": 1750499552923,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,19 +43,9 @@\n     def stop(self):\r\n         \"\"\"ワーカースレッドを停止\"\"\"\r\n         if self.automation_engine.is_running:\r\n             self.automation_engine.stop_automation()\r\n-        \r\n-        if self.loop and self.loop.is_running():\r\n-            # より安全な停止処理\r\n-            try:\r\n-                self.loop.call_soon_threadsafe(self.loop.stop)\r\n-                # ループが停止するまで少し待つ\r\n-                import time\r\n-                time.sleep(0.1)\r\n-            except RuntimeError:\r\n-                # イベントループが既に閉じられている場合\r\n-                pass\r\n+        # ループ停止は自然に任せる（loop.stop()は呼ばない）\r\n \r\n \r\n class DeviceManagementWidget(QWidget):\r\n     \"\"\"デバイス管理ウィジェット\"\"\"\r\n"
                },
                {
                    "date": 1750500363611,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n import sys\r\n import asyncio\r\n import logging\r\n+import os\r\n from typing import List, Dict\r\n from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, \r\n                            QHBoxLayout, QLabel, QPushButton, QTextEdit, QComboBox,\r\n                            QSpinBox, QDoubleSpinBox, QCheckBox, QGroupBox, QTabWidget,\r\n@@ -196,9 +197,17 @@\n         detection_layout.addWidget(self.error_spin, 3, 1)\r\n         \r\n         detection_group.setLayout(detection_layout)\r\n         layout.addWidget(detection_group)\r\n-        \r\n+\r\n+        # --- 画像ごとの閾値設定テーブル ---\r\n+        self.threshold_table = QTableWidget()\r\n+        self.threshold_table.setColumnCount(2)\r\n+        self.threshold_table.setHorizontalHeaderLabels([\"画像ファイル\", \"閾値\"])\r\n+        self.threshold_table.horizontalHeader().setStretchLastSection(True)\r\n+        layout.addWidget(QLabel(\"画像ごとの検出閾値設定\"))\r\n+        layout.addWidget(self.threshold_table)\r\n+\r\n         # 保存ボタン\r\n         save_buttons = QHBoxLayout()\r\n         self.save_button = QPushButton(\"設定を保存\")\r\n         self.save_button.clicked.connect(self.save_settings)\r\n@@ -218,19 +227,39 @@\n         self.threshold_spin.setValue(settings['threshold'])\r\n         self.cooldown_spin.setValue(settings['tap_cooldown'])\r\n         self.capture_spin.setValue(settings['capture_interval'])\r\n         self.error_spin.setValue(settings['max_error_count'])\r\n-    \r\n+\r\n+        # 画像ごと閾値の読込\r\n+        image_dir = os.path.join(os.getcwd(), 'image')\r\n+        image_files = [f for f in os.listdir(image_dir) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]\r\n+        thresholds = self.config_manager.get_image_thresholds()\r\n+        self.threshold_table.setRowCount(len(image_files))\r\n+        for i, fname in enumerate(sorted(image_files)):\r\n+            self.threshold_table.setItem(i, 0, QTableWidgetItem(fname))\r\n+            spin = QDoubleSpinBox()\r\n+            spin.setRange(0.1, 1.0)\r\n+            spin.setSingleStep(0.01)\r\n+            spin.setDecimals(2)\r\n+            spin.setValue(thresholds.get(fname, settings['threshold']))\r\n+            self.threshold_table.setCellWidget(i, 1, spin)\r\n+\r\n     def save_settings(self):\r\n         \"\"\"設定を保存\"\"\"\r\n         settings = {\r\n             'threshold': self.threshold_spin.value(),\r\n             'tap_cooldown': self.cooldown_spin.value(),\r\n             'capture_interval': self.capture_spin.value(),\r\n             'max_error_count': self.error_spin.value()\r\n         }\r\n-        \r\n         self.config_manager.set_detection_settings(settings)\r\n+        # --- 画像ごと閾値保存 ---\r\n+        thresholds = {}\r\n+        for i in range(self.threshold_table.rowCount()):\r\n+            fname = self.threshold_table.item(i, 0).text()\r\n+            spin = self.threshold_table.cellWidget(i, 1)\r\n+            thresholds[fname] = spin.value()\r\n+        self.config_manager.set_image_thresholds(thresholds)\r\n         \r\n         # エンジンに設定を適用\r\n         self.automation_engine.set_detection_threshold(settings['threshold'])\r\n         self.automation_engine.set_tap_cooldown(settings['tap_cooldown'])\r\n"
                },
                {
                    "date": 1750503562594,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,14 +198,14 @@\n         \r\n         detection_group.setLayout(detection_layout)\r\n         layout.addWidget(detection_group)\r\n \r\n-        # --- 画像ごとの閾値設定テーブル ---\r\n+        # --- 画像ごとの閾値・ランダム幅設定テーブル ---\r\n         self.threshold_table = QTableWidget()\r\n-        self.threshold_table.setColumnCount(2)\r\n-        self.threshold_table.setHorizontalHeaderLabels([\"画像ファイル\", \"閾値\"])\r\n+        self.threshold_table.setColumnCount(3)\r\n+        self.threshold_table.setHorizontalHeaderLabels([\"画像ファイル\", \"閾値\", \"ランダム幅(px)\"])\r\n         self.threshold_table.horizontalHeader().setStretchLastSection(True)\r\n-        layout.addWidget(QLabel(\"画像ごとの検出閾値設定\"))\r\n+        layout.addWidget(QLabel(\"画像ごとの検出閾値・ランダムタップ幅設定\"))\r\n         layout.addWidget(self.threshold_table)\r\n \r\n         # 保存ボタン\r\n         save_buttons = QHBoxLayout()\r\n@@ -228,12 +228,13 @@\n         self.cooldown_spin.setValue(settings['tap_cooldown'])\r\n         self.capture_spin.setValue(settings['capture_interval'])\r\n         self.error_spin.setValue(settings['max_error_count'])\r\n \r\n-        # 画像ごと閾値の読込\r\n+        # 画像ごと閾値・ランダム幅の読込\r\n         image_dir = os.path.join(os.getcwd(), 'image')\r\n         image_files = [f for f in os.listdir(image_dir) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]\r\n         thresholds = self.config_manager.get_image_thresholds()\r\n+        random_ranges = self.config_manager.get_image_random_ranges()\r\n         self.threshold_table.setRowCount(len(image_files))\r\n         for i, fname in enumerate(sorted(image_files)):\r\n             self.threshold_table.setItem(i, 0, QTableWidgetItem(fname))\r\n             spin = QDoubleSpinBox()\r\n@@ -241,8 +242,12 @@\n             spin.setSingleStep(0.01)\r\n             spin.setDecimals(2)\r\n             spin.setValue(thresholds.get(fname, settings['threshold']))\r\n             self.threshold_table.setCellWidget(i, 1, spin)\r\n+            rand_spin = QSpinBox()\r\n+            rand_spin.setRange(0, 10)\r\n+            rand_spin.setValue(random_ranges.get(fname, 0))\r\n+            self.threshold_table.setCellWidget(i, 2, rand_spin)\r\n \r\n     def save_settings(self):\r\n         \"\"\"設定を保存\"\"\"\r\n         settings = {\r\n@@ -251,15 +256,19 @@\n             'capture_interval': self.capture_spin.value(),\r\n             'max_error_count': self.error_spin.value()\r\n         }\r\n         self.config_manager.set_detection_settings(settings)\r\n-        # --- 画像ごと閾値保存 ---\r\n+        # --- 画像ごと閾値・ランダム幅保存 ---\r\n         thresholds = {}\r\n+        random_ranges = {}\r\n         for i in range(self.threshold_table.rowCount()):\r\n             fname = self.threshold_table.item(i, 0).text()\r\n             spin = self.threshold_table.cellWidget(i, 1)\r\n             thresholds[fname] = spin.value()\r\n+            rand_spin = self.threshold_table.cellWidget(i, 2)\r\n+            random_ranges[fname] = rand_spin.value()\r\n         self.config_manager.set_image_thresholds(thresholds)\r\n+        self.config_manager.set_image_random_ranges(random_ranges)\r\n         \r\n         # エンジンに設定を適用\r\n         self.automation_engine.set_detection_threshold(settings['threshold'])\r\n         self.automation_engine.set_tap_cooldown(settings['tap_cooldown'])\r\n"
                },
                {
                    "date": 1750503616338,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -198,14 +198,14 @@\n         \r\n         detection_group.setLayout(detection_layout)\r\n         layout.addWidget(detection_group)\r\n \r\n-        # --- 画像ごとの閾値・ランダム幅設定テーブル ---\r\n+        # --- 画像ごとの閾値設定テーブル ---\r\n         self.threshold_table = QTableWidget()\r\n-        self.threshold_table.setColumnCount(3)\r\n-        self.threshold_table.setHorizontalHeaderLabels([\"画像ファイル\", \"閾値\", \"ランダム幅(px)\"])\r\n+        self.threshold_table.setColumnCount(2)\r\n+        self.threshold_table.setHorizontalHeaderLabels([\"画像ファイル\", \"閾値\"])\r\n         self.threshold_table.horizontalHeader().setStretchLastSection(True)\r\n-        layout.addWidget(QLabel(\"画像ごとの検出閾値・ランダムタップ幅設定\"))\r\n+        layout.addWidget(QLabel(\"画像ごとの検出閾値設定\"))\r\n         layout.addWidget(self.threshold_table)\r\n \r\n         # 保存ボタン\r\n         save_buttons = QHBoxLayout()\r\n@@ -228,13 +228,12 @@\n         self.cooldown_spin.setValue(settings['tap_cooldown'])\r\n         self.capture_spin.setValue(settings['capture_interval'])\r\n         self.error_spin.setValue(settings['max_error_count'])\r\n \r\n-        # 画像ごと閾値・ランダム幅の読込\r\n+        # 画像ごと閾値の読込\r\n         image_dir = os.path.join(os.getcwd(), 'image')\r\n         image_files = [f for f in os.listdir(image_dir) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]\r\n         thresholds = self.config_manager.get_image_thresholds()\r\n-        random_ranges = self.config_manager.get_image_random_ranges()\r\n         self.threshold_table.setRowCount(len(image_files))\r\n         for i, fname in enumerate(sorted(image_files)):\r\n             self.threshold_table.setItem(i, 0, QTableWidgetItem(fname))\r\n             spin = QDoubleSpinBox()\r\n@@ -242,12 +241,8 @@\n             spin.setSingleStep(0.01)\r\n             spin.setDecimals(2)\r\n             spin.setValue(thresholds.get(fname, settings['threshold']))\r\n             self.threshold_table.setCellWidget(i, 1, spin)\r\n-            rand_spin = QSpinBox()\r\n-            rand_spin.setRange(0, 10)\r\n-            rand_spin.setValue(random_ranges.get(fname, 0))\r\n-            self.threshold_table.setCellWidget(i, 2, rand_spin)\r\n \r\n     def save_settings(self):\r\n         \"\"\"設定を保存\"\"\"\r\n         settings = {\r\n@@ -256,19 +251,15 @@\n             'capture_interval': self.capture_spin.value(),\r\n             'max_error_count': self.error_spin.value()\r\n         }\r\n         self.config_manager.set_detection_settings(settings)\r\n-        # --- 画像ごと閾値・ランダム幅保存 ---\r\n+        # --- 画像ごと閾値保存 ---\r\n         thresholds = {}\r\n-        random_ranges = {}\r\n         for i in range(self.threshold_table.rowCount()):\r\n             fname = self.threshold_table.item(i, 0).text()\r\n             spin = self.threshold_table.cellWidget(i, 1)\r\n             thresholds[fname] = spin.value()\r\n-            rand_spin = self.threshold_table.cellWidget(i, 2)\r\n-            random_ranges[fname] = rand_spin.value()\r\n         self.config_manager.set_image_thresholds(thresholds)\r\n-        self.config_manager.set_image_random_ranges(random_ranges)\r\n         \r\n         # エンジンに設定を適用\r\n         self.automation_engine.set_detection_threshold(settings['threshold'])\r\n         self.automation_engine.set_tap_cooldown(settings['tap_cooldown'])\r\n"
                },
                {
                    "date": 1750503643358,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -206,8 +206,16 @@\n         self.threshold_table.horizontalHeader().setStretchLastSection(True)\r\n         layout.addWidget(QLabel(\"画像ごとの検出閾値設定\"))\r\n         layout.addWidget(self.threshold_table)\r\n \r\n+        # --- 画像ごとのランダムタップ設定テーブル ---\r\n+        self.random_table = QTableWidget()\r\n+        self.random_table.setColumnCount(3)\r\n+        self.random_table.setHorizontalHeaderLabels([\"画像ファイル\", \"Xランダム幅\", \"Yランダム幅\"])\r\n+        self.random_table.horizontalHeader().setStretchLastSection(True)\r\n+        layout.addWidget(QLabel(\"画像ごとのランダムタップ幅設定 (1~5ピクセル)\"))\r\n+        layout.addWidget(self.random_table)\r\n+\r\n         # 保存ボタン\r\n         save_buttons = QHBoxLayout()\r\n         self.save_button = QPushButton(\"設定を保存\")\r\n         self.save_button.clicked.connect(self.save_settings)\r\n@@ -242,8 +250,19 @@\n             spin.setDecimals(2)\r\n             spin.setValue(thresholds.get(fname, settings['threshold']))\r\n             self.threshold_table.setCellWidget(i, 1, spin)\r\n \r\n+        # 画像ごとランダムタップ幅の読込\r\n+        random_widths = self.config_manager.get_image_random_tap_widths()\r\n+        self.random_table.setRowCount(len(image_files))\r\n+        for i, fname in enumerate(sorted(image_files)):\r\n+            self.random_table.setItem(i, 0, QTableWidgetItem(fname))\r\n+            for j, axis in enumerate([\"x\", \"y\"]):\r\n+                spin = QSpinBox()\r\n+                spin.setRange(1, 5)\r\n+                spin.setValue(random_widths.get(fname, {}).get(axis, 1))\r\n+                self.random_table.setCellWidget(i, j+1, spin)\r\n+\r\n     def save_settings(self):\r\n         \"\"\"設定を保存\"\"\"\r\n         settings = {\r\n             'threshold': self.threshold_spin.value(),\r\n@@ -258,8 +277,17 @@\n             fname = self.threshold_table.item(i, 0).text()\r\n             spin = self.threshold_table.cellWidget(i, 1)\r\n             thresholds[fname] = spin.value()\r\n         self.config_manager.set_image_thresholds(thresholds)\r\n+        # --- 画像ごとランダムタップ幅保存 ---\r\n+        random_widths = {}\r\n+        for i in range(self.random_table.rowCount()):\r\n+            fname = self.random_table.item(i, 0).text()\r\n+            random_widths[fname] = {}\r\n+            for j, axis in enumerate([\"x\", \"y\"]):\r\n+                spin = self.random_table.cellWidget(i, j+1)\r\n+                random_widths[fname][axis] = spin.value()\r\n+        self.config_manager.set_image_random_tap_widths(random_widths)\r\n         \r\n         # エンジンに設定を適用\r\n         self.automation_engine.set_detection_threshold(settings['threshold'])\r\n         self.automation_engine.set_tap_cooldown(settings['tap_cooldown'])\r\n"
                },
                {
                    "date": 1750504167978,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -241,27 +241,28 @@\n         image_dir = os.path.join(os.getcwd(), 'image')\r\n         image_files = [f for f in os.listdir(image_dir) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]\r\n         thresholds = self.config_manager.get_image_thresholds()\r\n         self.threshold_table.setRowCount(len(image_files))\r\n+        self.random_table.setRowCount(len(image_files))\r\n+        random_settings = self.config_manager.get_image_random_settings() if hasattr(self.config_manager, 'get_image_random_settings') else {}\r\n         for i, fname in enumerate(sorted(image_files)):\r\n             self.threshold_table.setItem(i, 0, QTableWidgetItem(fname))\r\n             spin = QDoubleSpinBox()\r\n             spin.setRange(0.1, 1.0)\r\n             spin.setSingleStep(0.01)\r\n             spin.setDecimals(2)\r\n             spin.setValue(thresholds.get(fname, settings['threshold']))\r\n             self.threshold_table.setCellWidget(i, 1, spin)\r\n-\r\n-        # 画像ごとランダムタップ幅の読込\r\n-        random_widths = self.config_manager.get_image_random_tap_widths()\r\n-        self.random_table.setRowCount(len(image_files))\r\n-        for i, fname in enumerate(sorted(image_files)):\r\n+            # ランダム幅\r\n             self.random_table.setItem(i, 0, QTableWidgetItem(fname))\r\n-            for j, axis in enumerate([\"x\", \"y\"]):\r\n-                spin = QSpinBox()\r\n-                spin.setRange(1, 5)\r\n-                spin.setValue(random_widths.get(fname, {}).get(axis, 1))\r\n-                self.random_table.setCellWidget(i, j+1, spin)\r\n+            x_spin = QSpinBox()\r\n+            x_spin.setRange(0, 5)\r\n+            x_spin.setValue(random_settings.get(fname, (1, 1))[0] if fname in random_settings else 1)\r\n+            self.random_table.setCellWidget(i, 1, x_spin)\r\n+            y_spin = QSpinBox()\r\n+            y_spin.setRange(0, 5)\r\n+            y_spin.setValue(random_settings.get(fname, (1, 1))[1] if fname in random_settings else 1)\r\n+            self.random_table.setCellWidget(i, 2, y_spin)\r\n \r\n     def save_settings(self):\r\n         \"\"\"設定を保存\"\"\"\r\n         settings = {\r\n@@ -277,17 +278,17 @@\n             fname = self.threshold_table.item(i, 0).text()\r\n             spin = self.threshold_table.cellWidget(i, 1)\r\n             thresholds[fname] = spin.value()\r\n         self.config_manager.set_image_thresholds(thresholds)\r\n-        # --- 画像ごとランダムタップ幅保存 ---\r\n-        random_widths = {}\r\n+        # --- 画像ごとランダム幅保存 ---\r\n+        random_settings = {}\r\n         for i in range(self.random_table.rowCount()):\r\n             fname = self.random_table.item(i, 0).text()\r\n-            random_widths[fname] = {}\r\n-            for j, axis in enumerate([\"x\", \"y\"]):\r\n-                spin = self.random_table.cellWidget(i, j+1)\r\n-                random_widths[fname][axis] = spin.value()\r\n-        self.config_manager.set_image_random_tap_widths(random_widths)\r\n+            x_spin = self.random_table.cellWidget(i, 1)\r\n+            y_spin = self.random_table.cellWidget(i, 2)\r\n+            random_settings[fname] = (x_spin.value(), y_spin.value())\r\n+        if hasattr(self.config_manager, 'set_image_random_settings'):\r\n+            self.config_manager.set_image_random_settings(random_settings)\r\n         \r\n         # エンジンに設定を適用\r\n         self.automation_engine.set_detection_threshold(settings['threshold'])\r\n         self.automation_engine.set_tap_cooldown(settings['tap_cooldown'])\r\n"
                },
                {
                    "date": 1750504406774,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -178,17 +178,17 @@\n         detection_layout.addWidget(self.threshold_spin, 0, 1)\r\n         \r\n         detection_layout.addWidget(QLabel(\"タップ間隔(秒):\"), 1, 0)\r\n         self.cooldown_spin = QDoubleSpinBox()\r\n-        self.cooldown_spin.setRange(0.1, 5.0)\r\n-        self.cooldown_spin.setSingleStep(0.1)\r\n-        self.cooldown_spin.setDecimals(1)\r\n+        self.cooldown_spin.setRange(0.01, 5.0)\r\n+        self.cooldown_spin.setSingleStep(0.01)\r\n+        self.cooldown_spin.setDecimals(2)\r\n         detection_layout.addWidget(self.cooldown_spin, 1, 1)\r\n         \r\n         detection_layout.addWidget(QLabel(\"キャプチャ間隔(秒):\"), 2, 0)\r\n         self.capture_spin = QDoubleSpinBox()\r\n-        self.capture_spin.setRange(0.05, 1.0)\r\n-        self.capture_spin.setSingleStep(0.05)\r\n+        self.capture_spin.setRange(0.01, 1.0)\r\n+        self.capture_spin.setSingleStep(0.01)\r\n         self.capture_spin.setDecimals(2)\r\n         detection_layout.addWidget(self.capture_spin, 2, 1)\r\n         \r\n         detection_layout.addWidget(QLabel(\"最大エラー回数:\"), 3, 0)\r\n"
                },
                {
                    "date": 1750507056473,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -206,16 +206,8 @@\n         self.threshold_table.horizontalHeader().setStretchLastSection(True)\r\n         layout.addWidget(QLabel(\"画像ごとの検出閾値設定\"))\r\n         layout.addWidget(self.threshold_table)\r\n \r\n-        # --- 画像ごとのランダムタップ設定テーブル ---\r\n-        self.random_table = QTableWidget()\r\n-        self.random_table.setColumnCount(3)\r\n-        self.random_table.setHorizontalHeaderLabels([\"画像ファイル\", \"Xランダム幅\", \"Yランダム幅\"])\r\n-        self.random_table.horizontalHeader().setStretchLastSection(True)\r\n-        layout.addWidget(QLabel(\"画像ごとのランダムタップ幅設定 (1~5ピクセル)\"))\r\n-        layout.addWidget(self.random_table)\r\n-\r\n         # 保存ボタン\r\n         save_buttons = QHBoxLayout()\r\n         self.save_button = QPushButton(\"設定を保存\")\r\n         self.save_button.clicked.connect(self.save_settings)\r\n@@ -241,28 +233,16 @@\n         image_dir = os.path.join(os.getcwd(), 'image')\r\n         image_files = [f for f in os.listdir(image_dir) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]\r\n         thresholds = self.config_manager.get_image_thresholds()\r\n         self.threshold_table.setRowCount(len(image_files))\r\n-        self.random_table.setRowCount(len(image_files))\r\n-        random_settings = self.config_manager.get_image_random_settings() if hasattr(self.config_manager, 'get_image_random_settings') else {}\r\n         for i, fname in enumerate(sorted(image_files)):\r\n             self.threshold_table.setItem(i, 0, QTableWidgetItem(fname))\r\n             spin = QDoubleSpinBox()\r\n             spin.setRange(0.1, 1.0)\r\n             spin.setSingleStep(0.01)\r\n             spin.setDecimals(2)\r\n             spin.setValue(thresholds.get(fname, settings['threshold']))\r\n             self.threshold_table.setCellWidget(i, 1, spin)\r\n-            # ランダム幅\r\n-            self.random_table.setItem(i, 0, QTableWidgetItem(fname))\r\n-            x_spin = QSpinBox()\r\n-            x_spin.setRange(0, 5)\r\n-            x_spin.setValue(random_settings.get(fname, (1, 1))[0] if fname in random_settings else 1)\r\n-            self.random_table.setCellWidget(i, 1, x_spin)\r\n-            y_spin = QSpinBox()\r\n-            y_spin.setRange(0, 5)\r\n-            y_spin.setValue(random_settings.get(fname, (1, 1))[1] if fname in random_settings else 1)\r\n-            self.random_table.setCellWidget(i, 2, y_spin)\r\n \r\n     def save_settings(self):\r\n         \"\"\"設定を保存\"\"\"\r\n         settings = {\r\n@@ -278,17 +258,8 @@\n             fname = self.threshold_table.item(i, 0).text()\r\n             spin = self.threshold_table.cellWidget(i, 1)\r\n             thresholds[fname] = spin.value()\r\n         self.config_manager.set_image_thresholds(thresholds)\r\n-        # --- 画像ごとランダム幅保存 ---\r\n-        random_settings = {}\r\n-        for i in range(self.random_table.rowCount()):\r\n-            fname = self.random_table.item(i, 0).text()\r\n-            x_spin = self.random_table.cellWidget(i, 1)\r\n-            y_spin = self.random_table.cellWidget(i, 2)\r\n-            random_settings[fname] = (x_spin.value(), y_spin.value())\r\n-        if hasattr(self.config_manager, 'set_image_random_settings'):\r\n-            self.config_manager.set_image_random_settings(random_settings)\r\n         \r\n         # エンジンに設定を適用\r\n         self.automation_engine.set_detection_threshold(settings['threshold'])\r\n         self.automation_engine.set_tap_cooldown(settings['tap_cooldown'])\r\n"
                },
                {
                    "date": 1750511865581,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -206,8 +206,13 @@\n         self.threshold_table.horizontalHeader().setStretchLastSection(True)\r\n         layout.addWidget(QLabel(\"画像ごとの検出閾値設定\"))\r\n         layout.addWidget(self.threshold_table)\r\n \r\n+        # --- 全体閾値の注意ラベル ---\r\n+        self.global_threshold_label = QLabel(\"※画像ごとに閾値を設定した場合、下の全体閾値は無効になります\")\r\n+        self.global_threshold_label.setStyleSheet(\"color: orange; font-size: 11px;\")\r\n+        layout.addWidget(self.global_threshold_label)\r\n+\r\n         # 保存ボタン\r\n         save_buttons = QHBoxLayout()\r\n         self.save_button = QPushButton(\"設定を保存\")\r\n         self.save_button.clicked.connect(self.save_settings)\r\n"
                },
                {
                    "date": 1750511939658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -211,8 +211,11 @@\n         self.global_threshold_label = QLabel(\"※画像ごとに閾値を設定した場合、下の全体閾値は無効になります\")\r\n         self.global_threshold_label.setStyleSheet(\"color: orange; font-size: 11px;\")\r\n         layout.addWidget(self.global_threshold_label)\r\n \r\n+        # 全体閾値スピンボックスを保持\r\n+        self.global_threshold_spin = self.threshold_spin\r\n+\r\n         # 保存ボタン\r\n         save_buttons = QHBoxLayout()\r\n         self.save_button = QPushButton(\"設定を保存\")\r\n         self.save_button.clicked.connect(self.save_settings)\r\n@@ -227,9 +230,8 @@\n     \r\n     def load_settings(self):\r\n         \"\"\"設定を読み込み\"\"\"\r\n         settings = self.config_manager.get_detection_settings()\r\n-        \r\n         self.threshold_spin.setValue(settings['threshold'])\r\n         self.cooldown_spin.setValue(settings['tap_cooldown'])\r\n         self.capture_spin.setValue(settings['capture_interval'])\r\n         self.error_spin.setValue(settings['max_error_count'])\r\n@@ -238,16 +240,23 @@\n         image_dir = os.path.join(os.getcwd(), 'image')\r\n         image_files = [f for f in os.listdir(image_dir) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]\r\n         thresholds = self.config_manager.get_image_thresholds()\r\n         self.threshold_table.setRowCount(len(image_files))\r\n+        has_per_image = any(fname in thresholds for fname in image_files)\r\n         for i, fname in enumerate(sorted(image_files)):\r\n             self.threshold_table.setItem(i, 0, QTableWidgetItem(fname))\r\n             spin = QDoubleSpinBox()\r\n             spin.setRange(0.1, 1.0)\r\n             spin.setSingleStep(0.01)\r\n             spin.setDecimals(2)\r\n             spin.setValue(thresholds.get(fname, settings['threshold']))\r\n             self.threshold_table.setCellWidget(i, 1, spin)\r\n+        # 画像ごと閾値が1つでも設定されていれば全体閾値を無効化\r\n+        self.global_threshold_spin.setEnabled(not has_per_image)\r\n+        if has_per_image:\r\n+            self.global_threshold_label.setText(\"※画像ごとに閾値が設定されているため、下の全体閾値は無効です\")\r\n+        else:\r\n+            self.global_threshold_label.setText(\"※画像ごとに閾値を設定した場合、下の全体閾値は無効になります\")\r\n \r\n     def save_settings(self):\r\n         \"\"\"設定を保存\"\"\"\r\n         settings = {\r\n"
                },
                {
                    "date": 1750513814808,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -178,18 +178,18 @@\n         detection_layout.addWidget(self.threshold_spin, 0, 1)\r\n         \r\n         detection_layout.addWidget(QLabel(\"タップ間隔(秒):\"), 1, 0)\r\n         self.cooldown_spin = QDoubleSpinBox()\r\n-        self.cooldown_spin.setRange(0.01, 5.0)\r\n-        self.cooldown_spin.setSingleStep(0.01)\r\n-        self.cooldown_spin.setDecimals(2)\r\n+        self.cooldown_spin.setRange(0.005, 5.0)  # 最小値を0.005に\r\n+        self.cooldown_spin.setSingleStep(0.005)\r\n+        self.cooldown_spin.setDecimals(3)\r\n         detection_layout.addWidget(self.cooldown_spin, 1, 1)\r\n         \r\n         detection_layout.addWidget(QLabel(\"キャプチャ間隔(秒):\"), 2, 0)\r\n         self.capture_spin = QDoubleSpinBox()\r\n-        self.capture_spin.setRange(0.01, 1.0)\r\n-        self.capture_spin.setSingleStep(0.01)\r\n-        self.capture_spin.setDecimals(2)\r\n+        self.capture_spin.setRange(0.005, 1.0)  # 最小値を0.005に\r\n+        self.capture_spin.setSingleStep(0.005)\r\n+        self.capture_spin.setDecimals(3)\r\n         detection_layout.addWidget(self.capture_spin, 2, 1)\r\n         \r\n         detection_layout.addWidget(QLabel(\"最大エラー回数:\"), 3, 0)\r\n         self.error_spin = QSpinBox()\r\n"
                },
                {
                    "date": 1750514308243,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -256,8 +256,14 @@\n             self.global_threshold_label.setText(\"※画像ごとに閾値が設定されているため、下の全体閾値は無効です\")\r\n         else:\r\n             self.global_threshold_label.setText(\"※画像ごとに閾値を設定した場合、下の全体閾値は無効になります\")\r\n \r\n+        # 読み込み時にエンジンへ設定適用\r\n+        self.automation_engine.set_detection_threshold(settings['threshold'])\r\n+        self.automation_engine.set_tap_cooldown(settings['tap_cooldown'])\r\n+        self.automation_engine.set_capture_interval(settings['capture_interval'])\r\n+        self.automation_engine.max_error_count = settings['max_error_count']\r\n+\r\n     def save_settings(self):\r\n         \"\"\"設定を保存\"\"\"\r\n         settings = {\r\n             'threshold': self.threshold_spin.value(),\r\n"
                },
                {
                    "date": 1750514363956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -298,9 +298,9 @@\n         \r\n         # 統計更新タイマー\r\n         self.timer = QTimer()\r\n         self.timer.timeout.connect(self.update_statistics)\r\n-        self.timer.start(1000)  # 1秒ごとに更新\r\n+        self.timer.start(100)  # 0.1秒ごとに更新へ変更\r\n     \r\n     def init_ui(self):\r\n         layout = QVBoxLayout()\r\n         \r\n"
                },
                {
                    "date": 1750516446363,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,643 +0,0 @@\n-import sys\r\n-import asyncio\r\n-import logging\r\n-import os\r\n-from typing import List, Dict\r\n-from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, \r\n-                           QHBoxLayout, QLabel, QPushButton, QTextEdit, QComboBox,\r\n-                           QSpinBox, QDoubleSpinBox, QCheckBox, QGroupBox, QTabWidget,\r\n-                           QTableWidget, QTableWidgetItem, QHeaderView, QProgressBar,\r\n-                           QSplitter, QFrame, QGridLayout, QMessageBox, QSystemTrayIcon,\r\n-                           QMenu, QAction)\r\n-from PyQt5.QtCore import QThread, pyqtSignal, QTimer, Qt, QSize, QObject\r\n-from PyQt5.QtGui import QIcon, QFont, QPalette, QColor, QPixmap\r\n-\r\n-from automation_engine import AutomationEngine\r\n-from config_manager import ConfigManager, setup_logging\r\n-from device_controller import DeviceController\r\n-\r\n-\r\n-class AutomationWorker(QThread):\r\n-    \"\"\"自動化処理用ワーカースレッド\"\"\"\r\n-    \r\n-    log_signal = pyqtSignal(str)\r\n-    stats_signal = pyqtSignal(dict)\r\n-    error_signal = pyqtSignal(str)\r\n-    \r\n-    def __init__(self, automation_engine):\r\n-        super().__init__()\r\n-        self.automation_engine = automation_engine\r\n-        self.loop = None\r\n-        \r\n-    def run(self):\r\n-        \"\"\"ワーカースレッドのメインループ\"\"\"\r\n-        try:\r\n-            self.loop = asyncio.new_event_loop()\r\n-            asyncio.set_event_loop(self.loop)\r\n-            self.loop.run_until_complete(self.automation_engine.start_automation())\r\n-        except Exception as e:\r\n-            self.error_signal.emit(f\"自動化エラー: {str(e)}\")\r\n-        finally:\r\n-            if self.loop:\r\n-                self.loop.close()\r\n-    \r\n-    def stop(self):\r\n-        \"\"\"ワーカースレッドを停止\"\"\"\r\n-        if self.automation_engine.is_running:\r\n-            self.automation_engine.stop_automation()\r\n-        # ループ停止は自然に任せる（loop.stop()は呼ばない）\r\n-\r\n-\r\n-class DeviceManagementWidget(QWidget):\r\n-    \"\"\"デバイス管理ウィジェット\"\"\"\r\n-    \r\n-    def __init__(self, automation_engine):\r\n-        super().__init__()\r\n-        self.automation_engine = automation_engine\r\n-        self.init_ui()\r\n-        self.refresh_devices()\r\n-    \r\n-    def init_ui(self):\r\n-        layout = QVBoxLayout()\r\n-        \r\n-        # デバイス検出ボタン\r\n-        self.detect_button = QPushButton(\"デバイスを検出\")\r\n-        self.detect_button.clicked.connect(self.detect_devices)\r\n-        layout.addWidget(self.detect_button)\r\n-        \r\n-        # デバイス一覧テーブル\r\n-        self.device_table = QTableWidget()\r\n-        self.device_table.setColumnCount(4)\r\n-        self.device_table.setHorizontalHeaderLabels([\"デバイスID\", \"状態\", \"アクティブ\", \"操作\"])\r\n-        self.device_table.horizontalHeader().setStretchLastSection(True)\r\n-        layout.addWidget(self.device_table)\r\n-        \r\n-        # デバイス追加\r\n-        add_layout = QHBoxLayout()\r\n-        self.device_input = QComboBox()\r\n-        self.device_input.setEditable(True)\r\n-        self.add_button = QPushButton(\"追加\")\r\n-        self.add_button.clicked.connect(self.add_device)\r\n-        add_layout.addWidget(QLabel(\"デバイス:\"))\r\n-        add_layout.addWidget(self.device_input)\r\n-        add_layout.addWidget(self.add_button)\r\n-        layout.addLayout(add_layout)\r\n-        \r\n-        self.setLayout(layout)\r\n-    \r\n-    def detect_devices(self):\r\n-        \"\"\"デバイスを検出\"\"\"\r\n-        try:\r\n-            controller = DeviceController()\r\n-            devices = controller.get_connected_devices()\r\n-            \r\n-            self.device_input.clear()\r\n-            self.device_input.addItems(devices)\r\n-            \r\n-            if devices:\r\n-                QMessageBox.information(self, \"検出完了\", f\"{len(devices)}個のデバイスが見つかりました\")\r\n-            else:\r\n-                QMessageBox.warning(self, \"検出結果\", \"デバイスが見つかりませんでした\")\r\n-                \r\n-        except Exception as e:\r\n-            QMessageBox.critical(self, \"エラー\", f\"デバイス検出エラー: {str(e)}\")\r\n-    \r\n-    def add_device(self):\r\n-        \"\"\"デバイスを追加\"\"\"\r\n-        device_id = self.device_input.currentText().strip()\r\n-        if not device_id:\r\n-            return\r\n-        \r\n-        if self.automation_engine.add_device(device_id):\r\n-            self.refresh_devices()\r\n-            QMessageBox.information(self, \"成功\", f\"デバイス '{device_id}' を追加しました\")\r\n-        else:\r\n-            QMessageBox.warning(self, \"失敗\", f\"デバイス '{device_id}' の追加に失敗しました\")\r\n-    \r\n-    def remove_device(self, device_id):\r\n-        \"\"\"デバイスを削除\"\"\"\r\n-        self.automation_engine.remove_device(device_id)\r\n-        self.refresh_devices()\r\n-        QMessageBox.information(self, \"削除完了\", f\"デバイス '{device_id}' を削除しました\")\r\n-    \r\n-    def toggle_device_active(self, device_id, active):\r\n-        \"\"\"デバイスのアクティブ状態を切り替え\"\"\"\r\n-        self.automation_engine.set_device_active(device_id, active)\r\n-    \r\n-    def refresh_devices(self):\r\n-        \"\"\"デバイス一覧を更新\"\"\"\r\n-        devices = self.automation_engine.get_device_list()\r\n-        self.device_table.setRowCount(len(devices))\r\n-        \r\n-        for i, device_id in enumerate(devices):\r\n-            state = self.automation_engine.get_device_state(device_id)\r\n-            \r\n-            # デバイスID\r\n-            self.device_table.setItem(i, 0, QTableWidgetItem(device_id))\r\n-            \r\n-            # 状態\r\n-            status = state.current_state.value if state else \"不明\"\r\n-            self.device_table.setItem(i, 1, QTableWidgetItem(status))\r\n-            \r\n-            # アクティブチェックボックス\r\n-            active_checkbox = QCheckBox()\r\n-            active_checkbox.setChecked(state.is_active if state else False)\r\n-            active_checkbox.stateChanged.connect(\r\n-                lambda checked, dev_id=device_id: self.toggle_device_active(dev_id, checked == Qt.Checked)\r\n-            )\r\n-            self.device_table.setCellWidget(i, 2, active_checkbox)\r\n-            \r\n-            # 削除ボタン\r\n-            remove_button = QPushButton(\"削除\")\r\n-            remove_button.clicked.connect(lambda checked, dev_id=device_id: self.remove_device(dev_id))\r\n-            self.device_table.setCellWidget(i, 3, remove_button)\r\n-\r\n-\r\n-class SettingsWidget(QWidget):\r\n-    \"\"\"設定ウィジェット\"\"\"\r\n-    \r\n-    def __init__(self, automation_engine, config_manager):\r\n-        super().__init__()\r\n-        self.automation_engine = automation_engine\r\n-        self.config_manager = config_manager\r\n-        self.init_ui()\r\n-        self.load_settings()\r\n-    \r\n-    def init_ui(self):\r\n-        layout = QVBoxLayout()\r\n-        \r\n-        # 検出設定\r\n-        detection_group = QGroupBox(\"検出設定\")\r\n-        detection_layout = QGridLayout()\r\n-        \r\n-        detection_layout.addWidget(QLabel(\"検出閾値:\"), 0, 0)\r\n-        self.threshold_spin = QDoubleSpinBox()\r\n-        self.threshold_spin.setRange(0.1, 1.0)\r\n-        self.threshold_spin.setSingleStep(0.1)\r\n-        self.threshold_spin.setDecimals(1)\r\n-        detection_layout.addWidget(self.threshold_spin, 0, 1)\r\n-        \r\n-        detection_layout.addWidget(QLabel(\"タップ間隔(秒):\"), 1, 0)\r\n-        self.cooldown_spin = QDoubleSpinBox()\r\n-        self.cooldown_spin.setRange(0.005, 5.0)  # 最小値を0.005に\r\n-        self.cooldown_spin.setSingleStep(0.005)\r\n-        self.cooldown_spin.setDecimals(3)\r\n-        detection_layout.addWidget(self.cooldown_spin, 1, 1)\r\n-        \r\n-        detection_layout.addWidget(QLabel(\"キャプチャ間隔(秒):\"), 2, 0)\r\n-        self.capture_spin = QDoubleSpinBox()\r\n-        self.capture_spin.setRange(0.005, 1.0)  # 最小値を0.005に\r\n-        self.capture_spin.setSingleStep(0.005)\r\n-        self.capture_spin.setDecimals(3)\r\n-        detection_layout.addWidget(self.capture_spin, 2, 1)\r\n-        \r\n-        detection_layout.addWidget(QLabel(\"最大エラー回数:\"), 3, 0)\r\n-        self.error_spin = QSpinBox()\r\n-        self.error_spin.setRange(1, 20)\r\n-        detection_layout.addWidget(self.error_spin, 3, 1)\r\n-        \r\n-        detection_group.setLayout(detection_layout)\r\n-        layout.addWidget(detection_group)\r\n-\r\n-        # --- 画像ごとの閾値設定テーブル ---\r\n-        self.threshold_table = QTableWidget()\r\n-        self.threshold_table.setColumnCount(2)\r\n-        self.threshold_table.setHorizontalHeaderLabels([\"画像ファイル\", \"閾値\"])\r\n-        self.threshold_table.horizontalHeader().setStretchLastSection(True)\r\n-        layout.addWidget(QLabel(\"画像ごとの検出閾値設定\"))\r\n-        layout.addWidget(self.threshold_table)\r\n-\r\n-        # --- 全体閾値の注意ラベル ---\r\n-        self.global_threshold_label = QLabel(\"※画像ごとに閾値を設定した場合、下の全体閾値は無効になります\")\r\n-        self.global_threshold_label.setStyleSheet(\"color: orange; font-size: 11px;\")\r\n-        layout.addWidget(self.global_threshold_label)\r\n-\r\n-        # 全体閾値スピンボックスを保持\r\n-        self.global_threshold_spin = self.threshold_spin\r\n-\r\n-        # 保存ボタン\r\n-        save_buttons = QHBoxLayout()\r\n-        self.save_button = QPushButton(\"設定を保存\")\r\n-        self.save_button.clicked.connect(self.save_settings)\r\n-        self.reload_button = QPushButton(\"設定を再読込\")\r\n-        self.reload_button.clicked.connect(self.load_settings)\r\n-        save_buttons.addWidget(self.save_button)\r\n-        save_buttons.addWidget(self.reload_button)\r\n-        layout.addLayout(save_buttons)\r\n-        \r\n-        layout.addStretch()\r\n-        self.setLayout(layout)\r\n-    \r\n-    def load_settings(self):\r\n-        \"\"\"設定を読み込み\"\"\"\r\n-        settings = self.config_manager.get_detection_settings()\r\n-        self.threshold_spin.setValue(settings['threshold'])\r\n-        self.cooldown_spin.setValue(settings['tap_cooldown'])\r\n-        self.capture_spin.setValue(settings['capture_interval'])\r\n-        self.error_spin.setValue(settings['max_error_count'])\r\n-\r\n-        # 画像ごと閾値の読込\r\n-        image_dir = os.path.join(os.getcwd(), 'image')\r\n-        image_files = [f for f in os.listdir(image_dir) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]\r\n-        thresholds = self.config_manager.get_image_thresholds()\r\n-        self.threshold_table.setRowCount(len(image_files))\r\n-        has_per_image = any(fname in thresholds for fname in image_files)\r\n-        for i, fname in enumerate(sorted(image_files)):\r\n-            self.threshold_table.setItem(i, 0, QTableWidgetItem(fname))\r\n-            spin = QDoubleSpinBox()\r\n-            spin.setRange(0.1, 1.0)\r\n-            spin.setSingleStep(0.01)\r\n-            spin.setDecimals(2)\r\n-            spin.setValue(thresholds.get(fname, settings['threshold']))\r\n-            self.threshold_table.setCellWidget(i, 1, spin)\r\n-        # 画像ごと閾値が1つでも設定されていれば全体閾値を無効化\r\n-        self.global_threshold_spin.setEnabled(not has_per_image)\r\n-        if has_per_image:\r\n-            self.global_threshold_label.setText(\"※画像ごとに閾値が設定されているため、下の全体閾値は無効です\")\r\n-        else:\r\n-            self.global_threshold_label.setText(\"※画像ごとに閾値を設定した場合、下の全体閾値は無効になります\")\r\n-\r\n-        # 読み込み時にエンジンへ設定適用\r\n-        self.automation_engine.set_detection_threshold(settings['threshold'])\r\n-        self.automation_engine.set_tap_cooldown(settings['tap_cooldown'])\r\n-        self.automation_engine.set_capture_interval(settings['capture_interval'])\r\n-        self.automation_engine.max_error_count = settings['max_error_count']\r\n-\r\n-    def save_settings(self):\r\n-        \"\"\"設定を保存\"\"\"\r\n-        settings = {\r\n-            'threshold': self.threshold_spin.value(),\r\n-            'tap_cooldown': self.cooldown_spin.value(),\r\n-            'capture_interval': self.capture_spin.value(),\r\n-            'max_error_count': self.error_spin.value()\r\n-        }\r\n-        self.config_manager.set_detection_settings(settings)\r\n-        # --- 画像ごと閾値保存 ---\r\n-        thresholds = {}\r\n-        for i in range(self.threshold_table.rowCount()):\r\n-            fname = self.threshold_table.item(i, 0).text()\r\n-            spin = self.threshold_table.cellWidget(i, 1)\r\n-            thresholds[fname] = spin.value()\r\n-        self.config_manager.set_image_thresholds(thresholds)\r\n-        \r\n-        # エンジンに設定を適用\r\n-        self.automation_engine.set_detection_threshold(settings['threshold'])\r\n-        self.automation_engine.set_tap_cooldown(settings['tap_cooldown'])\r\n-        self.automation_engine.set_capture_interval(settings['capture_interval'])\r\n-        \r\n-        QMessageBox.information(self, \"保存完了\", \"設定を保存しました\")\r\n-\r\n-\r\n-class StatisticsWidget(QWidget):\r\n-    \"\"\"統計情報ウィジェット\"\"\"\r\n-    \r\n-    def __init__(self, automation_engine):\r\n-        super().__init__()\r\n-        self.automation_engine = automation_engine\r\n-        self.init_ui()\r\n-        \r\n-        # 統計更新タイマー\r\n-        self.timer = QTimer()\r\n-        self.timer.timeout.connect(self.update_statistics)\r\n-        self.timer.start(100)  # 0.1秒ごとに更新へ変更\r\n-    \r\n-    def init_ui(self):\r\n-        layout = QVBoxLayout()\r\n-        \r\n-        # 全体統計\r\n-        overall_group = QGroupBox(\"全体統計\")\r\n-        overall_layout = QGridLayout()\r\n-        \r\n-        self.total_loops_label = QLabel(\"0\")\r\n-        self.elapsed_time_label = QLabel(\"00:00:00\")\r\n-        self.loops_per_hour_label = QLabel(\"0.0\")\r\n-        self.active_devices_label = QLabel(\"0\")\r\n-        \r\n-        overall_layout.addWidget(QLabel(\"総ループ数:\"), 0, 0)\r\n-        overall_layout.addWidget(self.total_loops_label, 0, 1)\r\n-        overall_layout.addWidget(QLabel(\"経過時間:\"), 1, 0)\r\n-        overall_layout.addWidget(self.elapsed_time_label, 1, 1)\r\n-        overall_layout.addWidget(QLabel(\"時間あたりループ数:\"), 2, 0)\r\n-        overall_layout.addWidget(self.loops_per_hour_label, 2, 1)\r\n-        overall_layout.addWidget(QLabel(\"アクティブデバイス数:\"), 3, 0)\r\n-        overall_layout.addWidget(self.active_devices_label, 3, 1)\r\n-        \r\n-        overall_group.setLayout(overall_layout)\r\n-        layout.addWidget(overall_group)\r\n-        \r\n-        # デバイス別統計\r\n-        device_group = QGroupBox(\"デバイス別統計\")\r\n-        device_layout = QVBoxLayout()\r\n-        \r\n-        self.device_stats_table = QTableWidget()\r\n-        self.device_stats_table.setColumnCount(5)\r\n-        self.device_stats_table.setHorizontalHeaderLabels(\r\n-            [\"デバイスID\", \"状態\", \"タップ数\", \"エラー数\", \"最終動作時刻\"]\r\n-        )\r\n-        self.device_stats_table.horizontalHeader().setStretchLastSection(True)\r\n-        device_layout.addWidget(self.device_stats_table)\r\n-        \r\n-        device_group.setLayout(device_layout)\r\n-        layout.addWidget(device_group)\r\n-        \r\n-        # リセットボタン\r\n-        reset_button = QPushButton(\"統計をリセット\")\r\n-        reset_button.clicked.connect(self.reset_statistics)\r\n-        layout.addWidget(reset_button)\r\n-        \r\n-        self.setLayout(layout)\r\n-    \r\n-    def update_statistics(self):\r\n-        \"\"\"統計情報を更新\"\"\"\r\n-        try:\r\n-            stats = self.automation_engine.get_statistics()\r\n-            \r\n-            # 全体統計\r\n-            self.total_loops_label.setText(str(stats['total_loops']))\r\n-            \r\n-            # 経過時間をフォーマット\r\n-            elapsed = int(stats['elapsed_time'])\r\n-            hours = elapsed // 3600\r\n-            minutes = (elapsed % 3600) // 60\r\n-            seconds = elapsed % 60\r\n-            self.elapsed_time_label.setText(f\"{hours:02d}:{minutes:02d}:{seconds:02d}\")\r\n-            \r\n-            self.loops_per_hour_label.setText(f\"{stats['loops_per_hour']:.1f}\")\r\n-            self.active_devices_label.setText(f\"{stats['active_devices']}/{stats['total_devices']}\")\r\n-            \r\n-            # デバイス別統計\r\n-            device_details = stats['device_details']\r\n-            self.device_stats_table.setRowCount(len(device_details))\r\n-            \r\n-            for i, (device_id, details) in enumerate(device_details.items()):\r\n-                self.device_stats_table.setItem(i, 0, QTableWidgetItem(device_id))\r\n-                self.device_stats_table.setItem(i, 1, QTableWidgetItem(details['state']))\r\n-                self.device_stats_table.setItem(i, 2, QTableWidgetItem(str(details['tap_count'])))\r\n-                self.device_stats_table.setItem(i, 3, QTableWidgetItem(str(details['error_count'])))\r\n-                \r\n-                # 最終動作時刻\r\n-                import datetime\r\n-                if details['last_action_time'] > 0:\r\n-                    last_time = datetime.datetime.fromtimestamp(details['last_action_time'])\r\n-                    time_str = last_time.strftime(\"%H:%M:%S\")\r\n-                else:\r\n-                    time_str = \"未実行\"\r\n-                self.device_stats_table.setItem(i, 4, QTableWidgetItem(time_str))\r\n-                \r\n-        except Exception as e:\r\n-            logging.error(f\"統計更新エラー: {e}\")\r\n-    \r\n-    def reset_statistics(self):\r\n-        \"\"\"統計をリセット\"\"\"\r\n-        reply = QMessageBox.question(self, \"確認\", \"統計情報をリセットしますか？\",\r\n-                                   QMessageBox.Yes | QMessageBox.No)\r\n-        if reply == QMessageBox.Yes:\r\n-            self.automation_engine.reset_statistics()\r\n-\r\n-\r\n-class MainWindow(QMainWindow):\r\n-    \"\"\"メインウィンドウ\"\"\"\r\n-    \r\n-    def __init__(self):\r\n-        super().__init__()\r\n-        self.config_manager = ConfigManager()\r\n-        setup_logging(self.config_manager)\r\n-        \r\n-        self.automation_engine = AutomationEngine()\r\n-        self.automation_worker = None\r\n-        \r\n-        self.init_ui()\r\n-        self.init_tray()\r\n-        self.load_gui_settings()\r\n-        \r\n-        # ログハンドラーを追加\r\n-        self.log_handler = LogHandler()\r\n-        self.log_handler.log_signal.connect(self.append_log)\r\n-        logging.getLogger().addHandler(self.log_handler)\r\n-    \r\n-    def init_ui(self):\r\n-        self.setWindowTitle(\"妖怪ウォッチぷにぷに 自動周回ツール\")\r\n-        self.setMinimumSize(800, 600)\r\n-        \r\n-        # 中央ウィジェット\r\n-        central_widget = QWidget()\r\n-        self.setCentralWidget(central_widget)\r\n-        \r\n-        # メインレイアウト\r\n-        main_layout = QHBoxLayout()\r\n-        \r\n-        # 左側：制御パネル\r\n-        control_panel = QVBoxLayout()\r\n-          # 開始/停止ボタン\r\n-        self.start_button = QPushButton(\"自動化開始\")\r\n-        self.start_button.setStyleSheet(\"QPushButton { background-color: #4CAF50; color: white; font-size: 14px; padding: 10px; }\")\r\n-        self.start_button.clicked.connect(self.start_automation)\r\n-        \r\n-        self.stop_button = QPushButton(\"自動化停止\")\r\n-        self.stop_button.setStyleSheet(\"QPushButton { background-color: #f44336; color: white; font-size: 14px; padding: 10px; }\")\r\n-        self.stop_button.clicked.connect(self.stop_automation)\r\n-        self.stop_button.setEnabled(False)\r\n-        \r\n-        control_panel.addWidget(self.start_button)\r\n-        control_panel.addWidget(self.stop_button)\r\n-        \r\n-        # ログ表示\r\n-        log_group = QGroupBox(\"ログ\")\r\n-        log_layout = QVBoxLayout()\r\n-        \r\n-        self.log_text = QTextEdit()\r\n-        self.log_text.setReadOnly(True)\r\n-        # 最大行数の制限はQTextEditにはないため、コメントアウト\r\n-        # self.log_text.setMaximumBlockCount(1000)  # 最大1000行\r\n-        log_layout.addWidget(self.log_text)\r\n-        \r\n-        log_group.setLayout(log_layout)\r\n-        control_panel.addWidget(log_group)\r\n-        \r\n-        # 右側：タブウィジェット\r\n-        self.tab_widget = QTabWidget()\r\n-        \r\n-        # デバイス管理タブ\r\n-        self.device_widget = DeviceManagementWidget(self.automation_engine)\r\n-        self.tab_widget.addTab(self.device_widget, \"デバイス管理\")\r\n-        \r\n-        # 設定タブ\r\n-        self.settings_widget = SettingsWidget(self.automation_engine, self.config_manager)\r\n-        self.tab_widget.addTab(self.settings_widget, \"設定\")\r\n-        \r\n-        # 統計タブ\r\n-        self.stats_widget = StatisticsWidget(self.automation_engine)\r\n-        self.tab_widget.addTab(self.stats_widget, \"統計\")\r\n-        \r\n-        # レイアウト配置\r\n-        left_widget = QWidget()\r\n-        left_widget.setLayout(control_panel)\r\n-        left_widget.setMaximumWidth(400)\r\n-        \r\n-        main_layout.addWidget(left_widget)\r\n-        main_layout.addWidget(self.tab_widget)\r\n-        \r\n-        central_widget.setLayout(main_layout)\r\n-        \r\n-        # ステータスバー\r\n-        self.statusBar().showMessage(\"準備完了\")\r\n-    \r\n-    def init_tray(self):\r\n-        \"\"\"システムトレイを初期化\"\"\"\r\n-        self.tray_icon = QSystemTrayIcon(self)\r\n-        \r\n-        # トレイメニュー\r\n-        tray_menu = QMenu()\r\n-        \r\n-        show_action = QAction(\"表示\", self)\r\n-        show_action.triggered.connect(self.show)\r\n-        tray_menu.addAction(show_action)\r\n-        \r\n-        hide_action = QAction(\"非表示\", self)\r\n-        hide_action.triggered.connect(self.hide)\r\n-        tray_menu.addAction(hide_action)\r\n-        \r\n-        tray_menu.addSeparator()\r\n-        \r\n-        quit_action = QAction(\"終了\", self)\r\n-        quit_action.triggered.connect(self.quit_application)\r\n-        tray_menu.addAction(quit_action)\r\n-        \r\n-        self.tray_icon.setContextMenu(tray_menu)\r\n-        self.tray_icon.activated.connect(self.tray_icon_activated)\r\n-        \r\n-        # アイコンを設定（デフォルトアイコン）\r\n-        self.tray_icon.setIcon(self.style().standardIcon(self.style().SP_ComputerIcon))\r\n-        self.tray_icon.show()\r\n-    \r\n-    def tray_icon_activated(self, reason):\r\n-        \"\"\"トレイアイコンがクリックされた時の処理\"\"\"\r\n-        if reason == QSystemTrayIcon.DoubleClick:\r\n-            self.show()\r\n-    \r\n-    def load_gui_settings(self):\r\n-        \"\"\"GUI設定を読み込み\"\"\"\r\n-        gui_settings = self.config_manager.get_gui_settings()\r\n-        \r\n-        self.resize(gui_settings['window_width'], gui_settings['window_height'])\r\n-        \r\n-        if gui_settings['always_on_top']:\r\n-            self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)\r\n-    \r\n-    def start_automation(self):\r\n-        \"\"\"自動化を開始\"\"\"\r\n-        if not self.automation_engine.get_device_list():\r\n-            QMessageBox.warning(self, \"警告\", \"デバイスが登録されていません\")\r\n-            return\r\n-        \r\n-        self.automation_worker = AutomationWorker(self.automation_engine)\r\n-        self.automation_worker.log_signal.connect(self.append_log)\r\n-        self.automation_worker.error_signal.connect(self.show_error)\r\n-        self.automation_worker.start()\r\n-        \r\n-        self.start_button.setEnabled(False)\r\n-        self.stop_button.setEnabled(True)\r\n-        self.statusBar().showMessage(\"自動化実行中...\")\r\n-        \r\n-        self.append_log(\"自動化を開始しました\")\r\n-    \r\n-    def stop_automation(self):\r\n-        \"\"\"自動化を停止\"\"\"\r\n-        if self.automation_worker:\r\n-            self.automation_worker.stop()\r\n-            self.automation_worker.wait()\r\n-            self.automation_worker = None\r\n-        \r\n-        self.start_button.setEnabled(True)\r\n-        self.stop_button.setEnabled(False)\r\n-        self.statusBar().showMessage(\"自動化停止\")\r\n-        \r\n-        self.append_log(\"自動化を停止しました\")\r\n-    \r\n-    def append_log(self, message):\r\n-        \"\"\"ログを追加\"\"\"\r\n-        import datetime\r\n-        timestamp = datetime.datetime.now().strftime(\"%H:%M:%S\")\r\n-        self.log_text.append(f\"[{timestamp}] {message}\")\r\n-    \r\n-    def show_error(self, message):\r\n-        \"\"\"エラーを表示\"\"\"\r\n-        QMessageBox.critical(self, \"エラー\", message)\r\n-        self.append_log(f\"エラー: {message}\")\r\n-    \r\n-    def closeEvent(self, event):\r\n-        \"\"\"ウィンドウを閉じる時の処理\"\"\"\r\n-        gui_settings = self.config_manager.get_gui_settings()\r\n-        \r\n-        if gui_settings['minimize_to_tray'] and self.tray_icon.isVisible():\r\n-            self.hide()\r\n-            event.ignore()\r\n-        else:\r\n-            self.quit_application()\r\n-    \r\n-    def quit_application(self):\r\n-        \"\"\"アプリケーションを終了\"\"\"\r\n-        if self.automation_worker:\r\n-            self.stop_automation()\r\n-        \r\n-        # 設定を保存\r\n-        gui_settings = {\r\n-            'window_width': self.width(),\r\n-            'window_height': self.height(),\r\n-            'always_on_top': bool(self.windowFlags() & Qt.WindowStaysOnTopHint),\r\n-            'minimize_to_tray': True\r\n-        }\r\n-        self.config_manager.set_gui_settings(gui_settings)\r\n-        \r\n-        QApplication.quit()\r\n-\r\n-\r\n-class LogHandler(logging.Handler, QObject):\r\n-    \"\"\"ログをGUIに表示するためのハンドラー\"\"\"\r\n-    \r\n-    log_signal = pyqtSignal(str)\r\n-    \r\n-    def __init__(self):\r\n-        logging.Handler.__init__(self)\r\n-        QObject.__init__(self)\r\n-        \r\n-    def emit(self, record):\r\n-        msg = self.format(record)\r\n-        self.log_signal.emit(msg)\r\n-\r\n-\r\n-def main():\r\n-    app = QApplication(sys.argv)\r\n-    app.setQuitOnLastWindowClosed(False)  # トレイアイコンのため\r\n-    \r\n-    # アプリケーション情報\r\n-    app.setApplicationName(\"妖怪ウォッチぷにぷに自動周回ツール\")\r\n-    app.setApplicationVersion(\"1.0.0\")\r\n-    \r\n-    # ダークテーマの設定\r\n-    app.setStyle(\"Fusion\")\r\n-    palette = QPalette()\r\n-    palette.setColor(QPalette.Window, QColor(53, 53, 53))\r\n-    palette.setColor(QPalette.WindowText, Qt.white)\r\n-    palette.setColor(QPalette.Base, QColor(25, 25, 25))\r\n-    palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))\r\n-    palette.setColor(QPalette.ToolTipBase, Qt.white)\r\n-    palette.setColor(QPalette.ToolTipText, Qt.white)\r\n-    palette.setColor(QPalette.Text, Qt.white)\r\n-    palette.setColor(QPalette.Button, QColor(53, 53, 53))\r\n-    palette.setColor(QPalette.ButtonText, Qt.white)\r\n-    palette.setColor(QPalette.BrightText, Qt.red)\r\n-    palette.setColor(QPalette.Link, QColor(42, 130, 218))\r\n-    palette.setColor(QPalette.Highlight, QColor(42, 130, 218))\r\n-    palette.setColor(QPalette.HighlightedText, Qt.black)\r\n-    app.setPalette(palette)\r\n-    \r\n-    # メインウィンドウ\r\n-    window = MainWindow()\r\n-    window.show()\r\n-    \r\n-    sys.exit(app.exec_())\r\n-\r\n-\r\n-if __name__ == \"__main__\":\r\n-    main()\r\n\\ No newline at end of file\n"
                },
                {
                    "date": 1750517161014,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,257 @@\n-\n+import tkinter as tk\r\n+from tkinter import ttk, scrolledtext, messagebox\r\n+import threading\r\n+import time\r\n+from automation_engine import AutomationEngine\r\n+from config_manager import ConfigManager\r\n+\r\n+class PuniPuniAutoPlay:\r\n+    def __init__(self):\r\n+        self.root = tk.Tk()\r\n+        self.root.title(\"妖怪ウォッチぷにぷに 自動プレイ\")\r\n+        self.root.geometry(\"600x500\")\r\n+        self.root.resizable(True, True)\r\n+        \r\n+        # 設定管理とオートメーションエンジンの初期化\r\n+        self.config_manager = ConfigManager()\r\n+        self.automation_engine = AutomationEngine(self.config_manager)\r\n+        \r\n+        # GUI要素の初期化\r\n+        self.is_running = False\r\n+        self.automation_thread = None\r\n+        \r\n+        self.setup_ui()\r\n+        self.setup_callbacks()\r\n+        \r\n+    def setup_ui(self):\r\n+        \"\"\"UIの設定\"\"\"\r\n+        # メインフレーム\r\n+        main_frame = ttk.Frame(self.root, padding=\"10\")\r\n+        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n+        \r\n+        # タイトル\r\n+        title_label = ttk.Label(main_frame, text=\"妖怪ウォッチぷにぷに 自動プレイ\", \r\n+                               font=(\"Arial\", 16, \"bold\"))\r\n+        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))\r\n+        \r\n+        # デバイス設定フレーム\r\n+        device_frame = ttk.LabelFrame(main_frame, text=\"デバイス設定\", padding=\"10\")\r\n+        device_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))\r\n+        \r\n+        # デバイス選択\r\n+        ttk.Label(device_frame, text=\"デバイス:\").grid(row=0, column=0, sticky=tk.W)\r\n+        self.device_var = tk.StringVar()\r\n+        self.device_combo = ttk.Combobox(device_frame, textvariable=self.device_var, \r\n+                                        width=30, state=\"readonly\")\r\n+        self.device_combo.grid(row=0, column=1, padx=(10, 0), sticky=(tk.W, tk.E))\r\n+        \r\n+        # デバイス更新ボタン\r\n+        self.refresh_btn = ttk.Button(device_frame, text=\"デバイス更新\", \r\n+                                     command=self.refresh_devices)\r\n+        self.refresh_btn.grid(row=0, column=2, padx=(10, 0))\r\n+        \r\n+        # 自動化設定フレーム\r\n+        automation_frame = ttk.LabelFrame(main_frame, text=\"自動化設定\", padding=\"10\")\r\n+        automation_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))\r\n+        \r\n+        # タップ間隔設定\r\n+        ttk.Label(automation_frame, text=\"タップ間隔 (秒):\").grid(row=0, column=0, sticky=tk.W)\r\n+        self.tap_interval_var = tk.DoubleVar(value=0.5)\r\n+        tap_interval_spin = ttk.Spinbox(automation_frame, from_=0.1, to=5.0, \r\n+                                       increment=0.1, textvariable=self.tap_interval_var,\r\n+                                       width=10)\r\n+        tap_interval_spin.grid(row=0, column=1, padx=(10, 0), sticky=tk.W)\r\n+        \r\n+        # 検出精度設定\r\n+        ttk.Label(automation_frame, text=\"検出精度:\").grid(row=1, column=0, sticky=tk.W, pady=(10, 0))\r\n+        self.detection_threshold_var = tk.DoubleVar(value=0.8)\r\n+        threshold_scale = ttk.Scale(automation_frame, from_=0.5, to=1.0, \r\n+                                   variable=self.detection_threshold_var, \r\n+                                   orient=tk.HORIZONTAL, length=200)\r\n+        threshold_scale.grid(row=1, column=1, padx=(10, 0), sticky=(tk.W, tk.E), pady=(10, 0))\r\n+        \r\n+        # 精度値表示\r\n+        self.threshold_label = ttk.Label(automation_frame, text=\"0.80\")\r\n+        self.threshold_label.grid(row=1, column=2, padx=(10, 0), pady=(10, 0))\r\n+        \r\n+        # 制御ボタンフレーム\r\n+        control_frame = ttk.Frame(main_frame)\r\n+        control_frame.grid(row=3, column=0, columnspan=2, pady=(0, 10))\r\n+        \r\n+        # 開始/停止ボタン\r\n+        self.start_stop_btn = ttk.Button(control_frame, text=\"自動化開始\", \r\n+                                        command=self.toggle_automation)\r\n+        self.start_stop_btn.pack(side=tk.LEFT, padx=(0, 10))\r\n+        \r\n+        # テストボタン\r\n+        self.test_btn = ttk.Button(control_frame, text=\"画像検出テスト\", \r\n+                                  command=self.test_detection)\r\n+        self.test_btn.pack(side=tk.LEFT)\r\n+        \r\n+        # ログフレーム\r\n+        log_frame = ttk.LabelFrame(main_frame, text=\"ログ\", padding=\"10\")\r\n+        log_frame.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))\r\n+        \r\n+        # ログテキストエリア\r\n+        self.log_text = scrolledtext.ScrolledText(log_frame, height=10, width=70)\r\n+        self.log_text.pack(fill=tk.BOTH, expand=True)\r\n+        \r\n+        # ステータスバー\r\n+        self.status_var = tk.StringVar(value=\"準備完了\")\r\n+        status_bar = ttk.Label(main_frame, textvariable=self.status_var, \r\n+                              relief=tk.SUNKEN, anchor=tk.W)\r\n+        status_bar.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))\r\n+        \r\n+        # グリッドの重み設定\r\n+        main_frame.columnconfigure(1, weight=1)\r\n+        self.root.columnconfigure(0, weight=1)\r\n+        self.root.rowconfigure(0, weight=1)\r\n+        main_frame.rowconfigure(4, weight=1)\r\n+        device_frame.columnconfigure(1, weight=1)\r\n+        automation_frame.columnconfigure(1, weight=1)\r\n+        \r\n+    def setup_callbacks(self):\r\n+        \"\"\"コールバックの設定\"\"\"\r\n+        # スケール値の更新\r\n+        self.detection_threshold_var.trace('w', self.update_threshold_label)\r\n+        \r\n+        # 自動化エンジンのログコールバック\r\n+        self.automation_engine.set_log_callback(self.log_message)\r\n+        \r\n+    def update_threshold_label(self, *args):\r\n+        \"\"\"検出精度ラベルの更新\"\"\"\r\n+        value = self.detection_threshold_var.get()\r\n+        self.threshold_label.config(text=f\"{value:.2f}\")\r\n+        \r\n+    def refresh_devices(self):\r\n+        \"\"\"接続されているデバイスの更新\"\"\"\r\n+        self.log_message(\"デバイスを検索中...\")\r\n+        self.status_var.set(\"デバイス検索中...\")\r\n+        \r\n+        # 別スレッドでデバイス検索\r\n+        def search_devices():\r\n+            devices = self.automation_engine.get_available_devices()\r\n+            \r\n+            # UIスレッドで結果を更新\r\n+            self.root.after(0, self.update_device_list, devices)\r\n+            \r\n+        threading.Thread(target=search_devices, daemon=True).start()\r\n+        \r\n+    def update_device_list(self, devices):\r\n+        \"\"\"デバイスリストの更新\"\"\"\r\n+        self.device_combo['values'] = devices\r\n+        if devices:\r\n+            self.device_combo.current(0)\r\n+            self.log_message(f\"デバイスが見つかりました: {len(devices)}台\")\r\n+            self.status_var.set(\"デバイス検出完了\")\r\n+        else:\r\n+            self.log_message(\"デバイスが見つかりませんでした\")\r\n+            self.status_var.set(\"デバイスが見つかりません\")\r\n+            \r\n+    def toggle_automation(self):\r\n+        \"\"\"自動化の開始/停止\"\"\"\r\n+        if not self.is_running:\r\n+            self.start_automation()\r\n+        else:\r\n+            self.stop_automation()\r\n+            \r\n+    def start_automation(self):\r\n+        \"\"\"自動化開始\"\"\"\r\n+        device = self.device_var.get()\r\n+        if not device:\r\n+            messagebox.showerror(\"エラー\", \"デバイスを選択してください\")\r\n+            return\r\n+            \r\n+        # 設定の更新\r\n+        self.config_manager.set_config({\r\n+            'device': device,\r\n+            'tap_interval': self.tap_interval_var.get(),\r\n+            'detection_threshold': self.detection_threshold_var.get()\r\n+        })\r\n+        \r\n+        self.is_running = True\r\n+        self.start_stop_btn.config(text=\"自動化停止\", style=\"Accent.TButton\")\r\n+        self.status_var.set(\"自動化実行中...\")\r\n+        \r\n+        # 自動化スレッドの開始\r\n+        self.automation_thread = threading.Thread(target=self.run_automation, daemon=True)\r\n+        self.automation_thread.start()\r\n+        \r\n+        self.log_message(\"自動化を開始しました\")\r\n+        \r\n+    def stop_automation(self):\r\n+        \"\"\"自動化停止\"\"\"\r\n+        self.is_running = False\r\n+        self.automation_engine.stop()\r\n+        \r\n+        self.start_stop_btn.config(text=\"自動化開始\", style=\"\")\r\n+        self.status_var.set(\"自動化停止\")\r\n+        \r\n+        self.log_message(\"自動化を停止しました\")\r\n+        \r\n+    def run_automation(self):\r\n+        \"\"\"自動化の実行\"\"\"\r\n+        try:\r\n+            self.automation_engine.start()\r\n+            while self.is_running:\r\n+                if not self.automation_engine.process_frame():\r\n+                    time.sleep(0.1)\r\n+        except Exception as e:\r\n+            self.root.after(0, lambda: self.log_message(f\"エラー: {str(e)}\"))\r\n+            self.root.after(0, self.stop_automation)\r\n+            \r\n+    def test_detection(self):\r\n+        \"\"\"画像検出のテスト\"\"\"\r\n+        device = self.device_var.get()\r\n+        if not device:\r\n+            messagebox.showerror(\"エラー\", \"デバイスを選択してください\")\r\n+            return\r\n+            \r\n+        self.log_message(\"画像検出テストを実行しています...\")\r\n+        \r\n+        def run_test():\r\n+            try:\r\n+                # 設定の更新\r\n+                self.config_manager.set_config({\r\n+                    'device': device,\r\n+                    'detection_threshold': self.detection_threshold_var.get()\r\n+                })\r\n+                \r\n+                results = self.automation_engine.test_image_detection()\r\n+                \r\n+                # UIスレッドで結果を表示\r\n+                self.root.after(0, lambda: self.show_test_results(results))\r\n+                \r\n+            except Exception as e:\r\n+                self.root.after(0, lambda: self.log_message(f\"テストエラー: {str(e)}\"))\r\n+                \r\n+        threading.Thread(target=run_test, daemon=True).start()\r\n+        \r\n+    def show_test_results(self, results):\r\n+        \"\"\"テスト結果の表示\"\"\"\r\n+        message = \"画像検出テスト結果:\\n\\n\"\r\n+        for image_name, detected in results.items():\r\n+            status = \"検出\" if detected else \"未検出\"\r\n+            message += f\"{image_name}: {status}\\n\"\r\n+            \r\n+        messagebox.showinfo(\"テスト結果\", message)\r\n+        self.log_message(\"画像検出テストが完了しました\")\r\n+        \r\n+    def log_message(self, message):\r\n+        \"\"\"ログメッセージの追加\"\"\"\r\n+        timestamp = time.strftime(\"%H:%M:%S\")\r\n+        log_entry = f\"[{timestamp}] {message}\\n\"\r\n+        \r\n+        self.log_text.insert(tk.END, log_entry)\r\n+        self.log_text.see(tk.END)\r\n+        \r\n+    def run(self):\r\n+        \"\"\"アプリケーションの実行\"\"\"\r\n+        # 初期化時にデバイスを検索\r\n+        self.root.after(100, self.refresh_devices)\r\n+        \r\n+        self.root.mainloop()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    app = PuniPuniAutoPlay()\r\n+    app.run()\r\n"
                },
                {
                    "date": 1750517448957,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n         main_frame = ttk.Frame(self.root, padding=\"10\")\r\n         main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n         \r\n         # タイトル\r\n-        title_label = ttk.Label(main_frame, text=\"妖怪ウォッチぷにぷに 自動プレイ\", \r\n+        title_label = ttk.Label(main_frame, text=\"妖怪ウォッチぷにぷに オトクリ補助自動プレイ\", \r\n                                font=(\"Arial\", 16, \"bold\"))\r\n         title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))\r\n         \r\n         # デバイス設定フレーム\r\n"
                },
                {
                    "date": 1750517460896,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n         main_frame = ttk.Frame(self.root, padding=\"10\")\r\n         main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n         \r\n         # タイトル\r\n-        title_label = ttk.Label(main_frame, text=\"妖怪ウォッチぷにぷに オトクリ補助自動プレイ\", \r\n+        title_label = ttk.Label(main_frame, text=\"妖怪ウォッチぷにぷに オトクリ補助ツールV\", \r\n                                font=(\"Arial\", 16, \"bold\"))\r\n         title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))\r\n         \r\n         # デバイス設定フレーム\r\n"
                },
                {
                    "date": 1750517467726,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n         main_frame = ttk.Frame(self.root, padding=\"10\")\r\n         main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n         \r\n         # タイトル\r\n-        title_label = ttk.Label(main_frame, text=\"妖怪ウォッチぷにぷに オトクリ補助ツールV\", \r\n+        title_label = ttk.Label(main_frame, text=\"妖怪ウォッチぷにぷに オトクリ補助ツール　V1.0alpha\", \r\n                                font=(\"Arial\", 16, \"bold\"))\r\n         title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))\r\n         \r\n         # デバイス設定フレーム\r\n"
                },
                {
                    "date": 1750517484303,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n \r\n class PuniPuniAutoPlay:\r\n     def __init__(self):\r\n         self.root = tk.Tk()\r\n-        self.root.title(\"妖怪ウォッチぷにぷに 自動プレイ\")\r\n+        self.root.title(\"オトクリ補助ツール V1.0alpha\")\r\n         self.root.geometry(\"600x500\")\r\n         self.root.resizable(True, True)\r\n         \r\n         # 設定管理とオートメーションエンジンの初期化\r\n@@ -29,9 +29,9 @@\n         main_frame = ttk.Frame(self.root, padding=\"10\")\r\n         main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n         \r\n         # タイトル\r\n-        title_label = ttk.Label(main_frame, text=\"妖怪ウォッチぷにぷに オトクリ補助ツール　V1.0alpha\", \r\n+        title_label = ttk.Label(main_frame, text=\"妖怪ウォッチぷにぷに オトクリ補助ツール V1.0alpha\", \r\n                                font=(\"Arial\", 16, \"bold\"))\r\n         title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))\r\n         \r\n         # デバイス設定フレーム\r\n"
                },
                {
                    "date": 1750517492394,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n \r\n class PuniPuniAutoPlay:\r\n     def __init__(self):\r\n         self.root = tk.Tk()\r\n-        self.root.title(\"オトクリ補助ツール V1.0alpha\")\r\n+        self.root.title(\"妖怪ウォッチぷにぷに オトクリ補助ツール V1.0alpha\")\r\n         self.root.geometry(\"600x500\")\r\n         self.root.resizable(True, True)\r\n         \r\n         # 設定管理とオートメーションエンジンの初期化\r\n"
                },
                {
                    "date": 1750517815525,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n         main_frame = ttk.Frame(self.root, padding=\"10\")\r\n         main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n         \r\n         # タイトル\r\n-        title_label = ttk.Label(main_frame, text=\"妖怪ウォッチぷにぷに オトクリ補助ツール V1.0alpha\", \r\n+        title_label = ttk.Label(main_frame, text=\"オトクリ補助ツール V1.0alpha\", \r\n                                font=(\"Arial\", 16, \"bold\"))\r\n         title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))\r\n         \r\n         # デバイス設定フレーム\r\n"
                },
                {
                    "date": 1750518120828,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,16 +68,34 @@\n         threshold_scale = ttk.Scale(automation_frame, from_=0.5, to=1.0, \r\n                                    variable=self.detection_threshold_var, \r\n                                    orient=tk.HORIZONTAL, length=200)\r\n         threshold_scale.grid(row=1, column=1, padx=(10, 0), sticky=(tk.W, tk.E), pady=(10, 0))\r\n-        \r\n-        # 精度値表示\r\n+          # 精度値表示\r\n         self.threshold_label = ttk.Label(automation_frame, text=\"0.80\")\r\n         self.threshold_label.grid(row=1, column=2, padx=(10, 0), pady=(10, 0))\r\n         \r\n+        # 誤タップ防止設定フレーム\r\n+        prevent_frame = ttk.LabelFrame(main_frame, text=\"誤タップ防止\", padding=\"10\")\r\n+        prevent_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))\r\n+        \r\n+        # 誤タップ防止の各チェックボックス\r\n+        self.prevent_goukan_var = tk.BooleanVar(value=True)\r\n+        self.prevent_yuubin_var = tk.BooleanVar(value=True)\r\n+        self.prevent_ranking_var = tk.BooleanVar(value=True)\r\n+        self.prevent_menu_var = tk.BooleanVar(value=True)\r\n+        \r\n+        ttk.Checkbutton(prevent_frame, text=\"ごうかんボタンをタップしない\", \r\n+                       variable=self.prevent_goukan_var).grid(row=0, column=0, sticky=tk.W, pady=2)\r\n+        ttk.Checkbutton(prevent_frame, text=\"ゆうびんボタンをタップしない\", \r\n+                       variable=self.prevent_yuubin_var).grid(row=0, column=1, sticky=tk.W, pady=2, padx=(20, 0))\r\n+        ttk.Checkbutton(prevent_frame, text=\"ランキングボタンをタップしない\", \r\n+                       variable=self.prevent_ranking_var).grid(row=1, column=0, sticky=tk.W, pady=2)\r\n+        ttk.Checkbutton(prevent_frame, text=\"メニューボタンをタップしない\", \r\n+                       variable=self.prevent_menu_var).grid(row=1, column=1, sticky=tk.W, pady=2, padx=(20, 0))\r\n+        \r\n         # 制御ボタンフレーム\r\n         control_frame = ttk.Frame(main_frame)\r\n-        control_frame.grid(row=3, column=0, columnspan=2, pady=(0, 10))\r\n+        control_frame.grid(row=4, column=0, columnspan=2, pady=(0, 10))\r\n         \r\n         # 開始/停止ボタン\r\n         self.start_stop_btn = ttk.Button(control_frame, text=\"自動化開始\", \r\n                                         command=self.toggle_automation)\r\n@@ -86,12 +104,11 @@\n         # テストボタン\r\n         self.test_btn = ttk.Button(control_frame, text=\"画像検出テスト\", \r\n                                   command=self.test_detection)\r\n         self.test_btn.pack(side=tk.LEFT)\r\n-        \r\n-        # ログフレーム\r\n+          # ログフレーム\r\n         log_frame = ttk.LabelFrame(main_frame, text=\"ログ\", padding=\"10\")\r\n-        log_frame.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))\r\n+        log_frame.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))\r\n         \r\n         # ログテキストエリア\r\n         self.log_text = scrolledtext.ScrolledText(log_frame, height=10, width=70)\r\n         self.log_text.pack(fill=tk.BOTH, expand=True)\r\n@@ -99,15 +116,14 @@\n         # ステータスバー\r\n         self.status_var = tk.StringVar(value=\"準備完了\")\r\n         status_bar = ttk.Label(main_frame, textvariable=self.status_var, \r\n                               relief=tk.SUNKEN, anchor=tk.W)\r\n-        status_bar.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))\r\n-        \r\n-        # グリッドの重み設定\r\n+        status_bar.grid(row=6, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))\r\n+          # グリッドの重み設定\r\n         main_frame.columnconfigure(1, weight=1)\r\n         self.root.columnconfigure(0, weight=1)\r\n         self.root.rowconfigure(0, weight=1)\r\n-        main_frame.rowconfigure(4, weight=1)\r\n+        main_frame.rowconfigure(5, weight=1)\r\n         device_frame.columnconfigure(1, weight=1)\r\n         automation_frame.columnconfigure(1, weight=1)\r\n         \r\n     def setup_callbacks(self):\r\n@@ -160,14 +176,17 @@\n         device = self.device_var.get()\r\n         if not device:\r\n             messagebox.showerror(\"エラー\", \"デバイスを選択してください\")\r\n             return\r\n-            \r\n-        # 設定の更新\r\n+              # 設定の更新\r\n         self.config_manager.set_config({\r\n             'device': device,\r\n             'tap_interval': self.tap_interval_var.get(),\r\n-            'detection_threshold': self.detection_threshold_var.get()\r\n+            'detection_threshold': self.detection_threshold_var.get(),\r\n+            'prevent_goukan': self.prevent_goukan_var.get(),\r\n+            'prevent_yuubin': self.prevent_yuubin_var.get(),\r\n+            'prevent_ranking': self.prevent_ranking_var.get(),\r\n+            'prevent_menu': self.prevent_menu_var.get()\r\n         })\r\n         \r\n         self.is_running = True\r\n         self.start_stop_btn.config(text=\"自動化停止\", style=\"Accent.TButton\")\r\n@@ -209,13 +228,16 @@\n             \r\n         self.log_message(\"画像検出テストを実行しています...\")\r\n         \r\n         def run_test():\r\n-            try:\r\n-                # 設定の更新\r\n+            try:                # 設定の更新\r\n                 self.config_manager.set_config({\r\n                     'device': device,\r\n-                    'detection_threshold': self.detection_threshold_var.get()\r\n+                    'detection_threshold': self.detection_threshold_var.get(),\r\n+                    'prevent_goukan': self.prevent_goukan_var.get(),\r\n+                    'prevent_yuubin': self.prevent_yuubin_var.get(),\r\n+                    'prevent_ranking': self.prevent_ranking_var.get(),\r\n+                    'prevent_menu': self.prevent_menu_var.get()\r\n                 })\r\n                 \r\n                 results = self.automation_engine.test_image_detection()\r\n                 \r\n"
                },
                {
                    "date": 1750518940644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,10 @@\n import tkinter as tk\r\n-from tkinter import ttk, scrolledtext, messagebox\r\n+from tkinter import ttk, scrolledtext, messagebox, filedialog\r\n import threading\r\n import time\r\n+import os\r\n+import shutil\r\n from automation_engine import AutomationEngine\r\n from config_manager import ConfigManager\r\n \r\n class PuniPuniAutoPlay:\r\n@@ -80,10 +82,9 @@\n         # 誤タップ防止の各チェックボックス\r\n         self.prevent_goukan_var = tk.BooleanVar(value=True)\r\n         self.prevent_yuubin_var = tk.BooleanVar(value=True)\r\n         self.prevent_ranking_var = tk.BooleanVar(value=True)\r\n-        self.prevent_menu_var = tk.BooleanVar(value=True)\r\n-        \r\n+        self.prevent_menu_var = tk.BooleanVar(value=True)        \r\n         ttk.Checkbutton(prevent_frame, text=\"ごうかんボタンをタップしない\", \r\n                        variable=self.prevent_goukan_var).grid(row=0, column=0, sticky=tk.W, pady=2)\r\n         ttk.Checkbutton(prevent_frame, text=\"ゆうびんボタンをタップしない\", \r\n                        variable=self.prevent_yuubin_var).grid(row=0, column=1, sticky=tk.W, pady=2, padx=(20, 0))\r\n@@ -91,11 +92,56 @@\n                        variable=self.prevent_ranking_var).grid(row=1, column=0, sticky=tk.W, pady=2)\r\n         ttk.Checkbutton(prevent_frame, text=\"メニューボタンをタップしない\", \r\n                        variable=self.prevent_menu_var).grid(row=1, column=1, sticky=tk.W, pady=2, padx=(20, 0))\r\n         \r\n-        # 制御ボタンフレーム\r\n+        # 画像管理フレーム\r\n+        image_frame = ttk.LabelFrame(main_frame, text=\"画像管理\", padding=\"10\")\r\n+        image_frame.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))\r\n+        \r\n+        # 画像追加セクション\r\n+        ttk.Label(image_frame, text=\"新しい画像を追加:\").grid(row=0, column=0, sticky=tk.W, pady=(0, 5))\r\n+        \r\n+        # タップする画像追加\r\n+        tap_frame = ttk.Frame(image_frame)\r\n+        tap_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)\r\n+        \r\n+        ttk.Label(tap_frame, text=\"タップする画像:\").pack(side=tk.LEFT)\r\n+        self.add_tap_btn = ttk.Button(tap_frame, text=\"画像選択\", \r\n+                                     command=self.add_tap_image)\r\n+        self.add_tap_btn.pack(side=tk.LEFT, padx=(10, 0))\r\n+        \r\n+        # タップしない画像追加\r\n+        ignore_frame = ttk.Frame(image_frame)\r\n+        ignore_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)\r\n+        \r\n+        ttk.Label(ignore_frame, text=\"タップしない画像:\").pack(side=tk.LEFT)\r\n+        self.add_ignore_btn = ttk.Button(ignore_frame, text=\"画像選択\", \r\n+                                        command=self.add_ignore_image)\r\n+        self.add_ignore_btn.pack(side=tk.LEFT, padx=(10, 0))\r\n+        \r\n+        # 画像リスト表示\r\n+        ttk.Label(image_frame, text=\"現在の画像一覧:\").grid(row=3, column=0, sticky=tk.W, pady=(15, 5))\r\n+        \r\n+        # 画像リストフレーム\r\n+        list_frame = ttk.Frame(image_frame)\r\n+        list_frame.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)\r\n+        \r\n+        # 画像リストボックス\r\n+        self.image_listbox = tk.Listbox(list_frame, height=6, width=50)\r\n+        self.image_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\r\n+        \r\n+        # スクロールバー\r\n+        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=self.image_listbox.yview)\r\n+        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\r\n+        self.image_listbox.config(yscrollcommand=scrollbar.set)\r\n+        \r\n+        # 画像削除ボタン\r\n+        self.remove_image_btn = ttk.Button(image_frame, text=\"選択した画像を削除\", \r\n+                                          command=self.remove_image)\r\n+        self.remove_image_btn.grid(row=5, column=0, columnspan=2, pady=(10, 0))\r\n+          # 制御ボタンフレーム\r\n         control_frame = ttk.Frame(main_frame)\r\n-        control_frame.grid(row=4, column=0, columnspan=2, pady=(0, 10))\r\n+        control_frame.grid(row=5, column=0, columnspan=2, pady=(0, 10))\r\n         \r\n         # 開始/停止ボタン\r\n         self.start_stop_btn = ttk.Button(control_frame, text=\"自動化開始\", \r\n                                         command=self.toggle_automation)\r\n@@ -104,11 +150,12 @@\n         # テストボタン\r\n         self.test_btn = ttk.Button(control_frame, text=\"画像検出テスト\", \r\n                                   command=self.test_detection)\r\n         self.test_btn.pack(side=tk.LEFT)\r\n-          # ログフレーム\r\n+        \r\n+        # ログフレーム\r\n         log_frame = ttk.LabelFrame(main_frame, text=\"ログ\", padding=\"10\")\r\n-        log_frame.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))\r\n+        log_frame.grid(row=6, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))\r\n         \r\n         # ログテキストエリア\r\n         self.log_text = scrolledtext.ScrolledText(log_frame, height=10, width=70)\r\n         self.log_text.pack(fill=tk.BOTH, expand=True)\r\n@@ -116,25 +163,44 @@\n         # ステータスバー\r\n         self.status_var = tk.StringVar(value=\"準備完了\")\r\n         status_bar = ttk.Label(main_frame, textvariable=self.status_var, \r\n                               relief=tk.SUNKEN, anchor=tk.W)\r\n-        status_bar.grid(row=6, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))\r\n-          # グリッドの重み設定\r\n+        status_bar.grid(row=7, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))        # グリッドの重み設定\r\n         main_frame.columnconfigure(1, weight=1)\r\n         self.root.columnconfigure(0, weight=1)\r\n         self.root.rowconfigure(0, weight=1)\r\n-        main_frame.rowconfigure(5, weight=1)\r\n+        main_frame.rowconfigure(6, weight=1)  # ログフレームの行を拡張可能に\r\n         device_frame.columnconfigure(1, weight=1)\r\n         automation_frame.columnconfigure(1, weight=1)\r\n         \r\n+        # 設定値の初期化\r\n+        self.load_ui_settings()\r\n+        \r\n+    def load_ui_settings(self):\r\n+        \"\"\"UI設定値の読み込み\"\"\"\r\n+        config = self.config_manager.get_config()\r\n+        \r\n+        # 誤タップ防止設定の読み込み\r\n+        self.prevent_goukan_var.set(config.get('prevent_goukan', True))\r\n+        self.prevent_yuubin_var.set(config.get('prevent_yuubin', True))\r\n+        self.prevent_ranking_var.set(config.get('prevent_ranking', True))\r\n+        self.prevent_menu_var.set(config.get('prevent_menu', True))\r\n+        \r\n+        # 自動化設定の読み込み\r\n+        self.tap_interval_var.set(config.get('tap_interval', 0.5))\r\n+        self.detection_threshold_var.set(config.get('detection_threshold', 0.8))\r\n+        \r\n     def setup_callbacks(self):\r\n         \"\"\"コールバックの設定\"\"\"\r\n         # スケール値の更新\r\n         self.detection_threshold_var.trace('w', self.update_threshold_label)\r\n         \r\n         # 自動化エンジンのログコールバック\r\n         self.automation_engine.set_log_callback(self.log_message)\r\n         \r\n+        # 画像リストの初期化\r\n+        self.update_image_list()\r\n+        \r\n     def update_threshold_label(self, *args):\r\n         \"\"\"検出精度ラベルの更新\"\"\"\r\n         value = self.detection_threshold_var.get()\r\n         self.threshold_label.config(text=f\"{value:.2f}\")\r\n@@ -266,8 +332,161 @@\n         \r\n         self.log_text.insert(tk.END, log_entry)\r\n         self.log_text.see(tk.END)\r\n         \r\n+    def update_image_list(self):\r\n+        \"\"\"画像リストを更新\"\"\"\r\n+        self.image_listbox.delete(0, tk.END)\r\n+        \r\n+        image_dir = \"image\"\r\n+        if not os.path.exists(image_dir):\r\n+            os.makedirs(image_dir)\r\n+            return\r\n+            \r\n+        # タップする画像とタップしない画像を分類\r\n+        tap_images = []\r\n+        ignore_images = []\r\n+        \r\n+        # 設定から誤タップ防止画像を取得\r\n+        prevent_images = []\r\n+        if self.config_manager.get_config('prevent_goukan', True):\r\n+            prevent_images.append('koukan.png')\r\n+        if self.config_manager.get_config('prevent_yuubin', True):\r\n+            prevent_images.append('yubin.png')\r\n+        if self.config_manager.get_config('prevent_ranking', True):\r\n+            prevent_images.append('ranking.png')\r\n+        if self.config_manager.get_config('prevent_menu', True):\r\n+            prevent_images.append('menu.png')\r\n+        \r\n+        # imageフォルダ内の画像ファイルを確認\r\n+        for filename in os.listdir(image_dir):\r\n+            if filename.lower().endswith(('.png', '.jpg', '.jpeg')):\r\n+                if filename in prevent_images:\r\n+                    ignore_images.append(filename)\r\n+                else:\r\n+                    tap_images.append(filename)\r\n+        \r\n+        # リストボックスに表示\r\n+        for img in sorted(tap_images):\r\n+            self.image_listbox.insert(tk.END, f\"[タップする] {img}\")\r\n+        \r\n+        for img in sorted(ignore_images):\r\n+            self.image_listbox.insert(tk.END, f\"[タップしない] {img}\")\r\n+    \r\n+    def add_tap_image(self):\r\n+        \"\"\"タップする画像を追加\"\"\"\r\n+        file_path = filedialog.askopenfilename(\r\n+            title=\"タップする画像を選択\",\r\n+            filetypes=[\r\n+                (\"画像ファイル\", \"*.png *.jpg *.jpeg\"),\r\n+                (\"PNGファイル\", \"*.png\"),\r\n+                (\"JPEGファイル\", \"*.jpg *.jpeg\"),\r\n+                (\"すべてのファイル\", \"*.*\")\r\n+            ]\r\n+        )\r\n+        \r\n+        if file_path:\r\n+            self._add_image_file(file_path, is_tap_image=True)\r\n+    \r\n+    def add_ignore_image(self):\r\n+        \"\"\"タップしない画像を追加\"\"\"\r\n+        file_path = filedialog.askopenfilename(\r\n+            title=\"タップしない画像を選択\",\r\n+            filetypes=[\r\n+                (\"画像ファイル\", \"*.png *.jpg *.jpeg\"),\r\n+                (\"PNGファイル\", \"*.png\"),\r\n+                (\"JPEGファイル\", \"*.jpg *.jpeg\"),\r\n+                (\"すべてのファイル\", \"*.*\")\r\n+            ]\r\n+        )\r\n+        \r\n+        if file_path:\r\n+            self._add_image_file(file_path, is_tap_image=False)\r\n+    \r\n+    def _add_image_file(self, file_path, is_tap_image=True):\r\n+        \"\"\"画像ファイルをimageフォルダに追加\"\"\"\r\n+        try:\r\n+            # ファイル名を取得\r\n+            filename = os.path.basename(file_path)\r\n+            \r\n+            # 画像フォルダのパス\r\n+            image_dir = \"image\"\r\n+            if not os.path.exists(image_dir):\r\n+                os.makedirs(image_dir)\r\n+            \r\n+            destination = os.path.join(image_dir, filename)\r\n+            \r\n+            # 既に同じ名前のファイルが存在する場合は確認\r\n+            if os.path.exists(destination):\r\n+                result = messagebox.askyesno(\r\n+                    \"ファイル上書き確認\",\r\n+                    f\"'{filename}' は既に存在します。上書きしますか？\"\r\n+                )\r\n+                if not result:\r\n+                    return\r\n+            \r\n+            # ファイルをコピー\r\n+            shutil.copy2(file_path, destination)\r\n+            \r\n+            # タップしない画像の場合、設定に追加\r\n+            if not is_tap_image:\r\n+                # 新規追加の場合はファイル名のみで管理\r\n+                self.log_message(f\"タップしない画像として '{filename}' を追加しました\")\r\n+            else:\r\n+                self.log_message(f\"タップする画像として '{filename}' を追加しました\")\r\n+            \r\n+            # 画像リストを更新\r\n+            self.update_image_list()\r\n+            \r\n+            # オートメーションエンジンに変更を通知\r\n+            self.automation_engine.reload_images()\r\n+            \r\n+        except Exception as e:\r\n+            messagebox.showerror(\"エラー\", f\"画像の追加に失敗しました:\\n{str(e)}\")\r\n+            self.log_message(f\"画像追加エラー: {str(e)}\")\r\n+    \r\n+    def remove_image(self):\r\n+        \"\"\"選択した画像を削除\"\"\"\r\n+        selection = self.image_listbox.curselection()\r\n+        if not selection:\r\n+            messagebox.showwarning(\"警告\", \"削除する画像を選択してください\")\r\n+            return\r\n+        \r\n+        # 選択された項目のテキストを取得\r\n+        selected_text = self.image_listbox.get(selection[0])\r\n+        \r\n+        # ファイル名を抽出（[タイプ] filename形式から）\r\n+        if \"] \" in selected_text:\r\n+            filename = selected_text.split(\"] \", 1)[1]\r\n+        else:\r\n+            filename = selected_text\r\n+        \r\n+        # 削除確認\r\n+        result = messagebox.askyesno(\r\n+            \"削除確認\",\r\n+            f\"'{filename}' を削除しますか？\\nこの操作は元に戻せません。\"\r\n+        )\r\n+        \r\n+        if result:\r\n+            try:\r\n+                # ファイルを削除\r\n+                file_path = os.path.join(\"image\", filename)\r\n+                if os.path.exists(file_path):\r\n+                    os.remove(file_path)\r\n+                    self.log_message(f\"画像 '{filename}' を削除しました\")\r\n+                    \r\n+                    # 画像リストを更新\r\n+                    self.update_image_list()\r\n+                    \r\n+                    # オートメーションエンジンに変更を通知\r\n+                    self.automation_engine.reload_images()\r\n+                else:\r\n+                    messagebox.showerror(\"エラー\", f\"ファイルが見つかりません: {filename}\")\r\n+                    \r\n+            except Exception as e:\r\n+                messagebox.showerror(\"エラー\", f\"画像の削除に失敗しました:\\n{str(e)}\")\r\n+                self.log_message(f\"画像削除エラー: {str(e)}\")\r\n+    \r\n     def run(self):\r\n         \"\"\"アプリケーションの実行\"\"\"\r\n         # 初期化時にデバイスを検索\r\n         self.root.after(100, self.refresh_devices)\r\n"
                },
                {
                    "date": 1750519368978,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n         main_frame = ttk.Frame(self.root, padding=\"10\")\r\n         main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n         \r\n         # タイトル\r\n-        title_label = ttk.Label(main_frame, text=\"オトクリ補助ツール V1.0alpha\", \r\n+        title_label = ttk.Label(main_frame, text=\"オトクリ補助ツール \", \r\n                                font=(\"Arial\", 16, \"bold\"))\r\n         title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))\r\n         \r\n         # デバイス設定フレーム\r\n@@ -305,10 +305,9 @@\n                     'prevent_menu': self.prevent_menu_var.get()\r\n                 })\r\n                 \r\n                 results = self.automation_engine.test_image_detection()\r\n-                \r\n-                # UIスレッドで結果を表示\r\n+                  # UIスレッドで結果を表示\r\n                 self.root.after(0, lambda: self.show_test_results(results))\r\n                 \r\n             except Exception as e:\r\n                 self.root.after(0, lambda: self.log_message(f\"テストエラー: {str(e)}\"))\r\n@@ -346,16 +345,17 @@\n         tap_images = []\r\n         ignore_images = []\r\n         \r\n         # 設定から誤タップ防止画像を取得\r\n+        config = self.config_manager.get_config()\r\n         prevent_images = []\r\n-        if self.config_manager.get_config('prevent_goukan', True):\r\n+        if config.get('prevent_goukan', True):\r\n             prevent_images.append('koukan.png')\r\n-        if self.config_manager.get_config('prevent_yuubin', True):\r\n+        if config.get('prevent_yuubin', True):\r\n             prevent_images.append('yubin.png')\r\n-        if self.config_manager.get_config('prevent_ranking', True):\r\n+        if config.get('prevent_ranking', True):\r\n             prevent_images.append('ranking.png')\r\n-        if self.config_manager.get_config('prevent_menu', True):\r\n+        if config.get('prevent_menu', True):\r\n             prevent_images.append('menu.png')\r\n         \r\n         # imageフォルダ内の画像ファイルを確認\r\n         for filename in os.listdir(image_dir):\r\n"
                },
                {
                    "date": 1750519375163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n         main_frame = ttk.Frame(self.root, padding=\"10\")\r\n         main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n         \r\n         # タイトル\r\n-        title_label = ttk.Label(main_frame, text=\"オトクリ補助ツール \", \r\n+        title_label = ttk.Label(main_frame, text=\"オトクリ補助ツール for Windows\", \r\n                                font=(\"Arial\", 16, \"bold\"))\r\n         title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))\r\n         \r\n         # デバイス設定フレーム\r\n"
                },
                {
                    "date": 1750519709470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n class PuniPuniAutoPlay:\r\n     def __init__(self):\r\n         self.root = tk.Tk()\r\n         self.root.title(\"妖怪ウォッチぷにぷに オトクリ補助ツール V1.0alpha\")\r\n-        self.root.geometry(\"600x500\")\r\n+        self.root.geometry(\"600x1000\")\r\n         self.root.resizable(True, True)\r\n         \r\n         # 設定管理とオートメーションエンジンの初期化\r\n         self.config_manager = ConfigManager()\r\n"
                },
                {
                    "date": 1750519719534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n class PuniPuniAutoPlay:\r\n     def __init__(self):\r\n         self.root = tk.Tk()\r\n         self.root.title(\"妖怪ウォッチぷにぷに オトクリ補助ツール V1.0alpha\")\r\n-        self.root.geometry(\"600x1000\")\r\n+        self.root.geometry(\"600x800\")\r\n         self.root.resizable(True, True)\r\n         \r\n         # 設定管理とオートメーションエンジンの初期化\r\n         self.config_manager = ConfigManager()\r\n"
                },
                {
                    "date": 1750519733010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n class PuniPuniAutoPlay:\r\n     def __init__(self):\r\n         self.root = tk.Tk()\r\n         self.root.title(\"妖怪ウォッチぷにぷに オトクリ補助ツール V1.0alpha\")\r\n-        self.root.geometry(\"600x800\")\r\n+        self.root.geometry(\"600x900\")\r\n         self.root.resizable(True, True)\r\n         \r\n         # 設定管理とオートメーションエンジンの初期化\r\n         self.config_manager = ConfigManager()\r\n"
                },
                {
                    "date": 1750519751502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n class PuniPuniAutoPlay:\r\n     def __init__(self):\r\n         self.root = tk.Tk()\r\n         self.root.title(\"妖怪ウォッチぷにぷに オトクリ補助ツール V1.0alpha\")\r\n-        self.root.geometry(\"600x900\")\r\n+        self.root.geometry(\"500x900\")\r\n         self.root.resizable(True, True)\r\n         \r\n         # 設定管理とオートメーションエンジンの初期化\r\n         self.config_manager = ConfigManager()\r\n"
                }
            ],
            "date": 1750487296904,
            "name": "Commit-0",
            "content": "import cv2\r\nimport numpy as np\r\nimport time\r\nimport os\r\nimport subprocess\r\nimport threading\r\nimport tkinter as tk\r\nfrom tkinter import ttk, filedialog, scrolledtext\r\nfrom PIL import Image, ImageTk\r\nimport pyautogui\r\n\r\nclass YokaiWatchAutoGUI:\r\n    def __init__(self, root):\r\n        self.root = root\r\n        self.root.title(\"妖怪ウォッチぷにぷに自動周回ソフト\")\r\n        self.root.geometry(\"800x600\")\r\n        self.root.resizable(True, True)\r\n        \r\n        # アプリケーション状態\r\n        self.running = False\r\n        self.paused = False\r\n        self.stage_45_detected = False\r\n        self.puzzle_tapped_count = 0\r\n        self.adb_path = \"\"\r\n        self.images_path = \"\"\r\n        self.images = {\r\n            \"boss\": None,\r\n            \"play\": None,\r\n            \"puzzle\": None,\r\n            \"waza_ok\": None,\r\n            \"next\": None,\r\n            \"close\": None,\r\n            \"close_mini\": None,\r\n            \"stage_45\": None\r\n        }\r\n        \r\n        # メインフレームの作成\r\n        self.main_frame = ttk.Frame(self.root, padding=10)\r\n        self.main_frame.pack(fill=tk.BOTH, expand=True)\r\n        \r\n        # 設定フレーム\r\n        self.setup_settings_frame()\r\n        \r\n        # コントロールフレーム\r\n        self.setup_control_frame()\r\n        \r\n        # ログフレーム\r\n        self.setup_log_frame()\r\n        \r\n        # ステータスバー\r\n        self.status_var = tk.StringVar()\r\n        self.status_var.set(\"準備完了\")\r\n        self.status_bar = ttk.Label(self.root, textvariable=self.status_var, relief=tk.SUNKEN, anchor=tk.W)\r\n        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)\r\n    \r\n    def setup_settings_frame(self):\r\n        settings_frame = ttk.LabelFrame(self.main_frame, text=\"設定\", padding=10)\r\n        settings_frame.pack(fill=tk.X, pady=5)\r\n        \r\n        # ADBパス設定\r\n        ttk.Label(settings_frame, text=\"ADBパス:\").grid(row=0, column=0, sticky=tk.W, pady=5)\r\n        self.adb_path_var = tk.StringVar()\r\n        adb_entry = ttk.Entry(settings_frame, textvariable=self.adb_path_var, width=50)\r\n        adb_entry.grid(row=0, column=1, sticky=tk.W, pady=5)\r\n        ttk.Button(settings_frame, text=\"参照\", command=self.browse_adb).grid(row=0, column=2, sticky=tk.W, pady=5, padx=5)\r\n        \r\n        # 画像フォルダ設定\r\n        ttk.Label(settings_frame, text=\"画像フォルダ:\").grid(row=1, column=0, sticky=tk.W, pady=5)\r\n        self.images_path_var = tk.StringVar()\r\n        images_entry = ttk.Entry(settings_frame, textvariable=self.images_path_var, width=50)\r\n        images_entry.grid(row=1, column=1, sticky=tk.W, pady=5)\r\n        ttk.Button(settings_frame, text=\"参照\", command=self.browse_images).grid(row=1, column=2, sticky=tk.W, pady=5, padx=5)\r\n        \r\n        # 一致率設定\r\n        ttk.Label(settings_frame, text=\"一致率しきい値:\").grid(row=2, column=0, sticky=tk.W, pady=5)\r\n        self.threshold_var = tk.DoubleVar(value=0.8)\r\n        threshold_scale = ttk.Scale(settings_frame, from_=0.5, to=1.0, orient=tk.HORIZONTAL, \r\n                                    variable=self.threshold_var, length=200)\r\n        threshold_scale.grid(row=2, column=1, sticky=tk.W, pady=5)\r\n        ttk.Label(settings_frame, textvariable=self.threshold_var).grid(row=2, column=2, sticky=tk.W, pady=5)\r\n        \r\n        # ディレイ設定\r\n        ttk.Label(settings_frame, text=\"操作間隔(秒):\").grid(row=3, column=0, sticky=tk.W, pady=5)\r\n        self.delay_var = tk.DoubleVar(value=1.0)\r\n        delay_scale = ttk.Scale(settings_frame, from_=0.1, to=5.0, orient=tk.HORIZONTAL, \r\n                                variable=self.delay_var, length=200)\r\n        delay_scale.grid(row=3, column=1, sticky=tk.W, pady=5)\r\n        ttk.Label(settings_frame, textvariable=self.delay_var).grid(row=3, column=2, sticky=tk.W, pady=5)\r\n        \r\n        # 画像のロードボタン\r\n        ttk.Button(settings_frame, text=\"画像をロード\", command=self.load_images).grid(row=4, column=1, pady=10)\r\n    \r\n    def setup_control_frame(self):\r\n        control_frame = ttk.LabelFrame(self.main_frame, text=\"コントロール\", padding=10)\r\n        control_frame.pack(fill=tk.X, pady=5)\r\n        \r\n        # スタート・ストップボタン\r\n        self.start_btn = ttk.Button(control_frame, text=\"開始\", command=self.start_automation)\r\n        self.start_btn.pack(side=tk.LEFT, padx=5)\r\n        \r\n        self.stop_btn = ttk.Button(control_frame, text=\"停止\", command=self.stop_automation, state=tk.DISABLED)\r\n        self.stop_btn.pack(side=tk.LEFT, padx=5)\r\n        \r\n        self.pause_btn = ttk.Button(control_frame, text=\"一時停止\", command=self.pause_automation, state=tk.DISABLED)\r\n        self.pause_btn.pack(side=tk.LEFT, padx=5)\r\n        \r\n        # 1サイクルのみ実行ボタン\r\n        self.single_cycle_btn = ttk.Button(control_frame, text=\"1サイクル実行\", command=self.run_single_cycle)\r\n        self.single_cycle_btn.pack(side=tk.LEFT, padx=5)\r\n        \r\n        # スクリーンショットボタン\r\n        self.screenshot_btn = ttk.Button(control_frame, text=\"スクリーンショット\", command=self.take_screenshot)\r\n        self.screenshot_btn.pack(side=tk.LEFT, padx=5)\r\n    \r\n    def setup_log_frame(self):\r\n        log_frame = ttk.LabelFrame(self.main_frame, text=\"ログ\", padding=10)\r\n        log_frame.pack(fill=tk.BOTH, expand=True, pady=5)\r\n        \r\n        # ログエリア\r\n        self.log_area = scrolledtext.ScrolledText(log_frame, width=80, height=15)\r\n        self.log_area.pack(fill=tk.BOTH, expand=True)\r\n        self.log_area.config(state=tk.DISABLED)\r\n        \r\n        # プレビューフレーム\r\n        preview_frame = ttk.LabelFrame(self.main_frame, text=\"プレビュー\", padding=10)\r\n        preview_frame.pack(fill=tk.X, pady=5)\r\n        \r\n        self.preview_label = ttk.Label(preview_frame, text=\"スクリーンショットをここに表示\")\r\n        self.preview_label.pack(padx=10, pady=10)\r\n    \r\n    def browse_adb(self):\r\n        path = filedialog.askopenfilename(title=\"ADB実行ファイルを選択\", \r\n                                         filetypes=[(\"実行ファイル\", \"*.exe\"), (\"すべてのファイル\", \"*.*\")])\r\n        if path:\r\n            self.adb_path_var.set(path)\r\n            self.adb_path = path\r\n            self.log(\"ADBパスを設定: \" + path)\r\n    \r\n    def browse_images(self):\r\n        path = filedialog.askdirectory(title=\"画像フォルダを選択\")\r\n        if path:\r\n            self.images_path_var.set(path)\r\n            self.images_path = path\r\n            self.log(\"画像フォルダを設定: \" + path)\r\n    \r\n    def load_images(self):\r\n        if not self.images_path:\r\n            self.log(\"エラー: 画像フォルダが設定されていません。\")\r\n            return\r\n            \r\n        try:\r\n            for image_name in self.images:\r\n                image_path = os.path.join(self.images_path, f\"{image_name}.png\")\r\n                if os.path.exists(image_path):\r\n                    self.images[image_name] = cv2.imread(image_path)\r\n                    if self.images[image_name] is not None:\r\n                        self.log(f\"{image_name}.pngを読み込みました。\")\r\n                    else:\r\n                        self.log(f\"警告: {image_name}.pngの読み込みに失敗しました。\")\r\n                else:\r\n                    self.log(f\"警告: {image_name}.pngが見つかりません。\")\r\n            \r\n            self.log(\"画像の読み込みが完了しました。\")\r\n        except Exception as e:\r\n            self.log(f\"エラー: 画像の読み込み中にエラーが発生しました。{str(e)}\")\r\n    \r\n    def log(self, message):\r\n        self.log_area.config(state=tk.NORMAL)\r\n        self.log_area.insert(tk.END, f\"[{time.strftime('%H:%M:%S')}] {message}\\n\")\r\n        self.log_area.see(tk.END)\r\n        self.log_area.config(state=tk.DISABLED)\r\n    \r\n    def start_automation(self):\r\n        if not self.adb_path or not self.images_path:\r\n            self.log(\"エラー: ADBパスと画像フォルダを設定してください。\")\r\n            return\r\n            \r\n        # 必要な画像が読み込まれているか確認\r\n        missing_images = [name for name, img in self.images.items() if img is None]\r\n        if missing_images:\r\n            self.log(f\"エラー: 以下の画像が読み込まれていません: {', '.join(missing_images)}\")\r\n            return\r\n        \r\n        self.running = True\r\n        self.paused = False\r\n        self.stage_45_detected = False\r\n        self.puzzle_tapped_count = 0\r\n        \r\n        # UIの更新\r\n        self.start_btn.config(state=tk.DISABLED)\r\n        self.stop_btn.config(state=tk.NORMAL)\r\n        self.pause_btn.config(state=tk.NORMAL)\r\n        self.single_cycle_btn.config(state=tk.DISABLED)\r\n        \r\n        self.status_var.set(\"実行中...\")\r\n        self.log(\"自動周回を開始しました。\")\r\n        \r\n        # 別スレッドで実行\r\n        self.automation_thread = threading.Thread(target=self.automation_loop)\r\n        self.automation_thread.daemon = True\r\n        self.automation_thread.start()\r\n    \r\n    def stop_automation(self):\r\n        self.running = False\r\n        \r\n        # UIの更新\r\n        self.start_btn.config(state=tk.NORMAL)\r\n        self.stop_btn.config(state=tk.DISABLED)\r\n        self.pause_btn.config(state=tk.DISABLED)\r\n        self.single_cycle_btn.config(state=tk.NORMAL)\r\n        \r\n        self.status_var.set(\"停止\")\r\n        self.log(\"自動周回を停止しました。\")\r\n    \r\n    def pause_automation(self):\r\n        self.paused = not self.paused\r\n        \r\n        if self.paused:\r\n            self.pause_btn.config(text=\"再開\")\r\n            self.status_var.set(\"一時停止中\")\r\n            self.log(\"自動周回を一時停止しました。\")\r\n        else:\r\n            self.pause_btn.config(text=\"一時停止\")\r\n            self.status_var.set(\"実行中...\")\r\n            self.log(\"自動周回を再開しました。\")\r\n    \r\n    def run_single_cycle(self):\r\n        if not self.adb_path or not self.images_path:\r\n            self.log(\"エラー: ADBパスと画像フォルダを設定してください。\")\r\n            return\r\n            \r\n        # 必要な画像が読み込まれているか確認\r\n        missing_images = [name for name, img in self.images.items() if img is None]\r\n        if missing_images:\r\n            self.log(f\"エラー: 以下の画像が読み込まれていません: {', '.join(missing_images)}\")\r\n            return\r\n        \r\n        # UIの更新\r\n        self.start_btn.config(state=tk.DISABLED)\r\n        self.stop_btn.config(state=tk.DISABLED)\r\n        self.pause_btn.config(state=tk.DISABLED)\r\n        self.single_cycle_btn.config(state=tk.DISABLED)\r\n        \r\n        self.status_var.set(\"1サイクル実行中...\")\r\n        self.log(\"1サイクルの実行を開始しました。\")\r\n        \r\n        # 別スレッドで実行\r\n        threading.Thread(target=self.run_one_cycle).daemon = True\r\n        threading.Thread(target=self.run_one_cycle).start()\r\n    \r\n    def take_screenshot(self):\r\n        try:\r\n            self.log(\"スクリーンショットを取得中...\")\r\n            result = subprocess.run([self.adb_path, \"shell\", \"screencap\", \"-p\", \"/sdcard/screenshot.png\"], \r\n                                  stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)\r\n            \r\n            result = subprocess.run([self.adb_path, \"pull\", \"/sdcard/screenshot.png\", \"screenshot.png\"], \r\n                                  stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)\r\n            \r\n            # プレビューを更新\r\n            img = Image.open(\"screenshot.png\")\r\n            img = img.resize((300, 200), Image.LANCZOS)\r\n            img_tk = ImageTk.PhotoImage(img)\r\n            \r\n            self.preview_label.config(image=img_tk)\r\n            self.preview_label.image = img_tk  # 参照を保持\r\n            \r\n            self.log(\"スクリーンショットを取得しました。\")\r\n        except Exception as e:\r\n            self.log(f\"エラー: スクリーンショット取得中にエラーが発生しました。{str(e)}\")\r\n    \r\n    def detect_image(self, template_name):\r\n        try:\r\n            # スクリーンショットの取得\r\n            subprocess.run([self.adb_path, \"shell\", \"screencap\", \"-p\", \"/sdcard/screenshot.png\"], check=True)\r\n            subprocess.run([self.adb_path, \"pull\", \"/sdcard/screenshot.png\", \"screenshot.png\"], check=True)\r\n            \r\n            # 画像の読み込み\r\n            screenshot = cv2.imread(\"screenshot.png\")\r\n            template = self.images[template_name]\r\n            \r\n            if screenshot is None or template is None:\r\n                self.log(f\"エラー: 画像の読み込みに失敗しました。\")\r\n                return None\r\n            \r\n            # テンプレートマッチング\r\n            result = cv2.matchTemplate(screenshot, template, cv2.TM_CCOEFF_NORMED)\r\n            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)\r\n            \r\n            threshold = self.threshold_var.get()\r\n            if max_val >= threshold:\r\n                # マッチした位置を計算\r\n                h, w = template.shape[:2]\r\n                top_left = max_loc\r\n                center_x = top_left[0] + w // 2\r\n                center_y = top_left[1] + h // 2\r\n                \r\n                self.log(f\"{template_name}.pngを検出しました。一致率: {max_val:.2f}, 位置: ({center_x}, {center_y})\")\r\n                return (center_x, center_y)\r\n            else:\r\n                self.log(f\"{template_name}.pngは検出されませんでした。最大一致率: {max_val:.2f}\")\r\n                return None\r\n        except Exception as e:\r\n            self.log(f\"エラー: 画像検出中にエラーが発生しました。{str(e)}\")\r\n            return None\r\n    \r\n    def tap(self, x, y):\r\n        try:\r\n            subprocess.run([self.adb_path, \"shell\", \"input\", \"tap\", str(x), str(y)], check=True)\r\n            self.log(f\"画面の位置 ({x}, {y}) をタップしました。\")\r\n            time.sleep(self.delay_var.get())  # 操作間の待機\r\n            return True\r\n        except Exception as e:\r\n            self.log(f\"エラー: タップ操作中にエラーが発生しました。{str(e)}\")\r\n            return False\r\n    \r\n    def check_close_button(self):\r\n        # close.pngの検出\r\n        close_pos = self.detect_image(\"close\")\r\n        if close_pos:\r\n            if not (self.stage_45_detected):\r\n                self.log(\"close.pngを検出しました。タップします。\")\r\n                self.tap(close_pos[0], close_pos[1])\r\n                return True\r\n            else:\r\n                self.log(\"stage_45が検出されているため、close.pngはタップしません。\")\r\n        \r\n        # close_mini.pngの検出\r\n        close_mini_pos = self.detect_image(\"close_mini\")\r\n        if close_mini_pos:\r\n            if not (self.stage_45_detected):\r\n                self.log(\"close_mini.pngを検出しました。タップします。\")\r\n                self.tap(close_mini_pos[0], close_mini_pos[1])\r\n                return True\r\n            else:\r\n                self.log(\"stage_45が検出されているため、close_mini.pngはタップしません。\")\r\n        \r\n        return False\r\n    \r\n    def automation_loop(self):\r\n        while self.running:\r\n            if not self.paused:\r\n                self.run_one_cycle()\r\n            else:\r\n                time.sleep(0.5)  # 一時停止中は短い間隔でループ\r\n    \r\n    def run_one_cycle(self):\r\n        try:\r\n            # 常時closeボタンをチェック\r\n            if self.check_close_button():\r\n                time.sleep(self.delay_var.get())\r\n            \r\n            # ステップ1: boss.pngをタップ\r\n            self.log(\"ステップ1: boss.pngを探しています...\")\r\n            boss_pos = self.detect_image(\"boss\")\r\n            if boss_pos:\r\n                self.tap(boss_pos[0], boss_pos[1])\r\n            else:\r\n                self.log(\"boss.pngが見つかりませんでした。再試行します。\")\r\n                time.sleep(self.delay_var.get())\r\n                return\r\n            \r\n            # ステップ2: play.pngをタップ\r\n            self.log(\"ステップ2: play.pngを探しています...\")\r\n            play_pos = self.detect_image(\"play\")\r\n            if play_pos:\r\n                # stage_45の検出\r\n                stage_45_pos = self.detect_image(\"stage_45\")\r\n                if stage_45_pos:\r\n                    self.log(\"stage_45.pngを検出しました。\")\r\n                    self.stage_45_detected = True\r\n                \r\n                self.tap(play_pos[0], play_pos[1])\r\n            else:\r\n                self.log(\"play.pngが見つかりませんでした。再試行します。\")\r\n                time.sleep(self.delay_var.get())\r\n                return\r\n            \r\n            # ステップ3と4: puzzle.pngとwaza_ok.pngを交互にタップ、next.pngが検出されるまで\r\n            self.puzzle_tapped_count = 0\r\n            next_detected = False\r\n            \r\n            self.log(\"ステップ3/4: パズル中のループを開始します...\")\r\n            while not next_detected and self.running and not self.paused:\r\n                # 常時closeボタンをチェック\r\n                if self.check_close_button():\r\n                    time.sleep(self.delay_var.get())\r\n                \r\n                # next.pngの検出\r\n                next_pos = self.detect_image(\"next\")\r\n                if next_pos:\r\n                    next_detected = True\r\n                    self.log(\"next.pngを検出しました。ループを終了します。\")\r\n                    break\r\n                \r\n                # puzzle.pngのタップ（2回まで）\r\n                if self.puzzle_tapped_count < 2:\r\n                    puzzle_pos = self.detect_image(\"puzzle\")\r\n                    if puzzle_pos:\r\n                        self.tap(puzzle_pos[0], puzzle_pos[1])\r\n                        self.puzzle_tapped_count += 1\r\n                \r\n                # waza_ok.pngのタップ\r\n                waza_ok_pos = self.detect_image(\"waza_ok\")\r\n                if waza_ok_pos:\r\n                    self.tap(waza_ok_pos[0], waza_ok_pos[1])\r\n                \r\n                time.sleep(self.delay_var.get())\r\n            \r\n            # ステップ5: next.pngをタップ\r\n            if next_detected:\r\n                self.log(\"ステップ5: next.pngをタップします...\")\r\n                next_pos = self.detect_image(\"next\")\r\n                if next_pos:\r\n                    self.tap(next_pos[0], next_pos[1])\r\n            \r\n            # 1サイクル終了\r\n            self.log(\"1サイクルが完了しました。\")\r\n            self.stage_45_detected = False  # stage_45フラグをリセット\r\n            \r\n            # 単一サイクルモードの場合はUIを更新\r\n            if not self.running:\r\n                self.root.after(0, self.update_ui_after_single_cycle)\r\n            \r\n        except Exception as e:\r\n            self.log(f\"エラー: 自動化ループ中にエラーが発生しました。{str(e)}\")\r\n            if not self.running:\r\n                self.root.after(0, self.update_ui_after_single_cycle)\r\n    \r\n    def update_ui_after_single_cycle(self):\r\n        self.start_btn.config(state=tk.NORMAL)\r\n        self.stop_btn.config(state=tk.DISABLED)\r\n        self.pause_btn.config(state=tk.DISABLED)\r\n        self.single_cycle_btn.config(state=tk.NORMAL)\r\n        self.status_var.set(\"準備完了\")\r\n\r\nif __name__ == \"__main__\":\r\n    root = tk.Tk()\r\n    app = YokaiWatchAutoGUI(root)\r\n    root.mainloop()"
        }
    ]
}