{
    "sourceFile": "device_controller.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1750493481589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750495704642,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,280 +1,180 @@\n-\"\"\"\r\n-デバイス制御機能モジュール\r\n-ADB操作、スクリーンショット取得、タップ操作などのデバイス制御機能\r\n-\"\"\"\r\n-\r\n import subprocess\r\n-import cv2\r\n-import numpy as np\r\n import time\r\n-import struct\r\n+import logging\r\n+from typing import List, Tuple, Optional\r\n+import threading\r\n+import asyncio\r\n+from concurrent.futures import ThreadPoolExecutor\r\n \r\n \r\n class DeviceController:\r\n-    def __init__(self):\r\n-        self.screenshot_cache = {}\r\n-        self.last_screenshot_time = {}\r\n-        self.device_compatibility = {}\r\n-        self.fallback_count = {}\r\n-        self._memory_success_logged = False\r\n+    \"\"\"ADB経由でAndroidデバイスを制御するクラス\"\"\"\r\n+    \r\n+    def __init__(self, device_id: str = None):\r\n+        self.device_id = device_id\r\n+        self.logger = logging.getLogger(__name__)\r\n+        self.executor = ThreadPoolExecutor(max_workers=4)\r\n         \r\n-    def refresh_devices(self):\r\n-        \"\"\"ADBデバイスを更新\"\"\"\r\n+    def get_connected_devices(self) -> List[str]:\r\n+        \"\"\"接続されているデバイス一覧を取得\"\"\"\r\n         try:\r\n-            result = subprocess.run(['adb', 'devices'], capture_output=True, text=True)\r\n-            lines = result.stdout.strip().split('\\n')[1:]  # ヘッダーを除く\r\n-            \r\n+            result = subprocess.run(['adb', 'devices'], \r\n+                                 capture_output=True, text=True, timeout=10)\r\n             devices = []\r\n+            lines = result.stdout.strip().split('\\n')[1:]  # ヘッダー行をスキップ\r\n             for line in lines:\r\n                 if line.strip() and 'device' in line:\r\n                     device_id = line.split('\\t')[0]\r\n                     devices.append(device_id)\r\n-            \r\n             return devices\r\n-            \r\n         except Exception as e:\r\n-            print(f\"デバイス検出エラー: {str(e)}\")\r\n+            self.logger.error(f\"デバイス取得エラー: {e}\")\r\n             return []\r\n     \r\n-    def smart_tap_screen(self, x, y, device_id, tap_type=\"normal\", delay_multiplier=1.0):\r\n-        \"\"\"スマートタップ機能（タップ種類に応じて遅延を調整）\"\"\"\r\n+    def connect_device(self, device_id: str) -> bool:\r\n+        \"\"\"指定されたデバイスに接続\"\"\"\r\n         try:\r\n-            subprocess.run(['adb', '-s', device_id, 'shell', 'input', 'tap', str(x), str(y)], \r\n-                         check=True, capture_output=True)\r\n-            \r\n-            # タップ種類に応じた遅延\r\n-            base_delay = 0.3\r\n-            if tap_type == \"boss\":\r\n-                time.sleep(base_delay * 1.5 * delay_multiplier)\r\n-            elif tap_type == \"play\":\r\n-                time.sleep(base_delay * 2.0 * delay_multiplier)\r\n-            elif tap_type == \"puzzle\":\r\n-                time.sleep(base_delay * 0.8 * delay_multiplier)\r\n-            elif tap_type == \"close\":\r\n-                time.sleep(base_delay * 0.5 * delay_multiplier)\r\n-            else:\r\n-                time.sleep(base_delay * delay_multiplier)\r\n-            \r\n-            return True\r\n+            if device_id in self.get_connected_devices():\r\n+                self.device_id = device_id\r\n+                self.logger.info(f\"デバイス {device_id} に接続しました\")\r\n+                return True\r\n+            return False\r\n         except Exception as e:\r\n-            print(f\"タップエラー: {str(e)}\")\r\n+            self.logger.error(f\"デバイス接続エラー: {e}\")\r\n             return False\r\n     \r\n-    def take_screenshot_fast(self, device_id):\r\n-        \"\"\"高速ファイルベーススクリーンショット\"\"\"\r\n+    def get_screen_size(self) -> Tuple[int, int]:\r\n+        \"\"\"画面サイズを取得\"\"\"\r\n         try:\r\n-            # テンポラリファイル名を使用\r\n-            temp_name = f'/sdcard/temp_screenshot_{int(time.time() * 1000) % 10000}.png'\r\n-            local_path = f'temp_screenshot_{device_id}.png'\r\n+            cmd = ['adb']\r\n+            if self.device_id:\r\n+                cmd.extend(['-s', self.device_id])\r\n+            cmd.extend(['shell', 'wm', 'size'])\r\n             \r\n-            # 高速スクリーンショット取得\r\n-            subprocess.run(['adb', '-s', device_id, 'shell', 'screencap', temp_name], \r\n-                         check=True, capture_output=True, timeout=3)\r\n-            subprocess.run(['adb', '-s', device_id, 'pull', temp_name, local_path], \r\n-                         check=True, capture_output=True, timeout=3)\r\n-            \r\n-            # デバイス上のテンポラリファイルを削除\r\n-            subprocess.run(['adb', '-s', device_id, 'shell', 'rm', temp_name], \r\n-                         capture_output=True, timeout=1)\r\n-            \r\n-            return local_path\r\n-            \r\n-        except (subprocess.TimeoutExpired, subprocess.CalledProcessError) as e:\r\n-            print(f\"高速スクリーンショットエラー: {str(e)}\")\r\n-            return None\r\n+            result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)\r\n+            if result.returncode == 0:\r\n+                # \"Physical size: 1080x1920\" の形式\r\n+                size_str = result.stdout.strip().split(': ')[1]\r\n+                width, height = map(int, size_str.split('x'))\r\n+                return width, height\r\n+            return 1080, 1920  # デフォルト値\r\n+        except Exception as e:\r\n+            self.logger.error(f\"画面サイズ取得エラー: {e}\")\r\n+            return 1080, 1920\r\n     \r\n-    def get_memory_screenshot(self, device_id):\r\n-        \"\"\"メモリから直接スクリーンショットを取得（改良版）\"\"\"\r\n+    def capture_screen(self) -> bytes:\r\n+        \"\"\"画面キャプチャを取得（バイナリデータ）\"\"\"\r\n         try:\r\n-            # 方法1: ADB exec-outを使用してRAWデータを直接取得\r\n-            result = subprocess.run([\r\n-                'adb', '-s', device_id, 'exec-out', 'screencap'\r\n-            ], capture_output=True, timeout=3)\r\n+            cmd = ['adb']\r\n+            if self.device_id:\r\n+                cmd.extend(['-s', self.device_id])\r\n+            cmd.extend(['exec-out', 'screencap', '-p'])\r\n             \r\n-            if result.returncode == 0 and len(result.stdout) > 0:\r\n-                raw_data = result.stdout\r\n-                \r\n-                # PNGヘッダーをチェック\r\n-                if raw_data[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n-                    # PNG形式の場合\r\n-                    nparr = np.frombuffer(raw_data, np.uint8)\r\n-                    screenshot = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\r\n-                    if screenshot is not None:\r\n-                        return screenshot\r\n-                \r\n-                # RAW形式の場合のパース（Android 4.4以降）\r\n-                if len(raw_data) >= 12:\r\n-                    # ヘッダー情報を解析\r\n-                    width = struct.unpack('<I', raw_data[0:4])[0]\r\n-                    height = struct.unpack('<I', raw_data[4:8])[0]\r\n-                    pixel_format = struct.unpack('<I', raw_data[8:12])[0]\r\n-                    \r\n-                    # 妥当性チェック\r\n-                    if 100 <= width <= 4096 and 100 <= height <= 4096:\r\n-                        if pixel_format == 1:  # RGBA_8888\r\n-                            expected_size = width * height * 4 + 12\r\n-                            if len(raw_data) >= expected_size:\r\n-                                # RGBA データを抽出\r\n-                                image_data = raw_data[12:12 + width * height * 4]\r\n-                                # numpy配列に変換\r\n-                                img_array = np.frombuffer(image_data, dtype=np.uint8)\r\n-                                img_array = img_array.reshape((height, width, 4))\r\n-                                # BGRAからBGRに変換（Alphaチャンネル削除）\r\n-                                screenshot = cv2.cvtColor(img_array, cv2.COLOR_RGBA2BGR)\r\n-                                return screenshot\r\n-            \r\n-            # 方法2: shellコマンドでscreencapを実行してファイル取得を避ける\r\n-            result2 = subprocess.run([\r\n-                'adb', '-s', device_id, 'shell', 'screencap', '-p'\r\n-            ], capture_output=True, timeout=3)\r\n-            \r\n-            if result2.returncode == 0 and len(result2.stdout) > 0:\r\n-                # base64形式でない場合の処理\r\n-                raw_data = result2.stdout\r\n-                if raw_data[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n-                    nparr = np.frombuffer(raw_data, np.uint8)\r\n-                    screenshot = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\r\n-                    if screenshot is not None:\r\n-                        return screenshot\r\n-                        \r\n-            return None\r\n-            \r\n-        except subprocess.TimeoutExpired:\r\n-            print(f\"メモリキャプチャタイムアウト\")\r\n-            return None\r\n+            result = subprocess.run(cmd, capture_output=True, timeout=3)\r\n+            if result.returncode == 0:\r\n+                return result.stdout\r\n+            return b''\r\n         except Exception as e:\r\n-            print(f\"メモリキャプチャエラー: {str(e)}\")\r\n-            return None\r\n+            self.logger.error(f\"画面キャプチャエラー: {e}\")\r\n+            return b''\r\n     \r\n-    def fast_screenshot_to_memory(self, device_id, use_memory_capture=True):\r\n-        \"\"\"高速スクリーンショット（メモリ直接 or ファイル）改良版\"\"\"\r\n-        # 互換性チェック\r\n-        if device_id not in self.device_compatibility:\r\n-            self.check_device_compatibility(device_id)\r\n-        \r\n-        # メモリ直接取得を試行（サポートされている場合のみ）\r\n-        if (use_memory_capture and \r\n-            self.device_compatibility.get(device_id, {}).get('memory_capture_supported', False)):\r\n-            \r\n-            screenshot = self.get_memory_screenshot(device_id)\r\n-            if screenshot is not None:\r\n-                # メモリ取得成功のログ（初回のみ）\r\n-                if not self._memory_success_logged:\r\n-                    print(f\"メモリ直接取得成功\")\r\n-                    self._memory_success_logged = True\r\n-                return screenshot\r\n-            else:\r\n-                # フォールバック回数を記録\r\n-                self.fallback_count[device_id] = self.fallback_count.get(device_id, 0) + 1\r\n-                \r\n-                # 連続失敗時は一時的にメモリ取得を無効化\r\n-                if self.fallback_count[device_id] >= 5:\r\n-                    self.device_compatibility[device_id]['memory_capture_supported'] = False\r\n-                    print(\"メモリ取得を一時無効化（連続失敗）\")\r\n-        \r\n-        # 従来のファイル方式（高速化版）\r\n-        screenshot_path = self.take_screenshot_fast(device_id)\r\n-        if screenshot_path:\r\n-            return cv2.imread(screenshot_path)\r\n-        \r\n-        return None\r\n+    async def capture_screen_async(self) -> bytes:\r\n+        \"\"\"非同期で画面キャプチャを取得\"\"\"\r\n+        loop = asyncio.get_event_loop()\r\n+        return await loop.run_in_executor(self.executor, self.capture_screen)\r\n     \r\n-    def check_device_compatibility(self, device_id):\r\n-        \"\"\"デバイスの互換性チェック\"\"\"\r\n-        if device_id in self.device_compatibility:\r\n-            return self.device_compatibility[device_id]\r\n-        \r\n-        compatibility = {\r\n-            'exec_out_supported': False,\r\n-            'android_version': 'unknown',\r\n-            'memory_capture_supported': False,\r\n-            'reason': ''\r\n-        }\r\n-        \r\n+    def tap(self, x: int, y: int) -> bool:\r\n+        \"\"\"指定座標をタップ\"\"\"\r\n         try:\r\n-            # Androidバージョンを取得\r\n-            result = subprocess.run(['adb', '-s', device_id, 'shell', 'getprop', 'ro.build.version.release'],\r\n-                                  capture_output=True, text=True, timeout=10)\r\n-            if result.returncode == 0:\r\n-                compatibility['android_version'] = result.stdout.strip()\r\n+            cmd = ['adb']\r\n+            if self.device_id:\r\n+                cmd.extend(['-s', self.device_id])\r\n+            cmd.extend(['shell', 'input', 'tap', str(x), str(y)])\r\n             \r\n-            # exec-out screencapコマンドの動作テスト\r\n-            result = subprocess.run(['adb', '-s', device_id, 'exec-out', 'screencap', '-p'],\r\n-                                  capture_output=True, timeout=15)\r\n-            \r\n-            if result.returncode == 0 and len(result.stdout) > 1000:  # 最小限の画像データサイズ\r\n-                compatibility['exec_out_supported'] = True\r\n-                compatibility['memory_capture_supported'] = True\r\n-                compatibility['reason'] = 'Memory capture fully supported'\r\n-            else:\r\n-                compatibility['reason'] = f'exec-out failed (returncode: {result.returncode})'\r\n-                \r\n-        except subprocess.TimeoutExpired:\r\n-            compatibility['reason'] = 'Command timeout'\r\n+            result = subprocess.run(cmd, capture_output=True, timeout=2)\r\n+            return result.returncode == 0\r\n         except Exception as e:\r\n-            compatibility['reason'] = f'Error: {str(e)}'\r\n-        \r\n-        self.device_compatibility[device_id] = compatibility\r\n-        return compatibility\r\n+            self.logger.error(f\"タップエラー: {e}\")\r\n+            return False\r\n     \r\n-    def diagnostic_memory_capture(self, device_id):\r\n-        \"\"\"メモリ直接取得の診断情報を表示\"\"\"\r\n-        results = []\r\n-        results.append(\"=== メモリ直接取得診断 ===\")\r\n-        \r\n+    async def tap_async(self, x: int, y: int) -> bool:\r\n+        \"\"\"非同期でタップ\"\"\"\r\n+        loop = asyncio.get_event_loop()\r\n+        return await loop.run_in_executor(self.executor, self.tap, x, y)\r\n+    \r\n+    def swipe(self, x1: int, y1: int, x2: int, y2: int, duration: int = 300) -> bool:\r\n+        \"\"\"スワイプ動作\"\"\"\r\n         try:\r\n-            # 1. デバイス情報取得\r\n-            info_cmd = ['adb', '-s', device_id, 'shell', 'getprop']\r\n-            result = subprocess.run(info_cmd, capture_output=True, text=True, timeout=5)\r\n-            if result.returncode == 0:\r\n-                lines = result.stdout.split('\\n')\r\n-                for line in lines:\r\n-                    if 'ro.build.version.release' in line or 'ro.build.version.sdk' in line:\r\n-                        results.append(f\"デバイス情報: {line.strip()}\")\r\n+            cmd = ['adb']\r\n+            if self.device_id:\r\n+                cmd.extend(['-s', self.device_id])\r\n+            cmd.extend(['shell', 'input', 'swipe', str(x1), str(y1), str(x2), str(y2), str(duration)])\r\n             \r\n-            # 2. exec-outコマンドのサポート確認\r\n-            test_cmd = ['adb', '-s', device_id, 'exec-out', 'echo', 'test']\r\n-            result = subprocess.run(test_cmd, capture_output=True, timeout=3)\r\n-            if result.returncode == 0:\r\n-                results.append(\"exec-out コマンド: サポート\")\r\n-            else:\r\n-                results.append(f\"exec-out コマンド: 非サポート (code: {result.returncode})\")\r\n-            \r\n-            # 3. screencapコマンドの直接実行\r\n-            screencap_cmd = ['adb', '-s', device_id, 'shell', 'screencap', '-h']\r\n-            result = subprocess.run(screencap_cmd, capture_output=True, text=True, timeout=3)\r\n-            if result.returncode == 0:\r\n-                results.append(\"screencap コマンド: 利用可能\")\r\n-            else:\r\n-                results.append(f\"screencap コマンド: エラー (code: {result.returncode})\")\r\n-            \r\n-            # 4. 実際のメモリ取得を試行\r\n-            memory_cmd = ['adb', '-s', device_id, 'exec-out', 'screencap']\r\n-            result = subprocess.run(memory_cmd, capture_output=True, timeout=5)\r\n-            \r\n-            if result.returncode == 0:\r\n-                data_size = len(result.stdout)\r\n-                results.append(f\"メモリ取得: 成功 (データサイズ: {data_size} bytes)\")\r\n-                \r\n-                if data_size > 0:\r\n-                    # データ形式を確認\r\n-                    header = result.stdout[:16]\r\n-                    results.append(f\"データヘッダー: {header}\")\r\n-                    \r\n-                    if header[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n-                        results.append(\"データ形式: PNG\")\r\n-                    else:\r\n-                        results.append(\"データ形式: RAW (もしくは不明)\")\r\n-                else:\r\n-                    results.append(\"メモリ取得: データが空\")\r\n-            else:\r\n-                results.append(f\"メモリ取得: 失敗 (code: {result.returncode})\")\r\n-                if result.stderr:\r\n-                    error_msg = result.stderr.decode('utf-8', errors='ignore')\r\n-                    results.append(f\"エラー詳細: {error_msg}\")\r\n-            \r\n+            result = subprocess.run(cmd, capture_output=True, timeout=3)\r\n+            return result.returncode == 0\r\n         except Exception as e:\r\n-            results.append(f\"診断エラー: {str(e)}\")\r\n+            self.logger.error(f\"スワイプエラー: {e}\")\r\n+            return False\r\n+\r\n+\r\n+class MultiDeviceController:\r\n+    \"\"\"複数デバイスを同時制御するクラス\"\"\"\r\n+    \r\n+    def __init__(self):\r\n+        self.devices = {}\r\n+        self.logger = logging.getLogger(__name__)\r\n         \r\n-        results.append(\"=== 診断終了 ===\")\r\n+    def add_device(self, device_id: str) -> bool:\r\n+        \"\"\"デバイスを追加\"\"\"\r\n+        controller = DeviceController(device_id)\r\n+        if controller.connect_device(device_id):\r\n+            self.devices[device_id] = controller\r\n+            return True\r\n+        return False\r\n+    \r\n+    def remove_device(self, device_id: str):\r\n+        \"\"\"デバイスを削除\"\"\"\r\n+        if device_id in self.devices:\r\n+            del self.devices[device_id]\r\n+    \r\n+    def get_device_list(self) -> List[str]:\r\n+        \"\"\"管理中のデバイス一覧を取得\"\"\"\r\n+        return list(self.devices.keys())\r\n+    \r\n+    async def capture_all_screens(self) -> dict:\r\n+        \"\"\"全デバイスの画面を同時キャプチャ\"\"\"\r\n+        tasks = []\r\n+        for device_id, controller in self.devices.items():\r\n+            task = controller.capture_screen_async()\r\n+            tasks.append((device_id, task))\r\n+        \r\n+        results = {}\r\n+        for device_id, task in tasks:\r\n+            try:\r\n+                screen_data = await task\r\n+                results[device_id] = screen_data\r\n+            except Exception as e:\r\n+                self.logger.error(f\"デバイス {device_id} のキャプチャエラー: {e}\")\r\n+                results[device_id] = b''\r\n+        \r\n         return results\r\n+    \r\n+    async def tap_all_devices(self, coordinates: dict) -> dict:\r\n+        \"\"\"全デバイスで同時タップ\"\"\"\r\n+        tasks = []\r\n+        for device_id, controller in self.devices.items():\r\n+            if device_id in coordinates:\r\n+                x, y = coordinates[device_id]\r\n+                task = controller.tap_async(x, y)\r\n+                tasks.append((device_id, task))\r\n+        \r\n+        results = {}\r\n+        for device_id, task in tasks:\r\n+            try:\r\n+                success = await task\r\n+                results[device_id] = success\r\n+            except Exception as e:\r\n+                self.logger.error(f\"デバイス {device_id} のタップエラー: {e}\")\r\n+                results[device_id] = False\r\n+        \r\n+        return results\r\n"
                },
                {
                    "date": 1750517161025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,180 +1,184 @@\n import subprocess\r\n+import cv2\r\n+import numpy as np\r\n+import tempfile\r\n+import os\r\n import time\r\n-import logging\r\n-from typing import List, Tuple, Optional\r\n-import threading\r\n-import asyncio\r\n-from concurrent.futures import ThreadPoolExecutor\r\n \r\n-\r\n class DeviceController:\r\n-    \"\"\"ADB経由でAndroidデバイスを制御するクラス\"\"\"\r\n-    \r\n-    def __init__(self, device_id: str = None):\r\n-        self.device_id = device_id\r\n-        self.logger = logging.getLogger(__name__)\r\n-        self.executor = ThreadPoolExecutor(max_workers=4)\r\n+    def __init__(self):\r\n+        self.current_device = None\r\n+        self.adb_path = \"adb\"  # ADBのパス\r\n         \r\n-    def get_connected_devices(self) -> List[str]:\r\n-        \"\"\"接続されているデバイス一覧を取得\"\"\"\r\n+    def set_device(self, device):\r\n+        \"\"\"使用するデバイスの設定\"\"\"\r\n+        self.current_device = device\r\n+        \r\n+    def get_devices(self):\r\n+        \"\"\"接続されているデバイスのリストを取得\"\"\"\r\n         try:\r\n-            result = subprocess.run(['adb', 'devices'], \r\n-                                 capture_output=True, text=True, timeout=10)\r\n+            result = subprocess.run([self.adb_path, \"devices\"], \r\n+                                  capture_output=True, text=True, timeout=10)\r\n+            \r\n+            if result.returncode != 0:\r\n+                return []\r\n+                \r\n             devices = []\r\n-            lines = result.stdout.strip().split('\\n')[1:]  # ヘッダー行をスキップ\r\n+            lines = result.stdout.strip().split('\\n')[1:]  # 最初の行はヘッダーなのでスキップ\r\n+            \r\n             for line in lines:\r\n-                if line.strip() and 'device' in line:\r\n+                if line.strip() and '\\tdevice' in line:\r\n                     device_id = line.split('\\t')[0]\r\n                     devices.append(device_id)\r\n+                    \r\n             return devices\r\n+            \r\n         except Exception as e:\r\n-            self.logger.error(f\"デバイス取得エラー: {e}\")\r\n+            print(f\"デバイス取得エラー: {str(e)}\")\r\n             return []\r\n-    \r\n-    def connect_device(self, device_id: str) -> bool:\r\n-        \"\"\"指定されたデバイスに接続\"\"\"\r\n+            \r\n+    def get_screenshot(self):\r\n+        \"\"\"スクリーンショットの取得\"\"\"\r\n+        if not self.current_device:\r\n+            raise Exception(\"デバイスが設定されていません\")\r\n+            \r\n         try:\r\n-            if device_id in self.get_connected_devices():\r\n-                self.device_id = device_id\r\n-                self.logger.info(f\"デバイス {device_id} に接続しました\")\r\n-                return True\r\n-            return False\r\n+            # 一時ファイルを作成\r\n+            with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as temp_file:\r\n+                temp_path = temp_file.name\r\n+                \r\n+            try:\r\n+                # ADBコマンドでスクリーンショットを取得\r\n+                cmd = [self.adb_path, \"-s\", self.current_device, \"exec-out\", \"screencap\", \"-p\"]\r\n+                result = subprocess.run(cmd, capture_output=True, timeout=15)\r\n+                \r\n+                if result.returncode != 0:\r\n+                    raise Exception(f\"スクリーンショット取得失敗: {result.stderr.decode()}\")\r\n+                    \r\n+                # 画像データを一時ファイルに保存\r\n+                with open(temp_path, 'wb') as f:\r\n+                    f.write(result.stdout)\r\n+                    \r\n+                # OpenCVで画像を読み込み\r\n+                screenshot = cv2.imread(temp_path)\r\n+                \r\n+                if screenshot is None:\r\n+                    raise Exception(\"スクリーンショットの読み込みに失敗しました\")\r\n+                    \r\n+                return screenshot\r\n+                \r\n+            finally:\r\n+                # 一時ファイルを削除\r\n+                if os.path.exists(temp_path):\r\n+                    os.unlink(temp_path)\r\n+                    \r\n+        except subprocess.TimeoutExpired:\r\n+            raise Exception(\"スクリーンショット取得がタイムアウトしました\")\r\n         except Exception as e:\r\n-            self.logger.error(f\"デバイス接続エラー: {e}\")\r\n-            return False\r\n-    \r\n-    def get_screen_size(self) -> Tuple[int, int]:\r\n-        \"\"\"画面サイズを取得\"\"\"\r\n+            raise Exception(f\"スクリーンショット取得エラー: {str(e)}\")\r\n+            \r\n+    def tap(self, x, y):\r\n+        \"\"\"指定座標をタップ\"\"\"\r\n+        if not self.current_device:\r\n+            raise Exception(\"デバイスが設定されていません\")\r\n+            \r\n         try:\r\n-            cmd = ['adb']\r\n-            if self.device_id:\r\n-                cmd.extend(['-s', self.device_id])\r\n-            cmd.extend(['shell', 'wm', 'size'])\r\n+            cmd = [self.adb_path, \"-s\", self.current_device, \"shell\", \"input\", \"tap\", str(x), str(y)]\r\n+            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)\r\n             \r\n-            result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)\r\n-            if result.returncode == 0:\r\n-                # \"Physical size: 1080x1920\" の形式\r\n-                size_str = result.stdout.strip().split(': ')[1]\r\n-                width, height = map(int, size_str.split('x'))\r\n-                return width, height\r\n-            return 1080, 1920  # デフォルト値\r\n+            if result.returncode != 0:\r\n+                raise Exception(f\"タップ失敗: {result.stderr}\")\r\n+                \r\n+            return True\r\n+            \r\n+        except subprocess.TimeoutExpired:\r\n+            raise Exception(\"タップコマンドがタイムアウトしました\")\r\n         except Exception as e:\r\n-            self.logger.error(f\"画面サイズ取得エラー: {e}\")\r\n-            return 1080, 1920\r\n-    \r\n-    def capture_screen(self) -> bytes:\r\n-        \"\"\"画面キャプチャを取得（バイナリデータ）\"\"\"\r\n+            raise Exception(f\"タップエラー: {str(e)}\")\r\n+            \r\n+    def swipe(self, x1, y1, x2, y2, duration=500):\r\n+        \"\"\"スワイプ操作\"\"\"\r\n+        if not self.current_device:\r\n+            raise Exception(\"デバイスが設定されていません\")\r\n+            \r\n         try:\r\n-            cmd = ['adb']\r\n-            if self.device_id:\r\n-                cmd.extend(['-s', self.device_id])\r\n-            cmd.extend(['exec-out', 'screencap', '-p'])\r\n+            cmd = [self.adb_path, \"-s\", self.current_device, \"shell\", \"input\", \"swipe\", \r\n+                   str(x1), str(y1), str(x2), str(y2), str(duration)]\r\n+            result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)\r\n             \r\n-            result = subprocess.run(cmd, capture_output=True, timeout=3)\r\n-            if result.returncode == 0:\r\n-                return result.stdout\r\n-            return b''\r\n+            if result.returncode != 0:\r\n+                raise Exception(f\"スワイプ失敗: {result.stderr}\")\r\n+                \r\n+            return True\r\n+            \r\n+        except subprocess.TimeoutExpired:\r\n+            raise Exception(\"スワイプコマンドがタイムアウトしました\")\r\n         except Exception as e:\r\n-            self.logger.error(f\"画面キャプチャエラー: {e}\")\r\n-            return b''\r\n-    \r\n-    async def capture_screen_async(self) -> bytes:\r\n-        \"\"\"非同期で画面キャプチャを取得\"\"\"\r\n-        loop = asyncio.get_event_loop()\r\n-        return await loop.run_in_executor(self.executor, self.capture_screen)\r\n-    \r\n-    def tap(self, x: int, y: int) -> bool:\r\n-        \"\"\"指定座標をタップ\"\"\"\r\n+            raise Exception(f\"スワイプエラー: {str(e)}\")\r\n+            \r\n+    def get_screen_size(self):\r\n+        \"\"\"画面サイズの取得\"\"\"\r\n+        if not self.current_device:\r\n+            raise Exception(\"デバイスが設定されていません\")\r\n+            \r\n         try:\r\n-            cmd = ['adb']\r\n-            if self.device_id:\r\n-                cmd.extend(['-s', self.device_id])\r\n-            cmd.extend(['shell', 'input', 'tap', str(x), str(y)])\r\n+            cmd = [self.adb_path, \"-s\", self.current_device, \"shell\", \"wm\", \"size\"]\r\n+            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)\r\n             \r\n-            result = subprocess.run(cmd, capture_output=True, timeout=2)\r\n+            if result.returncode != 0:\r\n+                raise Exception(f\"画面サイズ取得失敗: {result.stderr}\")\r\n+                \r\n+            # 出力例: \"Physical size: 1080x1920\"\r\n+            output = result.stdout.strip()\r\n+            size_part = output.split(\": \")[1]\r\n+            width, height = map(int, size_part.split(\"x\"))\r\n+            \r\n+            return width, height\r\n+            \r\n+        except Exception as e:\r\n+            raise Exception(f\"画面サイズ取得エラー: {str(e)}\")\r\n+            \r\n+    def is_device_connected(self, device_id):\r\n+        \"\"\"デバイスが接続されているかチェック\"\"\"\r\n+        devices = self.get_devices()\r\n+        return device_id in devices\r\n+        \r\n+    def wait_for_device(self, timeout=30):\r\n+        \"\"\"デバイスの接続を待機\"\"\"\r\n+        if not self.current_device:\r\n+            raise Exception(\"デバイスが設定されていません\")\r\n+            \r\n+        start_time = time.time()\r\n+        \r\n+        while time.time() - start_time < timeout:\r\n+            if self.is_device_connected(self.current_device):\r\n+                return True\r\n+            time.sleep(1)\r\n+            \r\n+        return False\r\n+        \r\n+    def check_adb_connection(self):\r\n+        \"\"\"ADB接続の確認\"\"\"\r\n+        try:\r\n+            result = subprocess.run([self.adb_path, \"version\"], \r\n+                                  capture_output=True, text=True, timeout=5)\r\n             return result.returncode == 0\r\n-        except Exception as e:\r\n-            self.logger.error(f\"タップエラー: {e}\")\r\n+        except:\r\n             return False\r\n-    \r\n-    async def tap_async(self, x: int, y: int) -> bool:\r\n-        \"\"\"非同期でタップ\"\"\"\r\n-        loop = asyncio.get_event_loop()\r\n-        return await loop.run_in_executor(self.executor, self.tap, x, y)\r\n-    \r\n-    def swipe(self, x1: int, y1: int, x2: int, y2: int, duration: int = 300) -> bool:\r\n-        \"\"\"スワイプ動作\"\"\"\r\n+            \r\n+    def restart_adb_server(self):\r\n+        \"\"\"ADBサーバーの再起動\"\"\"\r\n         try:\r\n-            cmd = ['adb']\r\n-            if self.device_id:\r\n-                cmd.extend(['-s', self.device_id])\r\n-            cmd.extend(['shell', 'input', 'swipe', str(x1), str(y1), str(x2), str(y2), str(duration)])\r\n+            # ADBサーバーを停止\r\n+            subprocess.run([self.adb_path, \"kill-server\"], \r\n+                          capture_output=True, timeout=10)\r\n             \r\n-            result = subprocess.run(cmd, capture_output=True, timeout=3)\r\n+            # ADBサーバーを開始\r\n+            result = subprocess.run([self.adb_path, \"start-server\"], \r\n+                                  capture_output=True, timeout=10)\r\n+            \r\n             return result.returncode == 0\r\n+            \r\n         except Exception as e:\r\n-            self.logger.error(f\"スワイプエラー: {e}\")\r\n+            print(f\"ADBサーバー再起動エラー: {str(e)}\")\r\n             return False\r\n-\r\n-\r\n-class MultiDeviceController:\r\n-    \"\"\"複数デバイスを同時制御するクラス\"\"\"\r\n-    \r\n-    def __init__(self):\r\n-        self.devices = {}\r\n-        self.logger = logging.getLogger(__name__)\r\n-        \r\n-    def add_device(self, device_id: str) -> bool:\r\n-        \"\"\"デバイスを追加\"\"\"\r\n-        controller = DeviceController(device_id)\r\n-        if controller.connect_device(device_id):\r\n-            self.devices[device_id] = controller\r\n-            return True\r\n-        return False\r\n-    \r\n-    def remove_device(self, device_id: str):\r\n-        \"\"\"デバイスを削除\"\"\"\r\n-        if device_id in self.devices:\r\n-            del self.devices[device_id]\r\n-    \r\n-    def get_device_list(self) -> List[str]:\r\n-        \"\"\"管理中のデバイス一覧を取得\"\"\"\r\n-        return list(self.devices.keys())\r\n-    \r\n-    async def capture_all_screens(self) -> dict:\r\n-        \"\"\"全デバイスの画面を同時キャプチャ\"\"\"\r\n-        tasks = []\r\n-        for device_id, controller in self.devices.items():\r\n-            task = controller.capture_screen_async()\r\n-            tasks.append((device_id, task))\r\n-        \r\n-        results = {}\r\n-        for device_id, task in tasks:\r\n-            try:\r\n-                screen_data = await task\r\n-                results[device_id] = screen_data\r\n-            except Exception as e:\r\n-                self.logger.error(f\"デバイス {device_id} のキャプチャエラー: {e}\")\r\n-                results[device_id] = b''\r\n-        \r\n-        return results\r\n-    \r\n-    async def tap_all_devices(self, coordinates: dict) -> dict:\r\n-        \"\"\"全デバイスで同時タップ\"\"\"\r\n-        tasks = []\r\n-        for device_id, controller in self.devices.items():\r\n-            if device_id in coordinates:\r\n-                x, y = coordinates[device_id]\r\n-                task = controller.tap_async(x, y)\r\n-                tasks.append((device_id, task))\r\n-        \r\n-        results = {}\r\n-        for device_id, task in tasks:\r\n-            try:\r\n-                success = await task\r\n-                results[device_id] = success\r\n-            except Exception as e:\r\n-                self.logger.error(f\"デバイス {device_id} のタップエラー: {e}\")\r\n-                results[device_id] = False\r\n-        \r\n-        return results\r\n"
                }
            ],
            "date": 1750493481589,
            "name": "Commit-0",
            "content": "\"\"\"\r\nデバイス制御機能モジュール\r\nADB操作、スクリーンショット取得、タップ操作などのデバイス制御機能\r\n\"\"\"\r\n\r\nimport subprocess\r\nimport cv2\r\nimport numpy as np\r\nimport time\r\nimport struct\r\n\r\n\r\nclass DeviceController:\r\n    def __init__(self):\r\n        self.screenshot_cache = {}\r\n        self.last_screenshot_time = {}\r\n        self.device_compatibility = {}\r\n        self.fallback_count = {}\r\n        self._memory_success_logged = False\r\n        \r\n    def refresh_devices(self):\r\n        \"\"\"ADBデバイスを更新\"\"\"\r\n        try:\r\n            result = subprocess.run(['adb', 'devices'], capture_output=True, text=True)\r\n            lines = result.stdout.strip().split('\\n')[1:]  # ヘッダーを除く\r\n            \r\n            devices = []\r\n            for line in lines:\r\n                if line.strip() and 'device' in line:\r\n                    device_id = line.split('\\t')[0]\r\n                    devices.append(device_id)\r\n            \r\n            return devices\r\n            \r\n        except Exception as e:\r\n            print(f\"デバイス検出エラー: {str(e)}\")\r\n            return []\r\n    \r\n    def smart_tap_screen(self, x, y, device_id, tap_type=\"normal\", delay_multiplier=1.0):\r\n        \"\"\"スマートタップ機能（タップ種類に応じて遅延を調整）\"\"\"\r\n        try:\r\n            subprocess.run(['adb', '-s', device_id, 'shell', 'input', 'tap', str(x), str(y)], \r\n                         check=True, capture_output=True)\r\n            \r\n            # タップ種類に応じた遅延\r\n            base_delay = 0.3\r\n            if tap_type == \"boss\":\r\n                time.sleep(base_delay * 1.5 * delay_multiplier)\r\n            elif tap_type == \"play\":\r\n                time.sleep(base_delay * 2.0 * delay_multiplier)\r\n            elif tap_type == \"puzzle\":\r\n                time.sleep(base_delay * 0.8 * delay_multiplier)\r\n            elif tap_type == \"close\":\r\n                time.sleep(base_delay * 0.5 * delay_multiplier)\r\n            else:\r\n                time.sleep(base_delay * delay_multiplier)\r\n            \r\n            return True\r\n        except Exception as e:\r\n            print(f\"タップエラー: {str(e)}\")\r\n            return False\r\n    \r\n    def take_screenshot_fast(self, device_id):\r\n        \"\"\"高速ファイルベーススクリーンショット\"\"\"\r\n        try:\r\n            # テンポラリファイル名を使用\r\n            temp_name = f'/sdcard/temp_screenshot_{int(time.time() * 1000) % 10000}.png'\r\n            local_path = f'temp_screenshot_{device_id}.png'\r\n            \r\n            # 高速スクリーンショット取得\r\n            subprocess.run(['adb', '-s', device_id, 'shell', 'screencap', temp_name], \r\n                         check=True, capture_output=True, timeout=3)\r\n            subprocess.run(['adb', '-s', device_id, 'pull', temp_name, local_path], \r\n                         check=True, capture_output=True, timeout=3)\r\n            \r\n            # デバイス上のテンポラリファイルを削除\r\n            subprocess.run(['adb', '-s', device_id, 'shell', 'rm', temp_name], \r\n                         capture_output=True, timeout=1)\r\n            \r\n            return local_path\r\n            \r\n        except (subprocess.TimeoutExpired, subprocess.CalledProcessError) as e:\r\n            print(f\"高速スクリーンショットエラー: {str(e)}\")\r\n            return None\r\n    \r\n    def get_memory_screenshot(self, device_id):\r\n        \"\"\"メモリから直接スクリーンショットを取得（改良版）\"\"\"\r\n        try:\r\n            # 方法1: ADB exec-outを使用してRAWデータを直接取得\r\n            result = subprocess.run([\r\n                'adb', '-s', device_id, 'exec-out', 'screencap'\r\n            ], capture_output=True, timeout=3)\r\n            \r\n            if result.returncode == 0 and len(result.stdout) > 0:\r\n                raw_data = result.stdout\r\n                \r\n                # PNGヘッダーをチェック\r\n                if raw_data[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n                    # PNG形式の場合\r\n                    nparr = np.frombuffer(raw_data, np.uint8)\r\n                    screenshot = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\r\n                    if screenshot is not None:\r\n                        return screenshot\r\n                \r\n                # RAW形式の場合のパース（Android 4.4以降）\r\n                if len(raw_data) >= 12:\r\n                    # ヘッダー情報を解析\r\n                    width = struct.unpack('<I', raw_data[0:4])[0]\r\n                    height = struct.unpack('<I', raw_data[4:8])[0]\r\n                    pixel_format = struct.unpack('<I', raw_data[8:12])[0]\r\n                    \r\n                    # 妥当性チェック\r\n                    if 100 <= width <= 4096 and 100 <= height <= 4096:\r\n                        if pixel_format == 1:  # RGBA_8888\r\n                            expected_size = width * height * 4 + 12\r\n                            if len(raw_data) >= expected_size:\r\n                                # RGBA データを抽出\r\n                                image_data = raw_data[12:12 + width * height * 4]\r\n                                # numpy配列に変換\r\n                                img_array = np.frombuffer(image_data, dtype=np.uint8)\r\n                                img_array = img_array.reshape((height, width, 4))\r\n                                # BGRAからBGRに変換（Alphaチャンネル削除）\r\n                                screenshot = cv2.cvtColor(img_array, cv2.COLOR_RGBA2BGR)\r\n                                return screenshot\r\n            \r\n            # 方法2: shellコマンドでscreencapを実行してファイル取得を避ける\r\n            result2 = subprocess.run([\r\n                'adb', '-s', device_id, 'shell', 'screencap', '-p'\r\n            ], capture_output=True, timeout=3)\r\n            \r\n            if result2.returncode == 0 and len(result2.stdout) > 0:\r\n                # base64形式でない場合の処理\r\n                raw_data = result2.stdout\r\n                if raw_data[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n                    nparr = np.frombuffer(raw_data, np.uint8)\r\n                    screenshot = cv2.imdecode(nparr, cv2.IMREAD_COLOR)\r\n                    if screenshot is not None:\r\n                        return screenshot\r\n                        \r\n            return None\r\n            \r\n        except subprocess.TimeoutExpired:\r\n            print(f\"メモリキャプチャタイムアウト\")\r\n            return None\r\n        except Exception as e:\r\n            print(f\"メモリキャプチャエラー: {str(e)}\")\r\n            return None\r\n    \r\n    def fast_screenshot_to_memory(self, device_id, use_memory_capture=True):\r\n        \"\"\"高速スクリーンショット（メモリ直接 or ファイル）改良版\"\"\"\r\n        # 互換性チェック\r\n        if device_id not in self.device_compatibility:\r\n            self.check_device_compatibility(device_id)\r\n        \r\n        # メモリ直接取得を試行（サポートされている場合のみ）\r\n        if (use_memory_capture and \r\n            self.device_compatibility.get(device_id, {}).get('memory_capture_supported', False)):\r\n            \r\n            screenshot = self.get_memory_screenshot(device_id)\r\n            if screenshot is not None:\r\n                # メモリ取得成功のログ（初回のみ）\r\n                if not self._memory_success_logged:\r\n                    print(f\"メモリ直接取得成功\")\r\n                    self._memory_success_logged = True\r\n                return screenshot\r\n            else:\r\n                # フォールバック回数を記録\r\n                self.fallback_count[device_id] = self.fallback_count.get(device_id, 0) + 1\r\n                \r\n                # 連続失敗時は一時的にメモリ取得を無効化\r\n                if self.fallback_count[device_id] >= 5:\r\n                    self.device_compatibility[device_id]['memory_capture_supported'] = False\r\n                    print(\"メモリ取得を一時無効化（連続失敗）\")\r\n        \r\n        # 従来のファイル方式（高速化版）\r\n        screenshot_path = self.take_screenshot_fast(device_id)\r\n        if screenshot_path:\r\n            return cv2.imread(screenshot_path)\r\n        \r\n        return None\r\n    \r\n    def check_device_compatibility(self, device_id):\r\n        \"\"\"デバイスの互換性チェック\"\"\"\r\n        if device_id in self.device_compatibility:\r\n            return self.device_compatibility[device_id]\r\n        \r\n        compatibility = {\r\n            'exec_out_supported': False,\r\n            'android_version': 'unknown',\r\n            'memory_capture_supported': False,\r\n            'reason': ''\r\n        }\r\n        \r\n        try:\r\n            # Androidバージョンを取得\r\n            result = subprocess.run(['adb', '-s', device_id, 'shell', 'getprop', 'ro.build.version.release'],\r\n                                  capture_output=True, text=True, timeout=10)\r\n            if result.returncode == 0:\r\n                compatibility['android_version'] = result.stdout.strip()\r\n            \r\n            # exec-out screencapコマンドの動作テスト\r\n            result = subprocess.run(['adb', '-s', device_id, 'exec-out', 'screencap', '-p'],\r\n                                  capture_output=True, timeout=15)\r\n            \r\n            if result.returncode == 0 and len(result.stdout) > 1000:  # 最小限の画像データサイズ\r\n                compatibility['exec_out_supported'] = True\r\n                compatibility['memory_capture_supported'] = True\r\n                compatibility['reason'] = 'Memory capture fully supported'\r\n            else:\r\n                compatibility['reason'] = f'exec-out failed (returncode: {result.returncode})'\r\n                \r\n        except subprocess.TimeoutExpired:\r\n            compatibility['reason'] = 'Command timeout'\r\n        except Exception as e:\r\n            compatibility['reason'] = f'Error: {str(e)}'\r\n        \r\n        self.device_compatibility[device_id] = compatibility\r\n        return compatibility\r\n    \r\n    def diagnostic_memory_capture(self, device_id):\r\n        \"\"\"メモリ直接取得の診断情報を表示\"\"\"\r\n        results = []\r\n        results.append(\"=== メモリ直接取得診断 ===\")\r\n        \r\n        try:\r\n            # 1. デバイス情報取得\r\n            info_cmd = ['adb', '-s', device_id, 'shell', 'getprop']\r\n            result = subprocess.run(info_cmd, capture_output=True, text=True, timeout=5)\r\n            if result.returncode == 0:\r\n                lines = result.stdout.split('\\n')\r\n                for line in lines:\r\n                    if 'ro.build.version.release' in line or 'ro.build.version.sdk' in line:\r\n                        results.append(f\"デバイス情報: {line.strip()}\")\r\n            \r\n            # 2. exec-outコマンドのサポート確認\r\n            test_cmd = ['adb', '-s', device_id, 'exec-out', 'echo', 'test']\r\n            result = subprocess.run(test_cmd, capture_output=True, timeout=3)\r\n            if result.returncode == 0:\r\n                results.append(\"exec-out コマンド: サポート\")\r\n            else:\r\n                results.append(f\"exec-out コマンド: 非サポート (code: {result.returncode})\")\r\n            \r\n            # 3. screencapコマンドの直接実行\r\n            screencap_cmd = ['adb', '-s', device_id, 'shell', 'screencap', '-h']\r\n            result = subprocess.run(screencap_cmd, capture_output=True, text=True, timeout=3)\r\n            if result.returncode == 0:\r\n                results.append(\"screencap コマンド: 利用可能\")\r\n            else:\r\n                results.append(f\"screencap コマンド: エラー (code: {result.returncode})\")\r\n            \r\n            # 4. 実際のメモリ取得を試行\r\n            memory_cmd = ['adb', '-s', device_id, 'exec-out', 'screencap']\r\n            result = subprocess.run(memory_cmd, capture_output=True, timeout=5)\r\n            \r\n            if result.returncode == 0:\r\n                data_size = len(result.stdout)\r\n                results.append(f\"メモリ取得: 成功 (データサイズ: {data_size} bytes)\")\r\n                \r\n                if data_size > 0:\r\n                    # データ形式を確認\r\n                    header = result.stdout[:16]\r\n                    results.append(f\"データヘッダー: {header}\")\r\n                    \r\n                    if header[:8] == b'\\x89PNG\\r\\n\\x1a\\n':\r\n                        results.append(\"データ形式: PNG\")\r\n                    else:\r\n                        results.append(\"データ形式: RAW (もしくは不明)\")\r\n                else:\r\n                    results.append(\"メモリ取得: データが空\")\r\n            else:\r\n                results.append(f\"メモリ取得: 失敗 (code: {result.returncode})\")\r\n                if result.stderr:\r\n                    error_msg = result.stderr.decode('utf-8', errors='ignore')\r\n                    results.append(f\"エラー詳細: {error_msg}\")\r\n            \r\n        except Exception as e:\r\n            results.append(f\"診断エラー: {str(e)}\")\r\n        \r\n        results.append(\"=== 診断終了 ===\")\r\n        return results\r\n"
        }
    ]
}