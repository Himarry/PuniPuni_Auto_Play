{
    "sourceFile": "automation_engine.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 19,
            "patches": [
                {
                    "date": 1750493481590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750495704628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,438 +1,274 @@\n-\"\"\"\r\n-è‡ªå‹•åŒ–ã‚¨ãƒ³ã‚¸ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«\r\n-è‡ªå‹•å‘¨å›ã®ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ã€ãƒãƒˆãƒ«ãƒ«ãƒ¼ãƒ—ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–æ©Ÿèƒ½\r\n-\"\"\"\r\n-\r\n+import asyncio\r\n+import logging\r\n import time\r\n-import threading\r\n-import random\r\n-from image_detector import ImageDetector\r\n-from device_controller import DeviceController\r\n+from typing import Dict, Optional, Tuple, List\r\n+from enum import Enum\r\n+from dataclasses import dataclass\r\n+from device_controller import MultiDeviceController\r\n+from image_detector import MultiDeviceImageDetector\r\n \r\n \r\n+class GameState(Enum):\r\n+    \"\"\"ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®åˆ—æŒ™\"\"\"\r\n+    IDLE = \"idle\"\r\n+    BOSS_DETECTED = \"boss_detected\"\r\n+    PLAY_DETECTED = \"play_detected\"\r\n+    PUZZLE_DETECTED = \"puzzle_detected\"\r\n+    WAZA_OK_DETECTED = \"waza_ok_detected\"\r\n+    NEXT_DETECTED = \"next_detected\"\r\n+    STAGE_45_DETECTED = \"stage_45_detected\"\r\n+\r\n+\r\n+@dataclass\r\n+class DeviceState:\r\n+    \"\"\"ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹\"\"\"\r\n+    device_id: str\r\n+    current_state: GameState = GameState.IDLE\r\n+    last_action_time: float = 0\r\n+    tap_count: int = 0\r\n+    error_count: int = 0\r\n+    is_active: bool = True\r\n+\r\n+\r\n class AutomationEngine:\r\n-    def __init__(self, image_paths, settings, log_callback):\r\n-        self.image_paths = image_paths\r\n-        self.settings = settings\r\n-        self.log = log_callback\r\n+    \"\"\"å¦–æ€ªã‚¦ã‚©ãƒƒãƒã·ã«ã·ã«è‡ªå‹•å‘¨å›ã‚¨ãƒ³ã‚¸ãƒ³\"\"\"\r\n+    \r\n+    def __init__(self, template_dir: str = \"image\"):\r\n+        self.device_controller = MultiDeviceController()\r\n+        self.image_detector = MultiDeviceImageDetector(template_dir)\r\n+        self.device_states = {}\r\n+        self.is_running = False\r\n+        self.logger = logging.getLogger(__name__)\r\n         \r\n-        self.image_detector = ImageDetector(settings['similarity_threshold'])\r\n-        self.device_controller = DeviceController()\r\n+        # è¨­å®š\r\n+        self.detection_threshold = 0.8\r\n+        self.tap_cooldown = 0.5  # ã‚¿ãƒƒãƒ—é–“éš”ï¼ˆç§’ï¼‰\r\n+        self.screen_capture_interval = 0.1  # ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ï¼ˆç§’ï¼‰\r\n+        self.max_error_count = 5  # æœ€å¤§ã‚¨ãƒ©ãƒ¼å›æ•°\r\n         \r\n-        self.running = False\r\n-        self.threads = {}\r\n-        self.device_status = {}\r\n+        # çµ±è¨ˆæƒ…å ±\r\n+        self.total_loops = 0\r\n+        self.start_time = 0\r\n         \r\n-        # ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ç”¨\r\n-        self.realtime_monitoring = False\r\n-        self.realtime_monitor_thread = None\r\n-        \r\n-    def update_settings(self, settings):\r\n-        \"\"\"è¨­å®šã‚’æ›´æ–°\"\"\"\r\n-        self.settings = settings\r\n-        self.image_detector.similarity_threshold = settings['similarity_threshold']\r\n+    def add_device(self, device_id: str) -> bool:\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’è¿½åŠ \"\"\"\r\n+        if self.device_controller.add_device(device_id):\r\n+            self.device_states[device_id] = DeviceState(device_id)\r\n+            self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã‚’è¿½åŠ ã—ã¾ã—ãŸ\")\r\n+            return True\r\n+        return False\r\n     \r\n-    def human_like_delay(self):\r\n-        \"\"\"äººé–“ã‚‰ã—ã„ãƒ©ãƒ³ãƒ€ãƒ ãªé…å»¶\"\"\"\r\n-        delay = random.uniform(\r\n-            self.settings['human_like_delay_min'], \r\n-            self.settings['human_like_delay_max']\r\n-        )\r\n-        time.sleep(delay)\r\n+    def remove_device(self, device_id: str):\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’å‰Šé™¤\"\"\"\r\n+        self.device_controller.remove_device(device_id)\r\n+        if device_id in self.device_states:\r\n+            del self.device_states[device_id]\r\n+        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã‚’å‰Šé™¤ã—ã¾ã—ãŸ\")\r\n     \r\n-    def start_automation(self, selected_devices):\r\n-        \"\"\"è‡ªå‹•åŒ–é–‹å§‹\"\"\"\r\n-        self.running = True\r\n-        \r\n-        # ãƒ‡ãƒã‚¤ã‚¹äº’æ›æ€§ãƒã‚§ãƒƒã‚¯\r\n-        for device_id in selected_devices:\r\n-            self.log_device_compatibility(device_id)\r\n-        \r\n-        # å„ãƒ‡ãƒã‚¤ã‚¹ã§ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é–‹å§‹\r\n-        for device_id in selected_devices:\r\n-            thread = threading.Thread(target=self.automation_loop, args=(device_id,))\r\n-            thread.daemon = True\r\n-            self.threads[device_id] = thread\r\n-            thread.start()\r\n-            self.log(\"è‡ªå‹•åŒ–é–‹å§‹\", device_id)\r\n+    def get_device_list(self) -> List[str]:\r\n+        \"\"\"ç®¡ç†ä¸­ã®ãƒ‡ãƒã‚¤ã‚¹ä¸€è¦§ã‚’å–å¾—\"\"\"\r\n+        return list(self.device_states.keys())\r\n     \r\n-    def stop_automation(self):\r\n-        \"\"\"è‡ªå‹•åŒ–åœæ­¢\"\"\"\r\n-        self.running = False\r\n-        self.threads.clear()\r\n-        self.log(\"å…¨ãƒ‡ãƒã‚¤ã‚¹ã®è‡ªå‹•åŒ–ã‚’åœæ­¢\")\r\n+    def get_device_state(self, device_id: str) -> Optional[DeviceState]:\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’å–å¾—\"\"\"\r\n+        return self.device_states.get(device_id)\r\n     \r\n-    def automation_loop(self, device_id):\r\n-        \"\"\"æœ€é©åŒ–ã•ã‚ŒãŸãƒ¡ã‚¤ãƒ³ã®è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—\"\"\"\r\n-        self.device_status[device_id] = \"å®Ÿè¡Œä¸­\"\r\n-        puzzle_tap_count = 0\r\n-        stage_45_detected = False\r\n+    def set_device_active(self, device_id: str, active: bool):\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è¨­å®š\"\"\"\r\n+        if device_id in self.device_states:\r\n+            self.device_states[device_id].is_active = active\r\n+    \r\n+    async def process_device_detection(self, device_id: str, \r\n+                                     detections: Dict[str, Optional[Tuple[int, int]]]):\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\"\"\"\r\n+        if device_id not in self.device_states:\r\n+            return\r\n         \r\n-        while self.running and device_id in self.threads:\r\n-            try:\r\n-                # å„ªå…ˆåº¦ã®é«˜ã„ç”»åƒã‚’åŒæ™‚æ¤œç´¢\r\n-                priority_images = {}\r\n-                \r\n-                # stage_45.pngã‚’æœ€åˆã«ãƒã‚§ãƒƒã‚¯\r\n-                screenshot = self.device_controller.fast_screenshot_to_memory(\r\n-                    device_id, self.settings.get('use_memory_capture', True)\r\n-                )\r\n-                if screenshot is None:\r\n-                    time.sleep(0.5)\r\n-                    continue\r\n-                \r\n-                stage_45_pos = self.image_detector.find_image_on_screen_optimized(\r\n-                    self.image_paths['stage_45'], screenshot\r\n-                )\r\n-                \r\n-                if stage_45_pos and not stage_45_detected:\r\n-                    stage_45_detected = True\r\n-                    self.log(\"ã‚¹ãƒ†ãƒ¼ã‚¸45æ¤œå‡º - closeç³»ãƒœã‚¿ãƒ³ã®ç›£è¦–ã‚’åœæ­¢\", device_id)\r\n-                elif not stage_45_pos and stage_45_detected:\r\n-                    stage_45_detected = False\r\n-                    self.log(\"ã‚¹ãƒ†ãƒ¼ã‚¸45çµ‚äº† - closeç³»ãƒœã‚¿ãƒ³ã®ç›£è¦–ã‚’å†é–‹\", device_id)\r\n-                \r\n-                # closeç³»ã®ç›£è¦–ï¼ˆstage_45æ¤œå‡ºæ™‚ã¯é™¤ãï¼‰\r\n-                if not stage_45_detected:\r\n-                    priority_images['close'] = self.image_paths['close']\r\n-                    priority_images['close_mini'] = self.image_paths['close_mini']\r\n-                \r\n-                # ç¾åœ¨ã®çŠ¶æ…‹ã«å¿œã˜ãŸç”»åƒã‚’è¿½åŠ \r\n-                priority_images['boss'] = self.image_paths['boss']\r\n-                priority_images['play'] = self.image_paths['play']\r\n-                priority_images['next'] = self.image_paths['next']\r\n-                \r\n-                # è¤‡æ•°ç”»åƒã‚’åŒæ™‚æ¤œç´¢ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰\r\n-                detected_images = self.image_detector.find_multiple_images_on_screen_optimized(\r\n-                    priority_images, screenshot\r\n-                )\r\n-                \r\n-                # playãƒœã‚¿ãƒ³ã‚’ç›´æ¥æ¤œå‡ºã—ãŸå ´åˆã®å‡¦ç†ã‚’è¿½åŠ \r\n-                if 'play' in detected_images:\r\n-                    self.log(\"playãƒœã‚¿ãƒ³ã‚’ç›´æ¥æ¤œå‡ºã—ã¾ã—ãŸ\", device_id)\r\n-                    pos = detected_images['play']['pos']\r\n-                    \r\n-                    # play.pngã‚’ã‚¿ãƒƒãƒ—å‰ã«å†åº¦stage_45.pngã‚’ãƒã‚§ãƒƒã‚¯\r\n-                    stage_45_pos = self.image_detector.find_image_on_screen_optimized(\r\n-                        self.image_paths['stage_45'], screenshot\r\n-                    )\r\n-                    if stage_45_pos:\r\n-                        stage_45_detected = True\r\n-                        self.log(\"ãƒ—ãƒ¬ã‚¤å‰ã‚¹ãƒ†ãƒ¼ã‚¸45æ¤œå‡º - closeç³»ãƒœã‚¿ãƒ³ã®ç›£è¦–ã‚’åœæ­¢\", device_id)\r\n-                    \r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"play\", self.settings['tap_delay']\r\n-                    )\r\n-                    \r\n-                    # ãƒãƒˆãƒ«ãƒ«ãƒ¼ãƒ—ï¼ˆâ‘¢â‘£ã®å‡¦ç†ï¼‰\r\n-                    self.battle_loop(device_id, puzzle_tap_count)\r\n-                    puzzle_tap_count = 0\r\n-                    continue\r\n-                \r\n-                # å„ªå…ˆé †ä½ã«å¾“ã£ã¦å‡¦ç†\r\n-                if 'close' in detected_images and not stage_45_detected:\r\n-                    pos = detected_images['close']['pos']\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n-                    )\r\n-                    continue\r\n-                    \r\n-                if 'close_mini' in detected_images and not stage_45_detected:\r\n-                    pos = detected_images['close_mini']['pos']\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n-                    )\r\n-                    continue\r\n-                \r\n-                # next.pngãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆï¼ˆæœ€å„ªå…ˆï¼‰\r\n-                if 'next' in detected_images:\r\n-                    pos = detected_images['next']['pos']\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"next\", self.settings['tap_delay']\r\n-                    )\r\n-                    stage_45_detected = False  # ãƒªã‚»ãƒƒãƒˆ\r\n-                    puzzle_tap_count = 0\r\n-                    continue\r\n-                \r\n-                # boss.pngãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆ\r\n-                if 'boss' in detected_images:\r\n-                    pos = detected_images['boss']['pos']\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"boss\", self.settings['tap_delay']\r\n-                    )\r\n-                    \r\n-                    # play.pngã‚’å¾…æ©Ÿã—ã¦æ¤œç´¢ï¼ˆæœ€é©åŒ–ç‰ˆãƒ»å¼·åŒ–ï¼‰\r\n-                    self.log(\"bossæ¤œå‡ºå¾Œã€playãƒœã‚¿ãƒ³ã‚’æ¤œç´¢ä¸­...\", device_id)\r\n-                    play_found = False\r\n-                    max_attempts = 10  # æœ€å¤§è©¦è¡Œå›æ•°\r\n-                    \r\n-                    for attempt in range(max_attempts):\r\n-                        time.sleep(0.5)  # ç”»é¢é·ç§»ã‚’å¾…ã¤\r\n-                        # æ–°ã—ã„ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’å–å¾—\r\n-                        new_screenshot = self.device_controller.fast_screenshot_to_memory(\r\n-                            device_id, self.settings.get('use_memory_capture', True)\r\n-                        )\r\n-                        if new_screenshot is None:\r\n-                            continue\r\n-                            \r\n-                        # æ®µéšçš„é–¾å€¤æ¤œç´¢ã‚’ä½¿ç”¨\r\n-                        play_pos = self.image_detector.find_image_with_multiple_thresholds(\r\n-                            self.image_paths['play'], new_screenshot\r\n-                        )\r\n-                        \r\n-                        if play_pos:\r\n-                            self.log(f\"playãƒœã‚¿ãƒ³æ¤œå‡ºæˆåŠŸ (è©¦è¡Œ{attempt + 1}å›ç›®): {play_pos}\", device_id)\r\n-                            play_found = True\r\n-                            \r\n-                            self.device_controller.smart_tap_screen(\r\n-                                play_pos[0], play_pos[1], device_id, \"play\", self.settings['tap_delay']\r\n-                            )\r\n-                            \r\n-                            # ãƒãƒˆãƒ«ãƒ«ãƒ¼ãƒ—ï¼ˆâ‘¢â‘£ã®å‡¦ç†ï¼‰\r\n-                            self.battle_loop(device_id, puzzle_tap_count)\r\n-                            puzzle_tap_count = 0\r\n-                            break\r\n-                        else:\r\n-                            self.log(f\"playãƒœã‚¿ãƒ³æœªæ¤œå‡º (è©¦è¡Œ{attempt + 1}å›ç›®)\", device_id)\r\n-                    \r\n-                    if not play_found:\r\n-                        self.log(f\"playãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸï¼ˆ{max_attempts}å›è©¦è¡Œï¼‰\", device_id)\r\n-                \r\n-                # çŸ­ã„é–“éš”ã§æ¬¡ã®ãƒã‚§ãƒƒã‚¯\r\n-                time.sleep(self.settings['check_interval'])\r\n-                \r\n-            except Exception as e:\r\n-                self.log(f\"è‡ªå‹•åŒ–ã‚¨ãƒ©ãƒ¼: {str(e)}\", device_id)\r\n-                time.sleep(0.5)\r\n+        device_state = self.device_states[device_id]\r\n+        if not device_state.is_active:\r\n+            return\r\n         \r\n-        self.device_status[device_id] = \"åœæ­¢\"\r\n-        self.log(\"è‡ªå‹•åŒ–åœæ­¢\", device_id)\r\n-    \r\n-    def battle_loop(self, device_id, initial_puzzle_count=0):\r\n-        \"\"\"ãƒãƒˆãƒ«ä¸­ã®ãƒ«ãƒ¼ãƒ—å‡¦ç†ï¼ˆâ‘¢â‘£ã®æœ€é©åŒ–ãƒ»puzzleæ¤œçŸ¥å¼·åŒ–ï¼‰\"\"\"\r\n-        puzzle_tap_count = initial_puzzle_count\r\n-        battle_start_time = time.time()\r\n-        max_battle_time = 60  # æœ€å¤§ãƒãƒˆãƒ«æ™‚é–“ï¼ˆç§’ï¼‰\r\n-        stage_45_in_battle = False\r\n-        puzzle_search_attempts = 0  # puzzleæ¤œç´¢è©¦è¡Œå›æ•°\r\n+        current_time = time.time()\r\n         \r\n-        self.log(f\"ãƒãƒˆãƒ«é–‹å§‹ (åˆæœŸpuzzleå›æ•°: {puzzle_tap_count})\", device_id)\r\n+        # ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\r\n+        if current_time - device_state.last_action_time < self.tap_cooldown:\r\n+            return\r\n         \r\n-        while self.running and device_id in self.threads:\r\n-            # æœ€å¤§æ™‚é–“ãƒã‚§ãƒƒã‚¯\r\n-            if time.time() - battle_start_time > max_battle_time:\r\n-                self.log(\"ãƒãƒˆãƒ«æ™‚é–“è¶…é - æ¬¡ã®ã‚µã‚¤ã‚¯ãƒ«ã«ç§»è¡Œ\", device_id)\r\n-                break\r\n+        try:\r\n+            # å„ªå…ˆåº¦é †ã§å‡¦ç†\r\n+            action_taken = False\r\n             \r\n-            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆå–å¾—\r\n-            screenshot = self.device_controller.fast_screenshot_to_memory(\r\n-                device_id, self.settings.get('use_memory_capture', True)\r\n-            )\r\n-            if screenshot is None:\r\n-                time.sleep(0.3)\r\n-                continue\r\n+            # 1. bossãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('boss') and not action_taken:\r\n+                x, y = detections['boss']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.BOSS_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: BOSSã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n-            # ãƒãƒˆãƒ«é–‹å§‹æ™‚ã«stage_45ã‚’ãƒã‚§ãƒƒã‚¯\r\n-            if not stage_45_in_battle:\r\n-                stage_45_pos = self.image_detector.find_image_on_screen_optimized(\r\n-                    self.image_paths['stage_45'], screenshot\r\n-                )\r\n-                if stage_45_pos:\r\n-                    stage_45_in_battle = True\r\n-                    self.log(\"ãƒãƒˆãƒ«ä¸­ã‚¹ãƒ†ãƒ¼ã‚¸45æ¤œå‡º - closeç³»ç›£è¦–åœæ­¢\", device_id)\r\n-            \r\n-            # ãƒãƒˆãƒ«é–¢é€£ã®ç”»åƒã‚’åŒæ™‚æ¤œç´¢ï¼ˆpuzzleå„ªå…ˆé †åºï¼‰\r\n-            battle_images = {\r\n-                'puzzle': self.image_paths['puzzle'],  # puzzleã‚’æœ€åˆã«é…ç½®\r\n-                'next': self.image_paths['next'],\r\n-                'waza_ok': self.image_paths['waza_ok']\r\n-            }\r\n-            \r\n-            # stage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿closeç³»ã‚’è¿½åŠ \r\n-            if not stage_45_in_battle:\r\n-                battle_images['close'] = self.image_paths['close']\r\n-                battle_images['close_mini'] = self.image_paths['close_mini']\r\n-            \r\n-            detected = self.image_detector.find_multiple_images_on_screen_optimized(\r\n-                battle_images, screenshot\r\n-            )\r\n-            \r\n-            # æœ€å„ªå…ˆ: puzzle.pngã‚’ã‚¿ãƒƒãƒ—ï¼ˆå›æ•°åˆ¶é™ã‚ã‚Šãƒ»è¶…ç©æ¥µçš„æ¤œçŸ¥ï¼‰\r\n-            if puzzle_tap_count < self.settings['puzzle_tap_count']:\r\n-                puzzle_detected = False\r\n-                \r\n-                # æ–¹æ³•1: é€šå¸¸ã®æ¤œçŸ¥ã‚’è©¦è¡Œ\r\n-                if 'puzzle' in detected:\r\n-                    pos = detected['puzzle']['pos']\r\n-                    confidence = detected['puzzle']['confidence']\r\n-                    self.log(f\"puzzleé€šå¸¸æ¤œå‡º (å›æ•°: {puzzle_tap_count + 1}/{self.settings['puzzle_tap_count']}, ä¿¡é ¼åº¦: {confidence:.3f})\", device_id)\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"puzzle\", self.settings['tap_delay']\r\n-                    )\r\n-                    puzzle_tap_count += 1\r\n-                    puzzle_detected = True\r\n-                \r\n-                # æ–¹æ³•2: é€šå¸¸æ¤œçŸ¥ã§å¤±æ•—ã—ãŸå ´åˆã€ã™ãã«å¼·åŒ–æ¤œçŸ¥ã‚’è©¦è¡Œ\r\n-                if not puzzle_detected:\r\n-                    puzzle_pos = self.image_detector.find_puzzle_with_enhanced_detection(\r\n-                        self.image_paths['puzzle'], screenshot\r\n-                    )\r\n-                    if puzzle_pos:\r\n-                        self.log(f\"puzzleå¼·åŒ–æ¤œå‡º (å›æ•°: {puzzle_tap_count + 1}/{self.settings['puzzle_tap_count']})\", device_id)\r\n-                        self.device_controller.smart_tap_screen(\r\n-                            puzzle_pos[0], puzzle_pos[1], device_id, \"puzzle\", self.settings['tap_delay']\r\n-                        )\r\n-                        puzzle_tap_count += 1\r\n-                        puzzle_detected = True\r\n-                \r\n-                # æ–¹æ³•3: ãã‚Œã§ã‚‚å¤±æ•—ã—ãŸå ´åˆã€ä½é–¾å€¤ã§æœ€å¾Œã®è©¦è¡Œ\r\n-                if not puzzle_detected and puzzle_search_attempts % 3 == 0:  # 3å›ã«1å›ã ã‘\r\n-                    low_threshold_pos = self.image_detector.find_image_on_screen_optimized(\r\n-                        self.image_paths['puzzle'], screenshot, threshold=0.5\r\n-                    )\r\n-                    if low_threshold_pos:\r\n-                        self.log(f\"puzzleä½é–¾å€¤æ¤œå‡º (å›æ•°: {puzzle_tap_count + 1}/{self.settings['puzzle_tap_count']})\", device_id)\r\n-                        self.device_controller.smart_tap_screen(\r\n-                            low_threshold_pos[0], low_threshold_pos[1], device_id, \"puzzle\", self.settings['tap_delay']\r\n-                        )\r\n-                        puzzle_tap_count += 1\r\n-                        puzzle_detected = True\r\n-                \r\n-                # puzzleæ¤œå‡ºæˆåŠŸæ™‚ã¯çŸ­ã„ã‚¹ãƒªãƒ¼ãƒ—ã§æ¬¡ã®ãƒ«ãƒ¼ãƒ—ã¸\r\n-                if puzzle_detected:\r\n-                    time.sleep(0.2)  # ã•ã‚‰ã«çŸ­ã„ãƒ‡ã‚£ãƒ¬ã‚¤ã§puzzleã‚’é€£ç¶šæ¤œç´¢\r\n-                    continue\r\n+            # 2. playãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—ï¼ˆãŸã ã—stage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯å‡¦ç†ã—ãªã„ï¼‰\r\n+            if detections.get('play') and not action_taken:\r\n+                # stage_45ã®ç‰¹åˆ¥å‡¦ç†\r\n+                if detections.get('stage_45'):\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: stage_45ãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚ã€playã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™\")\r\n+                    device_state.current_state = GameState.STAGE_45_DETECTED\r\n                 else:\r\n-                    # puzzleæ¤œå‡ºå¤±æ•—æ™‚ã®å‡¦ç†ï¼ˆãƒ­ã‚°é »åº¦ã‚’åˆ¶å¾¡ï¼‰\r\n-                    puzzle_search_attempts += 1\r\n-                    if puzzle_search_attempts % 3 == 1:  # 3å›ã«1å›ãƒ­ã‚°ï¼ˆé »åº¦ã‚’ä¸Šã’ã‚‹ï¼‰\r\n-                        self.log(f\"puzzleå…¨æ¤œå‡ºå¤±æ•— ({puzzle_search_attempts}å›ç›®) - waza_okã‚’å¾…æ©Ÿä¸­\", device_id)\r\n-                        # å¤±æ•—æ™‚ã¯ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çŠ¶æ³ã‚’ãƒ­ã‚°\r\n-                        if puzzle_search_attempts % 9 == 1:  # 9å›ã«1å›ã¯è©³ç´°ãƒ­ã‚°\r\n-                            current_images = self.image_detector.find_multiple_images_on_screen_optimized(\r\n-                                {'waza_ok': self.image_paths['waza_ok'], 'next': self.image_paths['next']}, screenshot\r\n-                            )\r\n-                            detected_names = list(current_images.keys())\r\n-                            self.log(f\"ç¾åœ¨æ¤œå‡ºä¸­ã®ç”»åƒ: {detected_names if detected_names else 'ãªã—'}\", device_id)\r\n+                    x, y = detections['play']\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.PLAY_DETECTED\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PLAYã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n-            # æ¬¡ã®å„ªå…ˆåº¦: waza_ok.pngã‚’ã‚¿ãƒƒãƒ—\r\n-            if 'waza_ok' in detected:\r\n-                pos = detected['waza_ok']['pos']\r\n-                self.device_controller.smart_tap_screen(\r\n-                    pos[0], pos[1], device_id, \"waza_ok\", self.settings['tap_delay']\r\n-                )\r\n-                puzzle_tap_count = 0  # ãƒ‘ã‚ºãƒ«ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒªã‚»ãƒƒãƒˆ\r\n-                puzzle_search_attempts = 0  # æ¤œç´¢è©¦è¡Œå›æ•°ã‚‚ãƒªã‚»ãƒƒãƒˆ\r\n-                continue\r\n+            # 3. puzzleãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('puzzle') and not action_taken:\r\n+                x, y = detections['puzzle']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.PUZZLE_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PUZZLEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n-            # closeç³»ã®å‡¦ç†ï¼ˆstage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ï¼‰\r\n-            if not stage_45_in_battle:\r\n-                if 'close' in detected:\r\n-                    pos = detected['close']['pos']\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n-                    )\r\n-                    continue\r\n-                    \r\n-                if 'close_mini' in detected:\r\n-                    pos = detected['close_mini']['pos']\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n-                    )\r\n-                    continue\r\n+            # 4. waza_okãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('waza_ok') and not action_taken:\r\n+                x, y = detections['waza_ok']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.WAZA_OK_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: WAZA_OKã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n-            # æœ€å¾Œ: next.pngãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ãƒãƒˆãƒ«çµ‚äº†\r\n-            if 'next' in detected:\r\n-                pos = detected['next']['pos']\r\n-                self.device_controller.smart_tap_screen(\r\n-                    pos[0], pos[1], device_id, \"next\", self.settings['tap_delay']\r\n-                )\r\n-                break\r\n+            # 5. nextãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('next') and not action_taken:\r\n+                x, y = detections['next']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.NEXT_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.total_loops += 1  # ãƒ«ãƒ¼ãƒ—å®Œäº†ã®ã‚«ã‚¦ãƒ³ãƒˆ\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: NEXTã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸï¼ˆãƒ«ãƒ¼ãƒ—å®Œäº†: {self.total_loops}ï¼‰\")\r\n             \r\n-            # puzzleãŒå¿…è¦ãªå ´åˆã¯çŸ­ã„é–“éš”ã€ãã†ã§ãªã‘ã‚Œã°é€šå¸¸é–“éš”\r\n-            if puzzle_tap_count < self.settings['puzzle_tap_count']:\r\n-                time.sleep(max(0.15, self.settings['check_interval'] * 0.3))  # puzzleæ¤œç´¢æ™‚ã¯è¶…é«˜é€Ÿ\r\n-            else:\r\n-                time.sleep(self.settings['check_interval'])\r\n-    \r\n-    def toggle_realtime_monitor(self, device_id):\r\n-        \"\"\"ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ã®é–‹å§‹/åœæ­¢\"\"\"\r\n-        if not self.realtime_monitoring:\r\n-            self.realtime_monitoring = True\r\n+            # ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ\r\n+            if action_taken:\r\n+                device_state.error_count = 0\r\n             \r\n-            # ç›£è¦–ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é–‹å§‹\r\n-            self.realtime_monitor_thread = threading.Thread(\r\n-                target=self.realtime_monitor_loop, \r\n-                args=(device_id,)\r\n-            )\r\n-            self.realtime_monitor_thread.daemon = True\r\n-            self.realtime_monitor_thread.start()\r\n+        except Exception as e:\r\n+            device_state.error_count += 1\r\n+            self.logger.error(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}\")\r\n             \r\n-            self.log(\"ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–é–‹å§‹\")\r\n-            return True\r\n-        else:\r\n-            self.realtime_monitoring = False\r\n-            self.log(\"ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–åœæ­¢\")\r\n-            return False\r\n+            # ã‚¨ãƒ©ãƒ¼å›æ•°ãŒä¸Šé™ã‚’è¶…ãˆãŸå ´åˆã€ãƒ‡ãƒã‚¤ã‚¹ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹\r\n+            if device_state.error_count >= self.max_error_count:\r\n+                device_state.is_active = False\r\n+                self.logger.warning(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ãŒã‚¨ãƒ©ãƒ¼ä¸Šé™ã«é”ã—ãŸãŸã‚éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ã¾ã—ãŸ\")\r\n     \r\n-    def realtime_monitor_loop(self, device_id):\r\n-        \"\"\"ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ã®ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—\"\"\"\r\n-        last_detection_status = {}\r\n+    async def automation_loop(self):\r\n+        \"\"\"ãƒ¡ã‚¤ãƒ³è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—\"\"\"\r\n+        self.logger.info(\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã—ã¾ã™\")\r\n+        self.start_time = time.time()\r\n         \r\n-        while self.realtime_monitoring:\r\n+        while self.is_running:\r\n             try:\r\n-                # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆå–å¾—\r\n-                screenshot = self.device_controller.fast_screenshot_to_memory(\r\n-                    device_id, self.settings.get('use_memory_capture', True)\r\n-                )\r\n-                if screenshot is None:\r\n-                    time.sleep(1.0)\r\n+                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£\r\n+                screen_data = await self.device_controller.capture_all_screens()\r\n+                \r\n+                if not screen_data:\r\n+                    await asyncio.sleep(self.screen_capture_interval)\r\n                     continue\r\n                 \r\n-                # å…¨ç”»åƒã‚’åŒæ™‚æ¤œç´¢\r\n-                all_images = self.image_paths.copy()\r\n-                detected = self.image_detector.find_multiple_images_on_screen_optimized(\r\n-                    all_images, screenshot\r\n+                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã§ç”»åƒæ¤œå‡º\r\n+                detection_results = await self.image_detector.detect_all_devices(\r\n+                    screen_data, self.detection_threshold\r\n                 )\r\n                 \r\n-                # æ¤œå‡ºçŠ¶æ³ã®å¤‰åŒ–ã‚’ãƒ­ã‚°\r\n-                current_status = {}\r\n-                for name in all_images.keys():\r\n-                    current_status[name] = name in detected\r\n-                    \r\n-                    # çŠ¶æ…‹ãŒå¤‰åŒ–ã—ãŸå ´åˆã®ã¿ãƒ­ã‚°\r\n-                    if name not in last_detection_status or last_detection_status[name] != current_status[name]:\r\n-                        if current_status[name]:\r\n-                            confidence = detected[name]['confidence']\r\n-                            pos = detected[name]['pos']\r\n-                            self.log(f\"ğŸ” æ¤œå‡º: {name} (ä¿¡é ¼åº¦: {confidence:.3f}, ä½ç½®: {pos})\", device_id)\r\n-                        else:\r\n-                            self.log(f\"âŒ æ¶ˆå¤±: {name}\", device_id)\r\n+                # å„ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\r\n+                tasks = []\r\n+                for device_id, detections in detection_results.items():\r\n+                    if device_id in self.device_states:\r\n+                        task = self.process_device_detection(device_id, detections)\r\n+                        tasks.append(task)\r\n                 \r\n-                # puzzle.pngãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆã¯å¼·åŒ–æ¤œçŸ¥ã‚’è©¦è¡Œ\r\n-                if not current_status.get('puzzle', False):\r\n-                    puzzle_pos = self.image_detector.find_puzzle_with_enhanced_detection(\r\n-                        self.image_paths['puzzle'], screenshot\r\n-                    )\r\n-                    if puzzle_pos:\r\n-                        self.log(f\"ğŸ” å¼·åŒ–æ¤œå‡º: puzzle (ä½ç½®: {puzzle_pos})\", device_id)\r\n-                        current_status['puzzle'] = True\r\n+                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®å‡¦ç†ã‚’ä¸¦è¡Œå®Ÿè¡Œ\r\n+                if tasks:\r\n+                    await asyncio.gather(*tasks, return_exceptions=True)\r\n                 \r\n-                last_detection_status = current_status.copy()\r\n+                # çŸ­ã„å¾…æ©Ÿ\r\n+                await asyncio.sleep(self.screen_capture_interval)\r\n                 \r\n-                # 1ç§’é–“éš”ã§ç›£è¦–\r\n-                time.sleep(1.0)\r\n-                \r\n             except Exception as e:\r\n-                self.log(f\"ç›£è¦–ã‚¨ãƒ©ãƒ¼: {str(e)}\", device_id)\r\n-                time.sleep(1.0)\r\n+                self.logger.error(f\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚¨ãƒ©ãƒ¼: {e}\")\r\n+                await asyncio.sleep(1)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å°‘ã—é•·ã‚ã«å¾…æ©Ÿ\r\n     \r\n-    def log_device_compatibility(self, device_id):\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹äº’æ›æ€§æƒ…å ±ã‚’ãƒ­ã‚°å‡ºåŠ›\"\"\"\r\n-        compat = self.device_controller.check_device_compatibility(device_id)\r\n-        self.log(f\"ãƒ‡ãƒã‚¤ã‚¹äº’æ›æ€§ãƒã‚§ãƒƒã‚¯: Android {compat['android_version']}\", device_id)\r\n-        if compat['memory_capture_supported']:\r\n-            self.log(\"ãƒ¡ãƒ¢ãƒªç›´æ¥å–å¾—: ã‚µãƒãƒ¼ãƒˆ\", device_id)\r\n-        else:\r\n-            self.log(f\"ãƒ¡ãƒ¢ãƒªç›´æ¥å–å¾—: éã‚µãƒãƒ¼ãƒˆ - {compat['reason']}\", device_id)\r\n-            self.log(\"é€šå¸¸ã®ãƒ•ã‚¡ã‚¤ãƒ«æ–¹å¼ã‚’ä½¿ç”¨ã—ã¾ã™\", device_id)\r\n+    async def start_automation(self):\r\n+        \"\"\"è‡ªå‹•åŒ–ã‚’é–‹å§‹\"\"\"\r\n+        if self.is_running:\r\n+            self.logger.warning(\"è‡ªå‹•åŒ–ã¯æ—¢ã«å®Ÿè¡Œä¸­ã§ã™\")\r\n+            return\r\n+        \r\n+        if not self.device_states:\r\n+            self.logger.error(\"ãƒ‡ãƒã‚¤ã‚¹ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“\")\r\n+            return\r\n+        \r\n+        self.is_running = True\r\n+        self.total_loops = 0\r\n+        await self.automation_loop()\r\n+    \r\n+    def stop_automation(self):\r\n+        \"\"\"è‡ªå‹•åŒ–ã‚’åœæ­¢\"\"\"\r\n+        self.is_running = False\r\n+        self.logger.info(\"è‡ªå‹•åŒ–ã‚’åœæ­¢ã—ã¾ã—ãŸ\")\r\n+    \r\n+    def get_statistics(self) -> Dict:\r\n+        \"\"\"çµ±è¨ˆæƒ…å ±ã‚’å–å¾—\"\"\"\r\n+        current_time = time.time()\r\n+        elapsed_time = current_time - self.start_time if self.start_time > 0 else 0\r\n+        \r\n+        stats = {\r\n+            'total_loops': self.total_loops,\r\n+            'elapsed_time': elapsed_time,\r\n+            'loops_per_hour': (self.total_loops / elapsed_time * 3600) if elapsed_time > 0 else 0,\r\n+            'active_devices': len([d for d in self.device_states.values() if d.is_active]),\r\n+            'total_devices': len(self.device_states),\r\n+            'device_details': {}\r\n+        }\r\n+        \r\n+        for device_id, state in self.device_states.items():\r\n+            stats['device_details'][device_id] = {\r\n+                'state': state.current_state.value,\r\n+                'tap_count': state.tap_count,\r\n+                'error_count': state.error_count,\r\n+                'is_active': state.is_active,\r\n+                'last_action_time': state.last_action_time\r\n+            }\r\n+        \r\n+        return stats\r\n+    \r\n+    def reset_statistics(self):\r\n+        \"\"\"çµ±è¨ˆæƒ…å ±ã‚’ãƒªã‚»ãƒƒãƒˆ\"\"\"\r\n+        self.total_loops = 0\r\n+        self.start_time = time.time()\r\n+        for state in self.device_states.values():\r\n+            state.tap_count = 0\r\n+            state.error_count = 0\r\n+    \r\n+    def set_detection_threshold(self, threshold: float):\r\n+        \"\"\"æ¤œå‡ºé–¾å€¤ã‚’è¨­å®š\"\"\"\r\n+        self.detection_threshold = max(0.1, min(1.0, threshold))\r\n+    \r\n+    def set_tap_cooldown(self, cooldown: float):\r\n+        \"\"\"ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’è¨­å®š\"\"\"\r\n+        self.tap_cooldown = max(0.1, cooldown)\r\n+    \r\n+    def set_capture_interval(self, interval: float):\r\n+        \"\"\"ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ã‚’è¨­å®š\"\"\"\r\n+        self.screen_capture_interval = max(0.05, interval)\r\n"
                },
                {
                    "date": 1750496229563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,10 +195,9 @@\n                 tasks = []\r\n                 for device_id, detections in detection_results.items():\r\n                     if device_id in self.device_states:\r\n                         task = self.process_device_detection(device_id, detections)\r\n-                        tasks.append(task)\r\n-                \r\n+                        tasks.append(task)                \r\n                 # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®å‡¦ç†ã‚’ä¸¦è¡Œå®Ÿè¡Œ\r\n                 if tasks:\r\n                     await asyncio.gather(*tasks, return_exceptions=True)\r\n                 \r\n@@ -220,9 +219,14 @@\n             return\r\n         \r\n         self.is_running = True\r\n         self.total_loops = 0\r\n-        await self.automation_loop()\r\n+        try:\r\n+            await self.automation_loop()\r\n+        except Exception as e:\r\n+            self.logger.error(f\"è‡ªå‹•åŒ–å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}\")\r\n+        finally:\r\n+            self.is_running = False\r\n     \r\n     def stop_automation(self):\r\n         \"\"\"è‡ªå‹•åŒ–ã‚’åœæ­¢\"\"\"\r\n         self.is_running = False\r\n"
                },
                {
                    "date": 1750499271477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,10 +88,9 @@\n         if not device_state.is_active:\r\n             return\r\n         \r\n         current_time = time.time()\r\n-        \r\n-        # ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\r\n+          # ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\r\n         if current_time - device_state.last_action_time < self.tap_cooldown:\r\n             return\r\n         \r\n         try:\r\n@@ -108,25 +107,43 @@\n                     device_state.tap_count += 1\r\n                     action_taken = True\r\n                     self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: BOSSã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n-            # 2. playãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—ï¼ˆãŸã ã—stage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯å‡¦ç†ã—ãªã„ï¼‰\r\n+            # 2. playãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('play') and not action_taken:\r\n-                # stage_45ã®ç‰¹åˆ¥å‡¦ç†\r\n-                if detections.get('stage_45'):\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: stage_45ãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚ã€playã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™\")\r\n-                    device_state.current_state = GameState.STAGE_45_DETECTED\r\n-                else:\r\n-                    x, y = detections['play']\r\n+                x, y = detections['play']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.PLAY_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PLAYã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            \r\n+            # 3. close/close_miniãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—ï¼ˆãŸã ã—stage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰\r\n+            if not action_taken and not detections.get('stage_45'):\r\n+                if detections.get('close'):\r\n+                    x, y = detections['close']\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n-                        device_state.current_state = GameState.PLAY_DETECTED\r\n+                        device_state.current_state = GameState.IDLE\r\n                         device_state.last_action_time = current_time\r\n                         device_state.tap_count += 1\r\n                         action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PLAYã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+                elif detections.get('close_mini'):\r\n+                    x, y = detections['close_mini']\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.IDLE\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSE_MINIã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            elif detections.get('stage_45'):\r\n+                self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: stage_45ãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚ã€close/close_miniã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™\")\r\n             \r\n-            # 3. puzzleãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            # 4. puzzleãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('puzzle') and not action_taken:\r\n                 x, y = detections['puzzle']\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n@@ -135,9 +152,9 @@\n                     device_state.tap_count += 1\r\n                     action_taken = True\r\n                     self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PUZZLEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n-            # 4. waza_okãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            # 5. waza_okãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('waza_ok') and not action_taken:\r\n                 x, y = detections['waza_ok']\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n@@ -146,9 +163,9 @@\n                     device_state.tap_count += 1\r\n                     action_taken = True\r\n                     self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: WAZA_OKã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n-            # 5. nextãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            # 6. nextãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('next') and not action_taken:\r\n                 x, y = detections['next']\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n@@ -165,10 +182,9 @@\n             \r\n         except Exception as e:\r\n             device_state.error_count += 1\r\n             self.logger.error(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}\")\r\n-            \r\n-            # ã‚¨ãƒ©ãƒ¼å›æ•°ãŒä¸Šé™ã‚’è¶…ãˆãŸå ´åˆã€ãƒ‡ãƒã‚¤ã‚¹ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹\r\n+              # ã‚¨ãƒ©ãƒ¼å›æ•°ãŒä¸Šé™ã‚’è¶…ãˆãŸå ´åˆã€ãƒ‡ãƒã‚¤ã‚¹ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹\r\n             if device_state.error_count >= self.max_error_count:\r\n                 device_state.is_active = False\r\n                 self.logger.warning(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ãŒã‚¨ãƒ©ãƒ¼ä¸Šé™ã«é”ã—ãŸãŸã‚éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ã¾ã—ãŸ\")\r\n     \r\n@@ -195,16 +211,20 @@\n                 tasks = []\r\n                 for device_id, detections in detection_results.items():\r\n                     if device_id in self.device_states:\r\n                         task = self.process_device_detection(device_id, detections)\r\n-                        tasks.append(task)                \r\n+                        tasks.append(task)\r\n+                \r\n                 # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®å‡¦ç†ã‚’ä¸¦è¡Œå®Ÿè¡Œ\r\n                 if tasks:\r\n                     await asyncio.gather(*tasks, return_exceptions=True)\r\n-                \r\n-                # çŸ­ã„å¾…æ©Ÿ\r\n+                  # çŸ­ã„å¾…æ©Ÿ\r\n                 await asyncio.sleep(self.screen_capture_interval)\r\n                 \r\n+            except asyncio.CancelledError:\r\n+                # ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã¯æ­£å¸¸çµ‚äº†\r\n+                self.logger.info(\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ\")\r\n+                break\r\n             except Exception as e:\r\n                 self.logger.error(f\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚¨ãƒ©ãƒ¼: {e}\")\r\n                 await asyncio.sleep(1)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å°‘ã—é•·ã‚ã«å¾…æ©Ÿ\r\n     \r\n@@ -228,10 +248,20 @@\n             self.is_running = False\r\n     \r\n     def stop_automation(self):\r\n         \"\"\"è‡ªå‹•åŒ–ã‚’åœæ­¢\"\"\"\r\n+        self.logger.info(\"è‡ªå‹•åŒ–åœæ­¢è¦æ±‚ã‚’å—ä¿¡ã—ã¾ã—ãŸ\")\r\n         self.is_running = False\r\n-        self.logger.info(\"è‡ªå‹•åŒ–ã‚’åœæ­¢ã—ã¾ã—ãŸ\")\r\n+        \r\n+        # ç¾åœ¨å®Ÿè¡Œä¸­ã®ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Œã°ã‚­ãƒ£ãƒ³ã‚»ãƒ«\r\n+        try:\r\n+            current_loop = asyncio.get_running_loop()\r\n+            for task in asyncio.all_tasks(current_loop):\r\n+                if not task.done() and task != asyncio.current_task():\r\n+                    task.cancel()\r\n+        except RuntimeError:\r\n+            # ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ãŒå®Ÿè¡Œã•ã‚Œã¦ã„ãªã„å ´åˆã¯ç„¡è¦–\r\n+            pass\r\n     \r\n     def get_statistics(self) -> Dict:\r\n         \"\"\"çµ±è¨ˆæƒ…å ±ã‚’å–å¾—\"\"\"\r\n         current_time = time.time()\r\n"
                },
                {
                    "date": 1750499362725,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,17 +88,17 @@\n         if not device_state.is_active:\r\n             return\r\n         \r\n         current_time = time.time()\r\n-          # ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\r\n+        \r\n+        # ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\r\n         if current_time - device_state.last_action_time < self.tap_cooldown:\r\n             return\r\n         \r\n         try:\r\n             # å„ªå…ˆåº¦é †ã§å‡¦ç†\r\n             action_taken = False\r\n-            \r\n-            # 1. bossãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+              # 1. bossãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('boss') and not action_taken:\r\n                 x, y = detections['boss']\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n@@ -182,9 +182,10 @@\n             \r\n         except Exception as e:\r\n             device_state.error_count += 1\r\n             self.logger.error(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}\")\r\n-              # ã‚¨ãƒ©ãƒ¼å›æ•°ãŒä¸Šé™ã‚’è¶…ãˆãŸå ´åˆã€ãƒ‡ãƒã‚¤ã‚¹ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹\r\n+            \r\n+            # ã‚¨ãƒ©ãƒ¼å›æ•°ãŒä¸Šé™ã‚’è¶…ãˆãŸå ´åˆã€ãƒ‡ãƒã‚¤ã‚¹ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹\r\n             if device_state.error_count >= self.max_error_count:\r\n                 device_state.is_active = False\r\n                 self.logger.warning(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ãŒã‚¨ãƒ©ãƒ¼ä¸Šé™ã«é”ã—ãŸãŸã‚éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ã¾ã—ãŸ\")\r\n     \r\n@@ -211,20 +212,16 @@\n                 tasks = []\r\n                 for device_id, detections in detection_results.items():\r\n                     if device_id in self.device_states:\r\n                         task = self.process_device_detection(device_id, detections)\r\n-                        tasks.append(task)\r\n-                \r\n+                        tasks.append(task)                \r\n                 # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®å‡¦ç†ã‚’ä¸¦è¡Œå®Ÿè¡Œ\r\n                 if tasks:\r\n                     await asyncio.gather(*tasks, return_exceptions=True)\r\n-                  # çŸ­ã„å¾…æ©Ÿ\r\n+                \r\n+                # çŸ­ã„å¾…æ©Ÿ\r\n                 await asyncio.sleep(self.screen_capture_interval)\r\n                 \r\n-            except asyncio.CancelledError:\r\n-                # ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸå ´åˆã¯æ­£å¸¸çµ‚äº†\r\n-                self.logger.info(\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ\")\r\n-                break\r\n             except Exception as e:\r\n                 self.logger.error(f\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚¨ãƒ©ãƒ¼: {e}\")\r\n                 await asyncio.sleep(1)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å°‘ã—é•·ã‚ã«å¾…æ©Ÿ\r\n     \r\n@@ -248,20 +245,10 @@\n             self.is_running = False\r\n     \r\n     def stop_automation(self):\r\n         \"\"\"è‡ªå‹•åŒ–ã‚’åœæ­¢\"\"\"\r\n-        self.logger.info(\"è‡ªå‹•åŒ–åœæ­¢è¦æ±‚ã‚’å—ä¿¡ã—ã¾ã—ãŸ\")\r\n         self.is_running = False\r\n-        \r\n-        # ç¾åœ¨å®Ÿè¡Œä¸­ã®ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Œã°ã‚­ãƒ£ãƒ³ã‚»ãƒ«\r\n-        try:\r\n-            current_loop = asyncio.get_running_loop()\r\n-            for task in asyncio.all_tasks(current_loop):\r\n-                if not task.done() and task != asyncio.current_task():\r\n-                    task.cancel()\r\n-        except RuntimeError:\r\n-            # ã‚¤ãƒ™ãƒ³ãƒˆãƒ«ãƒ¼ãƒ—ãŒå®Ÿè¡Œã•ã‚Œã¦ã„ãªã„å ´åˆã¯ç„¡è¦–\r\n-            pass\r\n+        self.logger.info(\"è‡ªå‹•åŒ–ã‚’åœæ­¢ã—ã¾ã—ãŸ\")\r\n     \r\n     def get_statistics(self) -> Dict:\r\n         \"\"\"çµ±è¨ˆæƒ…å ±ã‚’å–å¾—\"\"\"\r\n         current_time = time.time()\r\n"
                },
                {
                    "date": 1750499785187,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,305 @@\n+import asyncio\r\n+import logging\r\n+import time\r\n+from typing import Dict, Optional, Tuple, List\r\n+from enum import Enum\r\n+from dataclasses import dataclass\r\n+from device_controller import MultiDeviceController\r\n+from image_detector import MultiDeviceImageDetector\r\n+\r\n+\r\n+class GameState(Enum):\r\n+    \"\"\"ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®åˆ—æŒ™\"\"\"\r\n+    IDLE = \"idle\"\r\n+    BOSS_DETECTED = \"boss_detected\"\r\n+    PLAY_DETECTED = \"play_detected\"\r\n+    PUZZLE_DETECTED = \"puzzle_detected\"\r\n+    WAZA_OK_DETECTED = \"waza_ok_detected\"\r\n+    NEXT_DETECTED = \"next_detected\"\r\n+    STAGE_45_DETECTED = \"stage_45_detected\"\r\n+\r\n+\r\n+@dataclass\r\n+class DeviceState:\r\n+    \"\"\"ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹\"\"\"\r\n+    device_id: str\r\n+    current_state: GameState = GameState.IDLE\r\n+    last_action_time: float = 0\r\n+    tap_count: int = 0\r\n+    error_count: int = 0\r\n+    is_active: bool = True\r\n+\r\n+\r\n+class AutomationEngine:\r\n+    \"\"\"å¦–æ€ªã‚¦ã‚©ãƒƒãƒã·ã«ã·ã«è‡ªå‹•å‘¨å›ã‚¨ãƒ³ã‚¸ãƒ³\"\"\"\r\n+    \r\n+    def __init__(self, template_dir: str = \"image\"):\r\n+        self.device_controller = MultiDeviceController()\r\n+        self.image_detector = MultiDeviceImageDetector(template_dir)\r\n+        self.device_states = {}\r\n+        self.is_running = False\r\n+        self.logger = logging.getLogger(__name__)\r\n+        \r\n+        # è¨­å®š\r\n+        self.detection_threshold = 0.8\r\n+        self.tap_cooldown = 0.5  # ã‚¿ãƒƒãƒ—é–“éš”ï¼ˆç§’ï¼‰\r\n+        self.screen_capture_interval = 0.1  # ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ï¼ˆç§’ï¼‰\r\n+        self.max_error_count = 5  # æœ€å¤§ã‚¨ãƒ©ãƒ¼å›æ•°\r\n+        \r\n+        # çµ±è¨ˆæƒ…å ±\r\n+        self.total_loops = 0\r\n+        self.start_time = 0\r\n+        \r\n+    def add_device(self, device_id: str) -> bool:\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’è¿½åŠ \"\"\"\r\n+        if self.device_controller.add_device(device_id):\r\n+            self.device_states[device_id] = DeviceState(device_id)\r\n+            self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã‚’è¿½åŠ ã—ã¾ã—ãŸ\")\r\n+            return True\r\n+        return False\r\n+    \r\n+    def remove_device(self, device_id: str):\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’å‰Šé™¤\"\"\"\r\n+        self.device_controller.remove_device(device_id)\r\n+        if device_id in self.device_states:\r\n+            del self.device_states[device_id]\r\n+        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã‚’å‰Šé™¤ã—ã¾ã—ãŸ\")\r\n+    \r\n+    def get_device_list(self) -> List[str]:\r\n+        \"\"\"ç®¡ç†ä¸­ã®ãƒ‡ãƒã‚¤ã‚¹ä¸€è¦§ã‚’å–å¾—\"\"\"\r\n+        return list(self.device_states.keys())\r\n+    \r\n+    def get_device_state(self, device_id: str) -> Optional[DeviceState]:\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’å–å¾—\"\"\"\r\n+        return self.device_states.get(device_id)\r\n+    \r\n+    def set_device_active(self, device_id: str, active: bool):\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è¨­å®š\"\"\"\r\n+        if device_id in self.device_states:\r\n+            self.device_states[device_id].is_active = active\r\n+    \r\n+    async def process_device_detection(self, device_id: str, \r\n+                                     detections: Dict[str, Optional[Tuple[int, int]]]):\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\"\"\"\r\n+        if device_id not in self.device_states:\r\n+            return\r\n+        \r\n+        device_state = self.device_states[device_id]\r\n+        if not device_state.is_active:\r\n+            return\r\n+        \r\n+        current_time = time.time()\r\n+        \r\n+        # ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\r\n+        if current_time - device_state.last_action_time < self.tap_cooldown:\r\n+            return\r\n+        \r\n+        try:\r\n+            # å„ªå…ˆåº¦é †ã§å‡¦ç†\r\n+            action_taken = False\r\n+            \r\n+            # menu, ranking, yubinãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ä½•ã‚‚ã—ãªã„\r\n+            if any([\r\n+                detections.get('menu'),\r\n+                detections.get('ranking'),\r\n+                detections.get('yubin')\r\n+            ]):\r\n+                self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: menu/ranking/yubinãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚ä½•ã‚‚ã‚¿ãƒƒãƒ—ã—ã¾ã›ã‚“\")\r\n+                return\r\n+            \r\n+            # 1. bossãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('boss') and not action_taken:\r\n+                x, y = detections['boss']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.BOSS_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: BOSSã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            \r\n+            # 2. playãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('play') and not action_taken:\r\n+                x, y = detections['play']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.PLAY_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PLAYã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            \r\n+            # 3. close/close_miniãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—ï¼ˆãŸã ã—stage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰\r\n+            if not action_taken and not detections.get('stage_45'):\r\n+                if detections.get('close'):\r\n+                    x, y = detections['close']\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.IDLE\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+                elif detections.get('close_mini'):\r\n+                    x, y = detections['close_mini']\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.IDLE\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSE_MINIã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            elif detections.get('stage_45'):\r\n+                self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: stage_45ãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚ã€close/close_miniã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™\")\r\n+            \r\n+            # 4. puzzleãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('puzzle') and not action_taken:\r\n+                x, y = detections['puzzle']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.PUZZLE_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PUZZLEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            \r\n+            # 5. waza_okãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('waza_ok') and not action_taken:\r\n+                x, y = detections['waza_ok']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.WAZA_OK_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: WAZA_OKã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            \r\n+            # 6. nextãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('next') and not action_taken:\r\n+                x, y = detections['next']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.NEXT_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.total_loops += 1  # ãƒ«ãƒ¼ãƒ—å®Œäº†ã®ã‚«ã‚¦ãƒ³ãƒˆ\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: NEXTã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸï¼ˆãƒ«ãƒ¼ãƒ—å®Œäº†: {self.total_loops}ï¼‰\")\r\n+            \r\n+            # ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ\r\n+            if action_taken:\r\n+                device_state.error_count = 0\r\n+            \r\n+        except Exception as e:\r\n+            device_state.error_count += 1\r\n+            self.logger.error(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}\")\r\n+            \r\n+            # ã‚¨ãƒ©ãƒ¼å›æ•°ãŒä¸Šé™ã‚’è¶…ãˆãŸå ´åˆã€ãƒ‡ãƒã‚¤ã‚¹ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹\r\n+            if device_state.error_count >= self.max_error_count:\r\n+                device_state.is_active = False\r\n+                self.logger.warning(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ãŒã‚¨ãƒ©ãƒ¼ä¸Šé™ã«é”ã—ãŸãŸã‚éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ã¾ã—ãŸ\")\r\n+    \r\n+    async def automation_loop(self):\r\n+        \"\"\"ãƒ¡ã‚¤ãƒ³è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—\"\"\"\r\n+        self.logger.info(\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã—ã¾ã™\")\r\n+        self.start_time = time.time()\r\n+        \r\n+        while self.is_running:\r\n+            try:\r\n+                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£\r\n+                screen_data = await self.device_controller.capture_all_screens()\r\n+                \r\n+                if not screen_data:\r\n+                    await asyncio.sleep(self.screen_capture_interval)\r\n+                    continue\r\n+                \r\n+                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã§ç”»åƒæ¤œå‡º\r\n+                detection_results = await self.image_detector.detect_all_devices(\r\n+                    screen_data, self.detection_threshold\r\n+                )\r\n+                \r\n+                # å„ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\r\n+                tasks = []\r\n+                for device_id, detections in detection_results.items():\r\n+                    if device_id in self.device_states:\r\n+                        task = self.process_device_detection(device_id, detections)\r\n+                        tasks.append(task)                \r\n+                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®å‡¦ç†ã‚’ä¸¦è¡Œå®Ÿè¡Œ\r\n+                if tasks:\r\n+                    await asyncio.gather(*tasks, return_exceptions=True)\r\n+                \r\n+                # çŸ­ã„å¾…æ©Ÿ\r\n+                await asyncio.sleep(self.screen_capture_interval)\r\n+                \r\n+            except Exception as e:\r\n+                self.logger.error(f\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚¨ãƒ©ãƒ¼: {e}\")\r\n+                await asyncio.sleep(1)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å°‘ã—é•·ã‚ã«å¾…æ©Ÿ\r\n+    \r\n+    async def start_automation(self):\r\n+        \"\"\"è‡ªå‹•åŒ–ã‚’é–‹å§‹\"\"\"\r\n+        if self.is_running:\r\n+            self.logger.warning(\"è‡ªå‹•åŒ–ã¯æ—¢ã«å®Ÿè¡Œä¸­ã§ã™\")\r\n+            return\r\n+        \r\n+        if not self.device_states:\r\n+            self.logger.error(\"ãƒ‡ãƒã‚¤ã‚¹ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“\")\r\n+            return\r\n+        \r\n+        self.is_running = True\r\n+        self.total_loops = 0\r\n+        try:\r\n+            await self.automation_loop()\r\n+        except Exception as e:\r\n+            self.logger.error(f\"è‡ªå‹•åŒ–å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}\")\r\n+        finally:\r\n+            self.is_running = False\r\n+    \r\n+    def stop_automation(self):\r\n+        \"\"\"è‡ªå‹•åŒ–ã‚’åœæ­¢\"\"\"\r\n+        self.is_running = False\r\n+        self.logger.info(\"è‡ªå‹•åŒ–ã‚’åœæ­¢ã—ã¾ã—ãŸ\")\r\n+    \r\n+    def get_statistics(self) -> Dict:\r\n+        \"\"\"çµ±è¨ˆæƒ…å ±ã‚’å–å¾—\"\"\"\r\n+        current_time = time.time()\r\n+        elapsed_time = current_time - self.start_time if self.start_time > 0 else 0\r\n+        \r\n+        stats = {\r\n+            'total_loops': self.total_loops,\r\n+            'elapsed_time': elapsed_time,\r\n+            'loops_per_hour': (self.total_loops / elapsed_time * 3600) if elapsed_time > 0 else 0,\r\n+            'active_devices': len([d for d in self.device_states.values() if d.is_active]),\r\n+            'total_devices': len(self.device_states),\r\n+            'device_details': {}\r\n+        }\r\n+        \r\n+        for device_id, state in self.device_states.items():\r\n+            stats['device_details'][device_id] = {\r\n+                'state': state.current_state.value,\r\n+                'tap_count': state.tap_count,\r\n+                'error_count': state.error_count,\r\n+                'is_active': state.is_active,\r\n+                'last_action_time': state.last_action_time\r\n+            }\r\n+        \r\n+        return stats\r\n+    \r\n+    def reset_statistics(self):\r\n+        \"\"\"çµ±è¨ˆæƒ…å ±ã‚’ãƒªã‚»ãƒƒãƒˆ\"\"\"\r\n+        self.total_loops = 0\r\n+        self.start_time = time.time()\r\n+        for state in self.device_states.values():\r\n+            state.tap_count = 0\r\n+            state.error_count = 0\r\n+    \r\n+    def set_detection_threshold(self, threshold: float):\r\n+        \"\"\"æ¤œå‡ºé–¾å€¤ã‚’è¨­å®š\"\"\"\r\n+        self.detection_threshold = max(0.1, min(1.0, threshold))\r\n+    \r\n+    def set_tap_cooldown(self, cooldown: float):\r\n+        \"\"\"ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’è¨­å®š\"\"\"\r\n+        self.tap_cooldown = max(0.1, cooldown)\r\n+    \r\n+    def set_capture_interval(self, interval: float):\r\n+        \"\"\"ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ã‚’è¨­å®š\"\"\"\r\n+        self.screen_capture_interval = max(0.05, interval)\r\n"
                },
                {
                    "date": 1750503530469,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,14 @@\n import asyncio\r\n import logging\r\n import time\r\n+import random\r\n from typing import Dict, Optional, Tuple, List\r\n from enum import Enum\r\n from dataclasses import dataclass\r\n from device_controller import MultiDeviceController\r\n from image_detector import MultiDeviceImageDetector\r\n+from config_manager import ConfigManager\r\n \r\n \r\n class GameState(Enum):\r\n     \"\"\"ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®åˆ—æŒ™\"\"\"\r\n@@ -49,8 +51,12 @@\n         # çµ±è¨ˆæƒ…å ±\r\n         self.total_loops = 0\r\n         self.start_time = 0\r\n         \r\n+        # ç”»åƒã‚¿ãƒƒãƒ—ãƒ©ãƒ³ãƒ€ãƒ å¹…è¨­å®š\r\n+        self.config_manager = ConfigManager()\r\n+        self.image_random_ranges = self.config_manager.get_image_random_ranges()\r\n+        \r\n     def add_device(self, device_id: str) -> bool:\r\n         \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’è¿½åŠ \"\"\"\r\n         if self.device_controller.add_device(device_id):\r\n             self.device_states[device_id] = DeviceState(device_id)\r\n@@ -77,8 +83,12 @@\n         \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è¨­å®š\"\"\"\r\n         if device_id in self.device_states:\r\n             self.device_states[device_id].is_active = active\r\n     \r\n+    def reload_image_random_ranges(self):\r\n+        \"\"\"ç”»åƒã‚¿ãƒƒãƒ—ãƒ©ãƒ³ãƒ€ãƒ å¹…è¨­å®šã‚’ãƒªãƒ­ãƒ¼ãƒ‰\"\"\"\r\n+        self.image_random_ranges = self.config_manager.get_image_random_ranges()\r\n+\r\n     async def process_device_detection(self, device_id: str, \r\n                                      detections: Dict[str, Optional[Tuple[int, int]]]):\r\n         \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\"\"\"\r\n         if device_id not in self.device_states:\r\n@@ -109,326 +119,41 @@\n             \r\n             # 1. bossãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('boss') and not action_taken:\r\n                 x, y = detections['boss']\r\n+                rx = self.image_random_ranges.get('boss.jpg', 0)\r\n+                x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.BOSS_DETECTED\r\n                     device_state.last_action_time = current_time\r\n                     device_state.tap_count += 1\r\n                     action_taken = True\r\n                     self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: BOSSã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n-            # 2. playãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('play') and not action_taken:\r\n-                x, y = detections['play']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.PLAY_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PLAYã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            \r\n-            # 3. close/close_miniãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—ï¼ˆãŸã ã—stage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰\r\n-            if not action_taken and not detections.get('stage_45'):\r\n-                if detections.get('close'):\r\n-                    x, y = detections['close']\r\n+            # 2. play, play_2ãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            for play_key, play_file in [('play', 'play.png'), ('play_2', 'play_2.png')]:\r\n+                if detections.get(play_key) and not action_taken:\r\n+                    x, y = detections[play_key]\r\n+                    rx = self.image_random_ranges.get(play_file, 0)\r\n+                    x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                    y += random.randint(-rx, rx) if rx > 0 else 0\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n-                        device_state.current_state = GameState.IDLE\r\n+                        device_state.current_state = GameState.PLAY_DETECTED\r\n                         device_state.last_action_time = current_time\r\n                         device_state.tap_count += 1\r\n                         action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-                elif detections.get('close_mini'):\r\n-                    x, y = detections['close_mini']\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.IDLE\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSE_MINIã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            elif detections.get('stage_45'):\r\n-                self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: stage_45ãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚ã€close/close_miniã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™\")\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: {play_key.upper()}ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n-            # 4. puzzleãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('puzzle') and not action_taken:\r\n-                x, y = detections['puzzle']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.PUZZLE_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PUZZLEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            \r\n-            # 5. waza_okãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('waza_ok') and not action_taken:\r\n-                x, y = detections['waza_ok']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.WAZA_OK_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: WAZA_OKã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            \r\n-            # 6. nextãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('next') and not action_taken:\r\n-                x, y = detections['next']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.NEXT_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.total_loops += 1  # ãƒ«ãƒ¼ãƒ—å®Œäº†ã®ã‚«ã‚¦ãƒ³ãƒˆ\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: NEXTã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸï¼ˆãƒ«ãƒ¼ãƒ—å®Œäº†: {self.total_loops}ï¼‰\")\r\n-            \r\n-            # ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ\r\n-            if action_taken:\r\n-                device_state.error_count = 0\r\n-            \r\n-        except Exception as e:\r\n-            device_state.error_count += 1\r\n-            self.logger.error(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}\")\r\n-            \r\n-            # ã‚¨ãƒ©ãƒ¼å›æ•°ãŒä¸Šé™ã‚’è¶…ãˆãŸå ´åˆã€ãƒ‡ãƒã‚¤ã‚¹ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹\r\n-            if device_state.error_count >= self.max_error_count:\r\n-                device_state.is_active = False\r\n-                self.logger.warning(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ãŒã‚¨ãƒ©ãƒ¼ä¸Šé™ã«é”ã—ãŸãŸã‚éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ã¾ã—ãŸ\")\r\n-    \r\n-    async def automation_loop(self):\r\n-        \"\"\"ãƒ¡ã‚¤ãƒ³è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—\"\"\"\r\n-        self.logger.info(\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã—ã¾ã™\")\r\n-        self.start_time = time.time()\r\n-        \r\n-        while self.is_running:\r\n-            try:\r\n-                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£\r\n-                screen_data = await self.device_controller.capture_all_screens()\r\n-                \r\n-                if not screen_data:\r\n-                    await asyncio.sleep(self.screen_capture_interval)\r\n-                    continue\r\n-                \r\n-                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã§ç”»åƒæ¤œå‡º\r\n-                detection_results = await self.image_detector.detect_all_devices(\r\n-                    screen_data, self.detection_threshold\r\n-                )\r\n-                \r\n-                # å„ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\r\n-                tasks = []\r\n-                for device_id, detections in detection_results.items():\r\n-                    if device_id in self.device_states:\r\n-                        task = self.process_device_detection(device_id, detections)\r\n-                        tasks.append(task)                \r\n-                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®å‡¦ç†ã‚’ä¸¦è¡Œå®Ÿè¡Œ\r\n-                if tasks:\r\n-                    await asyncio.gather(*tasks, return_exceptions=True)\r\n-                \r\n-                # çŸ­ã„å¾…æ©Ÿ\r\n-                await asyncio.sleep(self.screen_capture_interval)\r\n-                \r\n-            except Exception as e:\r\n-                self.logger.error(f\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚¨ãƒ©ãƒ¼: {e}\")\r\n-                await asyncio.sleep(1)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å°‘ã—é•·ã‚ã«å¾…æ©Ÿ\r\n-    \r\n-    async def start_automation(self):\r\n-        \"\"\"è‡ªå‹•åŒ–ã‚’é–‹å§‹\"\"\"\r\n-        if self.is_running:\r\n-            self.logger.warning(\"è‡ªå‹•åŒ–ã¯æ—¢ã«å®Ÿè¡Œä¸­ã§ã™\")\r\n-            return\r\n-        \r\n-        if not self.device_states:\r\n-            self.logger.error(\"ãƒ‡ãƒã‚¤ã‚¹ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“\")\r\n-            return\r\n-        \r\n-        self.is_running = True\r\n-        self.total_loops = 0\r\n-        try:\r\n-            await self.automation_loop()\r\n-        except Exception as e:\r\n-            self.logger.error(f\"è‡ªå‹•åŒ–å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}\")\r\n-        finally:\r\n-            self.is_running = False\r\n-    \r\n-    def stop_automation(self):\r\n-        \"\"\"è‡ªå‹•åŒ–ã‚’åœæ­¢\"\"\"\r\n-        self.is_running = False\r\n-        self.logger.info(\"è‡ªå‹•åŒ–ã‚’åœæ­¢ã—ã¾ã—ãŸ\")\r\n-    \r\n-    def get_statistics(self) -> Dict:\r\n-        \"\"\"çµ±è¨ˆæƒ…å ±ã‚’å–å¾—\"\"\"\r\n-        current_time = time.time()\r\n-        elapsed_time = current_time - self.start_time if self.start_time > 0 else 0\r\n-        \r\n-        stats = {\r\n-            'total_loops': self.total_loops,\r\n-            'elapsed_time': elapsed_time,\r\n-            'loops_per_hour': (self.total_loops / elapsed_time * 3600) if elapsed_time > 0 else 0,\r\n-            'active_devices': len([d for d in self.device_states.values() if d.is_active]),\r\n-            'total_devices': len(self.device_states),\r\n-            'device_details': {}\r\n-        }\r\n-        \r\n-        for device_id, state in self.device_states.items():\r\n-            stats['device_details'][device_id] = {\r\n-                'state': state.current_state.value,\r\n-                'tap_count': state.tap_count,\r\n-                'error_count': state.error_count,\r\n-                'is_active': state.is_active,\r\n-                'last_action_time': state.last_action_time\r\n-            }\r\n-        \r\n-        return stats\r\n-    \r\n-    def reset_statistics(self):\r\n-        \"\"\"çµ±è¨ˆæƒ…å ±ã‚’ãƒªã‚»ãƒƒãƒˆ\"\"\"\r\n-        self.total_loops = 0\r\n-        self.start_time = time.time()\r\n-        for state in self.device_states.values():\r\n-            state.tap_count = 0\r\n-            state.error_count = 0\r\n-    \r\n-    def set_detection_threshold(self, threshold: float):\r\n-        \"\"\"æ¤œå‡ºé–¾å€¤ã‚’è¨­å®š\"\"\"\r\n-        self.detection_threshold = max(0.1, min(1.0, threshold))\r\n-    \r\n-    def set_tap_cooldown(self, cooldown: float):\r\n-        \"\"\"ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’è¨­å®š\"\"\"\r\n-        self.tap_cooldown = max(0.1, cooldown)\r\n-    \r\n-    def set_capture_interval(self, interval: float):\r\n-        \"\"\"ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ã‚’è¨­å®š\"\"\"\r\n-        self.screen_capture_interval = max(0.05, interval)\r\n-import asyncio\r\n-import logging\r\n-import time\r\n-from typing import Dict, Optional, Tuple, List\r\n-from enum import Enum\r\n-from dataclasses import dataclass\r\n-from device_controller import MultiDeviceController\r\n-from image_detector import MultiDeviceImageDetector\r\n-\r\n-\r\n-class GameState(Enum):\r\n-    \"\"\"ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®åˆ—æŒ™\"\"\"\r\n-    IDLE = \"idle\"\r\n-    BOSS_DETECTED = \"boss_detected\"\r\n-    PLAY_DETECTED = \"play_detected\"\r\n-    PUZZLE_DETECTED = \"puzzle_detected\"\r\n-    WAZA_OK_DETECTED = \"waza_ok_detected\"\r\n-    NEXT_DETECTED = \"next_detected\"\r\n-    STAGE_45_DETECTED = \"stage_45_detected\"\r\n-\r\n-\r\n-@dataclass\r\n-class DeviceState:\r\n-    \"\"\"ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹\"\"\"\r\n-    device_id: str\r\n-    current_state: GameState = GameState.IDLE\r\n-    last_action_time: float = 0\r\n-    tap_count: int = 0\r\n-    error_count: int = 0\r\n-    is_active: bool = True\r\n-\r\n-\r\n-class AutomationEngine:\r\n-    \"\"\"å¦–æ€ªã‚¦ã‚©ãƒƒãƒã·ã«ã·ã«è‡ªå‹•å‘¨å›ã‚¨ãƒ³ã‚¸ãƒ³\"\"\"\r\n-    \r\n-    def __init__(self, template_dir: str = \"image\"):\r\n-        self.device_controller = MultiDeviceController()\r\n-        self.image_detector = MultiDeviceImageDetector(template_dir)\r\n-        self.device_states = {}\r\n-        self.is_running = False\r\n-        self.logger = logging.getLogger(__name__)\r\n-        \r\n-        # è¨­å®š\r\n-        self.detection_threshold = 0.8\r\n-        self.tap_cooldown = 0.5  # ã‚¿ãƒƒãƒ—é–“éš”ï¼ˆç§’ï¼‰\r\n-        self.screen_capture_interval = 0.1  # ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ï¼ˆç§’ï¼‰\r\n-        self.max_error_count = 5  # æœ€å¤§ã‚¨ãƒ©ãƒ¼å›æ•°\r\n-        \r\n-        # çµ±è¨ˆæƒ…å ±\r\n-        self.total_loops = 0\r\n-        self.start_time = 0\r\n-        \r\n-    def add_device(self, device_id: str) -> bool:\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’è¿½åŠ \"\"\"\r\n-        if self.device_controller.add_device(device_id):\r\n-            self.device_states[device_id] = DeviceState(device_id)\r\n-            self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã‚’è¿½åŠ ã—ã¾ã—ãŸ\")\r\n-            return True\r\n-        return False\r\n-    \r\n-    def remove_device(self, device_id: str):\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’å‰Šé™¤\"\"\"\r\n-        self.device_controller.remove_device(device_id)\r\n-        if device_id in self.device_states:\r\n-            del self.device_states[device_id]\r\n-        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã‚’å‰Šé™¤ã—ã¾ã—ãŸ\")\r\n-    \r\n-    def get_device_list(self) -> List[str]:\r\n-        \"\"\"ç®¡ç†ä¸­ã®ãƒ‡ãƒã‚¤ã‚¹ä¸€è¦§ã‚’å–å¾—\"\"\"\r\n-        return list(self.device_states.keys())\r\n-    \r\n-    def get_device_state(self, device_id: str) -> Optional[DeviceState]:\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’å–å¾—\"\"\"\r\n-        return self.device_states.get(device_id)\r\n-    \r\n-    def set_device_active(self, device_id: str, active: bool):\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è¨­å®š\"\"\"\r\n-        if device_id in self.device_states:\r\n-            self.device_states[device_id].is_active = active\r\n-    \r\n-    async def process_device_detection(self, device_id: str, \r\n-                                     detections: Dict[str, Optional[Tuple[int, int]]]):\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\"\"\"\r\n-        if device_id not in self.device_states:\r\n-            return\r\n-        \r\n-        device_state = self.device_states[device_id]\r\n-        if not device_state.is_active:\r\n-            return\r\n-        \r\n-        current_time = time.time()\r\n-        \r\n-        # ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\r\n-        if current_time - device_state.last_action_time < self.tap_cooldown:\r\n-            return\r\n-        \r\n-        try:\r\n-            # å„ªå…ˆåº¦é †ã§å‡¦ç†\r\n-            action_taken = False\r\n-              # 1. bossãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('boss') and not action_taken:\r\n-                x, y = detections['boss']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.BOSS_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: BOSSã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            \r\n-            # 2. playãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('play') and not action_taken:\r\n-                x, y = detections['play']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.PLAY_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PLAYã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            \r\n             # 3. close/close_miniãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—ï¼ˆãŸã ã—stage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰\r\n             if not action_taken and not detections.get('stage_45'):\r\n                 if detections.get('close'):\r\n                     x, y = detections['close']\r\n+                    rx = self.image_random_ranges.get('close.png', 0)\r\n+                    x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                    y += random.randint(-rx, rx) if rx > 0 else 0\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n                         device_state.current_state = GameState.IDLE\r\n                         device_state.last_action_time = current_time\r\n@@ -436,8 +161,11 @@\n                         action_taken = True\r\n                         self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n                 elif detections.get('close_mini'):\r\n                     x, y = detections['close_mini']\r\n+                    rx = self.image_random_ranges.get('close_mini.png', 0)\r\n+                    x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                    y += random.randint(-rx, rx) if rx > 0 else 0\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n                         device_state.current_state = GameState.IDLE\r\n                         device_state.last_action_time = current_time\r\n@@ -449,8 +177,11 @@\n             \r\n             # 4. puzzleãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('puzzle') and not action_taken:\r\n                 x, y = detections['puzzle']\r\n+                rx = self.image_random_ranges.get('puzzle.png', 0)\r\n+                x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.PUZZLE_DETECTED\r\n                     device_state.last_action_time = current_time\r\n@@ -460,8 +191,11 @@\n             \r\n             # 5. waza_okãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('waza_ok') and not action_taken:\r\n                 x, y = detections['waza_ok']\r\n+                rx = self.image_random_ranges.get('waza_ok.png', 0)\r\n+                x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.WAZA_OK_DETECTED\r\n                     device_state.last_action_time = current_time\r\n@@ -471,8 +205,11 @@\n             \r\n             # 6. nextãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('next') and not action_taken:\r\n                 x, y = detections['next']\r\n+                rx = self.image_random_ranges.get('next.png', 0)\r\n+                x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.NEXT_DETECTED\r\n                     device_state.last_action_time = current_time\r\n"
                },
                {
                    "date": 1750503616001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,12 @@\n import asyncio\r\n import logging\r\n import time\r\n-import random\r\n from typing import Dict, Optional, Tuple, List\r\n from enum import Enum\r\n from dataclasses import dataclass\r\n from device_controller import MultiDeviceController\r\n from image_detector import MultiDeviceImageDetector\r\n-from config_manager import ConfigManager\r\n \r\n \r\n class GameState(Enum):\r\n     \"\"\"ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®åˆ—æŒ™\"\"\"\r\n@@ -51,12 +49,8 @@\n         # çµ±è¨ˆæƒ…å ±\r\n         self.total_loops = 0\r\n         self.start_time = 0\r\n         \r\n-        # ç”»åƒã‚¿ãƒƒãƒ—ãƒ©ãƒ³ãƒ€ãƒ å¹…è¨­å®š\r\n-        self.config_manager = ConfigManager()\r\n-        self.image_random_ranges = self.config_manager.get_image_random_ranges()\r\n-        \r\n     def add_device(self, device_id: str) -> bool:\r\n         \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’è¿½åŠ \"\"\"\r\n         if self.device_controller.add_device(device_id):\r\n             self.device_states[device_id] = DeviceState(device_id)\r\n@@ -83,12 +77,8 @@\n         \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è¨­å®š\"\"\"\r\n         if device_id in self.device_states:\r\n             self.device_states[device_id].is_active = active\r\n     \r\n-    def reload_image_random_ranges(self):\r\n-        \"\"\"ç”»åƒã‚¿ãƒƒãƒ—ãƒ©ãƒ³ãƒ€ãƒ å¹…è¨­å®šã‚’ãƒªãƒ­ãƒ¼ãƒ‰\"\"\"\r\n-        self.image_random_ranges = self.config_manager.get_image_random_ranges()\r\n-\r\n     async def process_device_detection(self, device_id: str, \r\n                                      detections: Dict[str, Optional[Tuple[int, int]]]):\r\n         \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\"\"\"\r\n         if device_id not in self.device_states:\r\n@@ -119,11 +109,8 @@\n             \r\n             # 1. bossãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('boss') and not action_taken:\r\n                 x, y = detections['boss']\r\n-                rx = self.image_random_ranges.get('boss.jpg', 0)\r\n-                x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.BOSS_DETECTED\r\n                     device_state.last_action_time = current_time\r\n@@ -131,14 +118,11 @@\n                     action_taken = True\r\n                     self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: BOSSã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n             # 2. play, play_2ãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            for play_key, play_file in [('play', 'play.png'), ('play_2', 'play_2.png')]:\r\n+            for play_key in ('play', 'play_2'):\r\n                 if detections.get(play_key) and not action_taken:\r\n                     x, y = detections[play_key]\r\n-                    rx = self.image_random_ranges.get(play_file, 0)\r\n-                    x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                    y += random.randint(-rx, rx) if rx > 0 else 0\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n                         device_state.current_state = GameState.PLAY_DETECTED\r\n                         device_state.last_action_time = current_time\r\n@@ -149,11 +133,8 @@\n             # 3. close/close_miniãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—ï¼ˆãŸã ã—stage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰\r\n             if not action_taken and not detections.get('stage_45'):\r\n                 if detections.get('close'):\r\n                     x, y = detections['close']\r\n-                    rx = self.image_random_ranges.get('close.png', 0)\r\n-                    x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                    y += random.randint(-rx, rx) if rx > 0 else 0\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n                         device_state.current_state = GameState.IDLE\r\n                         device_state.last_action_time = current_time\r\n@@ -161,11 +142,8 @@\n                         action_taken = True\r\n                         self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n                 elif detections.get('close_mini'):\r\n                     x, y = detections['close_mini']\r\n-                    rx = self.image_random_ranges.get('close_mini.png', 0)\r\n-                    x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                    y += random.randint(-rx, rx) if rx > 0 else 0\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n                         device_state.current_state = GameState.IDLE\r\n                         device_state.last_action_time = current_time\r\n@@ -177,11 +155,8 @@\n             \r\n             # 4. puzzleãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('puzzle') and not action_taken:\r\n                 x, y = detections['puzzle']\r\n-                rx = self.image_random_ranges.get('puzzle.png', 0)\r\n-                x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.PUZZLE_DETECTED\r\n                     device_state.last_action_time = current_time\r\n@@ -191,11 +166,8 @@\n             \r\n             # 5. waza_okãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('waza_ok') and not action_taken:\r\n                 x, y = detections['waza_ok']\r\n-                rx = self.image_random_ranges.get('waza_ok.png', 0)\r\n-                x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.WAZA_OK_DETECTED\r\n                     device_state.last_action_time = current_time\r\n@@ -205,11 +177,8 @@\n             \r\n             # 6. nextãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n             if detections.get('next') and not action_taken:\r\n                 x, y = detections['next']\r\n-                rx = self.image_random_ranges.get('next.png', 0)\r\n-                x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.NEXT_DETECTED\r\n                     device_state.last_action_time = current_time\r\n"
                },
                {
                    "date": 1750512636088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,8 +27,9 @@\n     last_action_time: float = 0\r\n     tap_count: int = 0\r\n     error_count: int = 0\r\n     is_active: bool = True\r\n+    hp_bar_tapped: bool = False  # hp_barã‚¿ãƒƒãƒ—æ¸ˆã¿ãƒ•ãƒ©ã‚°ã‚’è¿½åŠ \r\n \r\n \r\n class AutomationEngine:\r\n     \"\"\"å¦–æ€ªã‚¦ã‚©ãƒƒãƒã·ã«ã·ã«è‡ªå‹•å‘¨å›ã‚¨ãƒ³ã‚¸ãƒ³\"\"\"\r\n@@ -186,8 +187,22 @@\n                     action_taken = True\r\n                     self.total_loops += 1  # ãƒ«ãƒ¼ãƒ—å®Œäº†ã®ã‚«ã‚¦ãƒ³ãƒˆ\r\n                     self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: NEXTã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸï¼ˆãƒ«ãƒ¼ãƒ—å®Œäº†: {self.total_loops}ï¼‰\")\r\n             \r\n+            # hp_barãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã€1å›ã ã‘y+200ã‚’ã‚¿ãƒƒãƒ—\r\n+            if detections.get('hp_bar') and not device_state.hp_bar_tapped and not action_taken:\r\n+                x, y = detections['hp_bar']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y + 200)\r\n+                if success:\r\n+                    device_state.hp_bar_tapped = True\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: HP_BARã‚’y+200ã§ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            # hp_barãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ\r\n+            if not detections.get('hp_bar'):\r\n+                device_state.hp_bar_tapped = False\r\n+            \r\n             # ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ\r\n             if action_taken:\r\n                 device_state.error_count = 0\r\n             \r\n"
                },
                {
                    "date": 1750512866272,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,8 @@\n     last_action_time: float = 0\r\n     tap_count: int = 0\r\n     error_count: int = 0\r\n     is_active: bool = True\r\n-    hp_bar_tapped: bool = False  # hp_barã‚¿ãƒƒãƒ—æ¸ˆã¿ãƒ•ãƒ©ã‚°ã‚’è¿½åŠ \r\n \r\n \r\n class AutomationEngine:\r\n     \"\"\"å¦–æ€ªã‚¦ã‚©ãƒƒãƒã·ã«ã·ã«è‡ªå‹•å‘¨å›ã‚¨ãƒ³ã‚¸ãƒ³\"\"\"\r\n@@ -187,22 +186,8 @@\n                     action_taken = True\r\n                     self.total_loops += 1  # ãƒ«ãƒ¼ãƒ—å®Œäº†ã®ã‚«ã‚¦ãƒ³ãƒˆ\r\n                     self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: NEXTã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸï¼ˆãƒ«ãƒ¼ãƒ—å®Œäº†: {self.total_loops}ï¼‰\")\r\n             \r\n-            # hp_barãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã€1å›ã ã‘y+200ã‚’ã‚¿ãƒƒãƒ—\r\n-            if detections.get('hp_bar') and not device_state.hp_bar_tapped and not action_taken:\r\n-                x, y = detections['hp_bar']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y + 200)\r\n-                if success:\r\n-                    device_state.hp_bar_tapped = True\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: HP_BARã‚’y+200ã§ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            # hp_barãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ\r\n-            if not detections.get('hp_bar'):\r\n-                device_state.hp_bar_tapped = False\r\n-            \r\n             # ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ\r\n             if action_taken:\r\n                 device_state.error_count = 0\r\n             \r\n"
                },
                {
                    "date": 1750513034024,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,8 +27,9 @@\n     last_action_time: float = 0\r\n     tap_count: int = 0\r\n     error_count: int = 0\r\n     is_active: bool = True\r\n+    hp_bar_tap_time: float = 0  # hp_barã‚¿ãƒƒãƒ—æ™‚åˆ»\r\n \r\n \r\n class AutomationEngine:\r\n     \"\"\"å¦–æ€ªã‚¦ã‚©ãƒƒãƒã·ã«ã·ã«è‡ªå‹•å‘¨å›ã‚¨ãƒ³ã‚¸ãƒ³\"\"\"\r\n@@ -96,8 +97,22 @@\n         \r\n         try:\r\n             # å„ªå…ˆåº¦é †ã§å‡¦ç†\r\n             action_taken = False\r\n+\r\n+            # --- hp_baræ¤œçŸ¥æ™‚ã®ç‰¹æ®Šã‚¿ãƒƒãƒ— ---\r\n+            if detections.get('hp_bar') and not action_taken:\r\n+                x, y = detections['hp_bar']\r\n+                # ç›´è¿‘1ç§’ä»¥å†…ã«ã‚¿ãƒƒãƒ—ã—ã¦ã„ãªã‘ã‚Œã°1å›ã ã‘ã‚¿ãƒƒãƒ—\r\n+                if current_time - device_state.hp_bar_tap_time > 1.0:\r\n+                    tap_x, tap_y = x, y + 200\r\n+                    success = await self.device_controller.devices[device_id].tap_async(tap_x, tap_y)\r\n+                    if success:\r\n+                        device_state.hp_bar_tap_time = current_time\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: hp_barã‚’æ¤œçŸ¥ã—ä¸­å¤®y+200ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n             # menu, ranking, yubinãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ä½•ã‚‚ã—ãªã„\r\n             if any([\r\n                 detections.get('menu'),\r\n"
                },
                {
                    "date": 1750513169157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -132,10 +132,10 @@\n                     device_state.tap_count += 1\r\n                     action_taken = True\r\n                     self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: BOSSã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n-            # 2. play, play_2ãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            for play_key in ('play', 'play_2'):\r\n+            # --- play, play_1, play_2ãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ— ---\r\n+            for play_key in ('play', 'play_1', 'play_2'):\r\n                 if detections.get(play_key) and not action_taken:\r\n                     x, y = detections[play_key]\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n"
                },
                {
                    "date": 1750513273040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,9 +99,13 @@\n             # å„ªå…ˆåº¦é †ã§å‡¦ç†\r\n             action_taken = False\r\n \r\n             # --- hp_baræ¤œçŸ¥æ™‚ã®ç‰¹æ®Šã‚¿ãƒƒãƒ— ---\r\n-            if detections.get('hp_bar') and not action_taken:\r\n+            # ãŸã ã—waza_ok_1ã¾ãŸã¯waza_ok_2ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚Œã°hp_barã¯ã‚¹ã‚­ãƒƒãƒ—\r\n+            if (\r\n+                detections.get('hp_bar') and not action_taken and\r\n+                not (detections.get('waza_ok_1') or detections.get('waza_ok_2'))\r\n+            ):\r\n                 x, y = detections['hp_bar']\r\n                 # ç›´è¿‘1ç§’ä»¥å†…ã«ã‚¿ãƒƒãƒ—ã—ã¦ã„ãªã‘ã‚Œã°1å›ã ã‘ã‚¿ãƒƒãƒ—\r\n                 if current_time - device_state.hp_bar_tap_time > 1.0:\r\n                     tap_x, tap_y = x, y + 200\r\n@@ -112,8 +116,20 @@\n                         device_state.tap_count += 1\r\n                         action_taken = True\r\n                         self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: hp_barã‚’æ¤œçŸ¥ã—ä¸­å¤®y+200ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n             \r\n+            # --- waza_ok_1, waza_ok_2, waza_ok ---\r\n+            for waza_key in ('waza_ok', 'waza_ok_1', 'waza_ok_2'):\r\n+                if detections.get(waza_key) and not action_taken:\r\n+                    x, y = detections[waza_key]\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.WAZA_OK_DETECTED\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: {waza_key.upper()}ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            \r\n             # menu, ranking, yubinãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ä½•ã‚‚ã—ãªã„\r\n             if any([\r\n                 detections.get('menu'),\r\n                 detections.get('ranking'),\r\n"
                },
                {
                    "date": 1750513288467,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,337 @@\n+import asyncio\r\n+import logging\r\n+import time\r\n+from typing import Dict, Optional, Tuple, List\r\n+from enum import Enum\r\n+from dataclasses import dataclass\r\n+from device_controller import MultiDeviceController\r\n+from image_detector import MultiDeviceImageDetector\r\n+\r\n+\r\n+class GameState(Enum):\r\n+    \"\"\"ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®åˆ—æŒ™\"\"\"\r\n+    IDLE = \"idle\"\r\n+    BOSS_DETECTED = \"boss_detected\"\r\n+    PLAY_DETECTED = \"play_detected\"\r\n+    PUZZLE_DETECTED = \"puzzle_detected\"\r\n+    WAZA_OK_DETECTED = \"waza_ok_detected\"\r\n+    NEXT_DETECTED = \"next_detected\"\r\n+    STAGE_45_DETECTED = \"stage_45_detected\"\r\n+\r\n+\r\n+@dataclass\r\n+class DeviceState:\r\n+    \"\"\"ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹\"\"\"\r\n+    device_id: str\r\n+    current_state: GameState = GameState.IDLE\r\n+    last_action_time: float = 0\r\n+    tap_count: int = 0\r\n+    error_count: int = 0\r\n+    is_active: bool = True\r\n+    hp_bar_tap_time: float = 0  # hp_barã‚¿ãƒƒãƒ—æ™‚åˆ»\r\n+\r\n+\r\n+class AutomationEngine:\r\n+    \"\"\"å¦–æ€ªã‚¦ã‚©ãƒƒãƒã·ã«ã·ã«è‡ªå‹•å‘¨å›ã‚¨ãƒ³ã‚¸ãƒ³\"\"\"\r\n+    \r\n+    def __init__(self, template_dir: str = \"image\"):\r\n+        self.device_controller = MultiDeviceController()\r\n+        self.image_detector = MultiDeviceImageDetector(template_dir)\r\n+        self.device_states = {}\r\n+        self.is_running = False\r\n+        self.logger = logging.getLogger(__name__)\r\n+        \r\n+        # è¨­å®š\r\n+        self.detection_threshold = 0.8\r\n+        self.tap_cooldown = 0.5  # ã‚¿ãƒƒãƒ—é–“éš”ï¼ˆç§’ï¼‰\r\n+        self.screen_capture_interval = 0.1  # ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ï¼ˆç§’ï¼‰\r\n+        self.max_error_count = 5  # æœ€å¤§ã‚¨ãƒ©ãƒ¼å›æ•°\r\n+        \r\n+        # çµ±è¨ˆæƒ…å ±\r\n+        self.total_loops = 0\r\n+        self.start_time = 0\r\n+        \r\n+    def add_device(self, device_id: str) -> bool:\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’è¿½åŠ \"\"\"\r\n+        if self.device_controller.add_device(device_id):\r\n+            self.device_states[device_id] = DeviceState(device_id)\r\n+            self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã‚’è¿½åŠ ã—ã¾ã—ãŸ\")\r\n+            return True\r\n+        return False\r\n+    \r\n+    def remove_device(self, device_id: str):\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’å‰Šé™¤\"\"\"\r\n+        self.device_controller.remove_device(device_id)\r\n+        if device_id in self.device_states:\r\n+            del self.device_states[device_id]\r\n+        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã‚’å‰Šé™¤ã—ã¾ã—ãŸ\")\r\n+    \r\n+    def get_device_list(self) -> List[str]:\r\n+        \"\"\"ç®¡ç†ä¸­ã®ãƒ‡ãƒã‚¤ã‚¹ä¸€è¦§ã‚’å–å¾—\"\"\"\r\n+        return list(self.device_states.keys())\r\n+    \r\n+    def get_device_state(self, device_id: str) -> Optional[DeviceState]:\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’å–å¾—\"\"\"\r\n+        return self.device_states.get(device_id)\r\n+    \r\n+    def set_device_active(self, device_id: str, active: bool):\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è¨­å®š\"\"\"\r\n+        if device_id in self.device_states:\r\n+            self.device_states[device_id].is_active = active\r\n+    \r\n+    async def process_device_detection(self, device_id: str, \r\n+                                     detections: Dict[str, Optional[Tuple[int, int]]]):\r\n+        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\"\"\"\r\n+        if device_id not in self.device_states:\r\n+            return\r\n+        \r\n+        device_state = self.device_states[device_id]\r\n+        if not device_state.is_active:\r\n+            return\r\n+        \r\n+        current_time = time.time()\r\n+        \r\n+        # ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\r\n+        if current_time - device_state.last_action_time < self.tap_cooldown:\r\n+            return\r\n+        \r\n+        try:\r\n+            # å„ªå…ˆåº¦é †ã§å‡¦ç†\r\n+            action_taken = False\r\n+\r\n+            # --- hp_baræ¤œçŸ¥æ™‚ã®ç‰¹æ®Šã‚¿ãƒƒãƒ— ---\r\n+            # ãŸã ã—waza_ok_1ã¾ãŸã¯waza_ok_2ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚Œã°hp_barã¯ã‚¹ã‚­ãƒƒãƒ—\r\n+            if (\r\n+                detections.get('hp_bar') and not action_taken and\r\n+                not (detections.get('waza_ok_1') or detections.get('waza_ok_2'))\r\n+            ):\r\n+                x, y = detections['hp_bar']\r\n+                # ç›´è¿‘1ç§’ä»¥å†…ã«ã‚¿ãƒƒãƒ—ã—ã¦ã„ãªã‘ã‚Œã°1å›ã ã‘ã‚¿ãƒƒãƒ—\r\n+                if current_time - device_state.hp_bar_tap_time > 1.0:\r\n+                    tap_x, tap_y = x, y + 2700\r\n+                    success = await self.device_controller.devices[device_id].tap_async(tap_x, tap_y)\r\n+                    if success:\r\n+                        device_state.hp_bar_tap_time = current_time\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: hp_barã‚’æ¤œçŸ¥ã—ä¸­å¤®y+200ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            \r\n+            # --- waza_ok_1, waza_ok_2, waza_ok ---\r\n+            for waza_key in ('waza_ok', 'waza_ok_1', 'waza_ok_2'):\r\n+                if detections.get(waza_key) and not action_taken:\r\n+                    x, y = detections[waza_key]\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.WAZA_OK_DETECTED\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: {waza_key.upper()}ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            \r\n+            # menu, ranking, yubinãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ä½•ã‚‚ã—ãªã„\r\n+            if any([\r\n+                detections.get('menu'),\r\n+                detections.get('ranking'),\r\n+                detections.get('yubin')\r\n+            ]):\r\n+                self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: menu/ranking/yubinãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚ä½•ã‚‚ã‚¿ãƒƒãƒ—ã—ã¾ã›ã‚“\")\r\n+                return\r\n+            \r\n+            # 1. bossãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('boss') and not action_taken:\r\n+                x, y = detections['boss']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.BOSS_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: BOSSã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            \r\n+            # --- play, play_1, play_2ãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ— ---\r\n+            for play_key in ('play', 'play_1', 'play_2'):\r\n+                if detections.get(play_key) and not action_taken:\r\n+                    x, y = detections[play_key]\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.PLAY_DETECTED\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: {play_key.upper()}ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            \r\n+            # 3. close/close_miniãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—ï¼ˆãŸã ã—stage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰\r\n+            if not action_taken and not detections.get('stage_45'):\r\n+                if detections.get('close'):\r\n+                    x, y = detections['close']\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.IDLE\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+                elif detections.get('close_mini'):\r\n+                    x, y = detections['close_mini']\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.IDLE\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSE_MINIã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            elif detections.get('stage_45'):\r\n+                self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: stage_45ãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚ã€close/close_miniã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™\")\r\n+            \r\n+            # 4. puzzleãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('puzzle') and not action_taken:\r\n+                x, y = detections['puzzle']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.PUZZLE_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PUZZLEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            \r\n+            # 5. waza_okãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('waza_ok') and not action_taken:\r\n+                x, y = detections['waza_ok']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.WAZA_OK_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: WAZA_OKã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            \r\n+            # 6. nextãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n+            if detections.get('next') and not action_taken:\r\n+                x, y = detections['next']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.NEXT_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.total_loops += 1  # ãƒ«ãƒ¼ãƒ—å®Œäº†ã®ã‚«ã‚¦ãƒ³ãƒˆ\r\n+                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: NEXTã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸï¼ˆãƒ«ãƒ¼ãƒ—å®Œäº†: {self.total_loops}ï¼‰\")\r\n+            \r\n+            # ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ\r\n+            if action_taken:\r\n+                device_state.error_count = 0\r\n+            \r\n+        except Exception as e:\r\n+            device_state.error_count += 1\r\n+            self.logger.error(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}\")\r\n+            \r\n+            # ã‚¨ãƒ©ãƒ¼å›æ•°ãŒä¸Šé™ã‚’è¶…ãˆãŸå ´åˆã€ãƒ‡ãƒã‚¤ã‚¹ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹\r\n+            if device_state.error_count >= self.max_error_count:\r\n+                device_state.is_active = False\r\n+                self.logger.warning(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ãŒã‚¨ãƒ©ãƒ¼ä¸Šé™ã«é”ã—ãŸãŸã‚éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ã¾ã—ãŸ\")\r\n+    \r\n+    async def automation_loop(self):\r\n+        \"\"\"ãƒ¡ã‚¤ãƒ³è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—\"\"\"\r\n+        self.logger.info(\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã—ã¾ã™\")\r\n+        self.start_time = time.time()\r\n+        \r\n+        while self.is_running:\r\n+            try:\r\n+                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£\r\n+                screen_data = await self.device_controller.capture_all_screens()\r\n+                \r\n+                if not screen_data:\r\n+                    await asyncio.sleep(self.screen_capture_interval)\r\n+                    continue\r\n+                \r\n+                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã§ç”»åƒæ¤œå‡º\r\n+                detection_results = await self.image_detector.detect_all_devices(\r\n+                    screen_data, self.detection_threshold\r\n+                )\r\n+                \r\n+                # å„ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\r\n+                tasks = []\r\n+                for device_id, detections in detection_results.items():\r\n+                    if device_id in self.device_states:\r\n+                        task = self.process_device_detection(device_id, detections)\r\n+                        tasks.append(task)                \r\n+                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®å‡¦ç†ã‚’ä¸¦è¡Œå®Ÿè¡Œ\r\n+                if tasks:\r\n+                    await asyncio.gather(*tasks, return_exceptions=True)\r\n+                \r\n+                # çŸ­ã„å¾…æ©Ÿ\r\n+                await asyncio.sleep(self.screen_capture_interval)\r\n+                \r\n+            except Exception as e:\r\n+                self.logger.error(f\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚¨ãƒ©ãƒ¼: {e}\")\r\n+                await asyncio.sleep(1)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å°‘ã—é•·ã‚ã«å¾…æ©Ÿ\r\n+    \r\n+    async def start_automation(self):\r\n+        \"\"\"è‡ªå‹•åŒ–ã‚’é–‹å§‹\"\"\"\r\n+        if self.is_running:\r\n+            self.logger.warning(\"è‡ªå‹•åŒ–ã¯æ—¢ã«å®Ÿè¡Œä¸­ã§ã™\")\r\n+            return\r\n+        \r\n+        if not self.device_states:\r\n+            self.logger.error(\"ãƒ‡ãƒã‚¤ã‚¹ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“\")\r\n+            return\r\n+        \r\n+        self.is_running = True\r\n+        self.total_loops = 0\r\n+        try:\r\n+            await self.automation_loop()\r\n+        except Exception as e:\r\n+            self.logger.error(f\"è‡ªå‹•åŒ–å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}\")\r\n+        finally:\r\n+            self.is_running = False\r\n+    \r\n+    def stop_automation(self):\r\n+        \"\"\"è‡ªå‹•åŒ–ã‚’åœæ­¢\"\"\"\r\n+        self.is_running = False\r\n+        self.logger.info(\"è‡ªå‹•åŒ–ã‚’åœæ­¢ã—ã¾ã—ãŸ\")\r\n+    \r\n+    def get_statistics(self) -> Dict:\r\n+        \"\"\"çµ±è¨ˆæƒ…å ±ã‚’å–å¾—\"\"\"\r\n+        current_time = time.time()\r\n+        elapsed_time = current_time - self.start_time if self.start_time > 0 else 0\r\n+        \r\n+        stats = {\r\n+            'total_loops': self.total_loops,\r\n+            'elapsed_time': elapsed_time,\r\n+            'loops_per_hour': (self.total_loops / elapsed_time * 3600) if elapsed_time > 0 else 0,\r\n+            'active_devices': len([d for d in self.device_states.values() if d.is_active]),\r\n+            'total_devices': len(self.device_states),\r\n+            'device_details': {}\r\n+        }\r\n+        \r\n+        for device_id, state in self.device_states.items():\r\n+            stats['device_details'][device_id] = {\r\n+                'state': state.current_state.value,\r\n+                'tap_count': state.tap_count,\r\n+                'error_count': state.error_count,\r\n+                'is_active': state.is_active,\r\n+                'last_action_time': state.last_action_time\r\n+            }\r\n+        \r\n+        return stats\r\n+    \r\n+    def reset_statistics(self):\r\n+        \"\"\"çµ±è¨ˆæƒ…å ±ã‚’ãƒªã‚»ãƒƒãƒˆ\"\"\"\r\n+        self.total_loops = 0\r\n+        self.start_time = time.time()\r\n+        for state in self.device_states.values():\r\n+            state.tap_count = 0\r\n+            state.error_count = 0\r\n+    \r\n+    def set_detection_threshold(self, threshold: float):\r\n+        \"\"\"æ¤œå‡ºé–¾å€¤ã‚’è¨­å®š\"\"\"\r\n+        self.detection_threshold = max(0.1, min(1.0, threshold))\r\n+    \r\n+    def set_tap_cooldown(self, cooldown: float):\r\n+        \"\"\"ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’è¨­å®š\"\"\"\r\n+        self.tap_cooldown = max(0.1, cooldown)\r\n+    \r\n+    def set_capture_interval(self, interval: float):\r\n+        \"\"\"ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ã‚’è¨­å®š\"\"\"\r\n+        self.screen_capture_interval = max(0.05, interval)\r\n"
                },
                {
                    "date": 1750513611653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,363 +98,33 @@\n         try:\r\n             # å„ªå…ˆåº¦é †ã§å‡¦ç†\r\n             action_taken = False\r\n \r\n+            # --- hp_barã‚¿ãƒƒãƒ—æ¸ˆã¿ãƒ•ãƒ©ã‚° ---\r\n+            if not hasattr(device_state, 'hp_bar_tapped'):\r\n+                device_state.hp_bar_tapped = False\r\n+\r\n             # --- hp_baræ¤œçŸ¥æ™‚ã®ç‰¹æ®Šã‚¿ãƒƒãƒ— ---\r\n             # ãŸã ã—waza_ok_1ã¾ãŸã¯waza_ok_2ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚Œã°hp_barã¯ã‚¹ã‚­ãƒƒãƒ—\r\n             if (\r\n                 detections.get('hp_bar') and not action_taken and\r\n                 not (detections.get('waza_ok_1') or detections.get('waza_ok_2'))\r\n             ):\r\n-                x, y = detections['hp_bar']\r\n-                # ç›´è¿‘1ç§’ä»¥å†…ã«ã‚¿ãƒƒãƒ—ã—ã¦ã„ãªã‘ã‚Œã°1å›ã ã‘ã‚¿ãƒƒãƒ—\r\n-                if current_time - device_state.hp_bar_tap_time > 1.0:\r\n-                    tap_x, tap_y = x, y + 2700\r\n+                if not device_state.hp_bar_tapped:\r\n+                    x, y = detections['hp_bar']\r\n+                    tap_x, tap_y = x, y + 500\r\n                     success = await self.device_controller.devices[device_id].tap_async(tap_x, tap_y)\r\n                     if success:\r\n                         device_state.hp_bar_tap_time = current_time\r\n                         device_state.last_action_time = current_time\r\n                         device_state.tap_count += 1\r\n+                        device_state.hp_bar_tapped = True\r\n                         action_taken = True\r\n                         self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: hp_barã‚’æ¤œçŸ¥ã—ä¸­å¤®y+200ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            \r\n-            # --- waza_ok_1, waza_ok_2, waza_ok ---\r\n-            for waza_key in ('waza_ok', 'waza_ok_1', 'waza_ok_2'):\r\n-                if detections.get(waza_key) and not action_taken:\r\n-                    x, y = detections[waza_key]\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.WAZA_OK_DETECTED\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: {waza_key.upper()}ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            \r\n-            # menu, ranking, yubinãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ä½•ã‚‚ã—ãªã„\r\n-            if any([\r\n-                detections.get('menu'),\r\n-                detections.get('ranking'),\r\n-                detections.get('yubin')\r\n-            ]):\r\n-                self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: menu/ranking/yubinãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚ä½•ã‚‚ã‚¿ãƒƒãƒ—ã—ã¾ã›ã‚“\")\r\n-                return\r\n-            \r\n-            # 1. bossãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('boss') and not action_taken:\r\n-                x, y = detections['boss']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.BOSS_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: BOSSã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            \r\n-            # --- play, play_1, play_2ãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ— ---\r\n-            for play_key in ('play', 'play_1', 'play_2'):\r\n-                if detections.get(play_key) and not action_taken:\r\n-                    x, y = detections[play_key]\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.PLAY_DETECTED\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: {play_key.upper()}ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            \r\n-            # 3. close/close_miniãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—ï¼ˆãŸã ã—stage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰\r\n-            if not action_taken and not detections.get('stage_45'):\r\n-                if detections.get('close'):\r\n-                    x, y = detections['close']\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.IDLE\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-                elif detections.get('close_mini'):\r\n-                    x, y = detections['close_mini']\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.IDLE\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSE_MINIã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            elif detections.get('stage_45'):\r\n-                self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: stage_45ãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚ã€close/close_miniã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™\")\r\n-            \r\n-            # 4. puzzleãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('puzzle') and not action_taken:\r\n-                x, y = detections['puzzle']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.PUZZLE_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PUZZLEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            \r\n-            # 5. waza_okãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('waza_ok') and not action_taken:\r\n-                x, y = detections['waza_ok']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.WAZA_OK_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: WAZA_OKã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            \r\n-            # 6. nextãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('next') and not action_taken:\r\n-                x, y = detections['next']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.NEXT_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.total_loops += 1  # ãƒ«ãƒ¼ãƒ—å®Œäº†ã®ã‚«ã‚¦ãƒ³ãƒˆ\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: NEXTã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸï¼ˆãƒ«ãƒ¼ãƒ—å®Œäº†: {self.total_loops}ï¼‰\")\r\n-            \r\n-            # ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ\r\n-            if action_taken:\r\n-                device_state.error_count = 0\r\n-            \r\n-        except Exception as e:\r\n-            device_state.error_count += 1\r\n-            self.logger.error(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}\")\r\n-            \r\n-            # ã‚¨ãƒ©ãƒ¼å›æ•°ãŒä¸Šé™ã‚’è¶…ãˆãŸå ´åˆã€ãƒ‡ãƒã‚¤ã‚¹ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹\r\n-            if device_state.error_count >= self.max_error_count:\r\n-                device_state.is_active = False\r\n-                self.logger.warning(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ãŒã‚¨ãƒ©ãƒ¼ä¸Šé™ã«é”ã—ãŸãŸã‚éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ã¾ã—ãŸ\")\r\n-    \r\n-    async def automation_loop(self):\r\n-        \"\"\"ãƒ¡ã‚¤ãƒ³è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—\"\"\"\r\n-        self.logger.info(\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã—ã¾ã™\")\r\n-        self.start_time = time.time()\r\n-        \r\n-        while self.is_running:\r\n-            try:\r\n-                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£\r\n-                screen_data = await self.device_controller.capture_all_screens()\r\n-                \r\n-                if not screen_data:\r\n-                    await asyncio.sleep(self.screen_capture_interval)\r\n-                    continue\r\n-                \r\n-                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã§ç”»åƒæ¤œå‡º\r\n-                detection_results = await self.image_detector.detect_all_devices(\r\n-                    screen_data, self.detection_threshold\r\n-                )\r\n-                \r\n-                # å„ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\r\n-                tasks = []\r\n-                for device_id, detections in detection_results.items():\r\n-                    if device_id in self.device_states:\r\n-                        task = self.process_device_detection(device_id, detections)\r\n-                        tasks.append(task)                \r\n-                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®å‡¦ç†ã‚’ä¸¦è¡Œå®Ÿè¡Œ\r\n-                if tasks:\r\n-                    await asyncio.gather(*tasks, return_exceptions=True)\r\n-                \r\n-                # çŸ­ã„å¾…æ©Ÿ\r\n-                await asyncio.sleep(self.screen_capture_interval)\r\n-                \r\n-            except Exception as e:\r\n-                self.logger.error(f\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚¨ãƒ©ãƒ¼: {e}\")\r\n-                await asyncio.sleep(1)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å°‘ã—é•·ã‚ã«å¾…æ©Ÿ\r\n-    \r\n-    async def start_automation(self):\r\n-        \"\"\"è‡ªå‹•åŒ–ã‚’é–‹å§‹\"\"\"\r\n-        if self.is_running:\r\n-            self.logger.warning(\"è‡ªå‹•åŒ–ã¯æ—¢ã«å®Ÿè¡Œä¸­ã§ã™\")\r\n-            return\r\n-        \r\n-        if not self.device_states:\r\n-            self.logger.error(\"ãƒ‡ãƒã‚¤ã‚¹ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“\")\r\n-            return\r\n-        \r\n-        self.is_running = True\r\n-        self.total_loops = 0\r\n-        try:\r\n-            await self.automation_loop()\r\n-        except Exception as e:\r\n-            self.logger.error(f\"è‡ªå‹•åŒ–å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}\")\r\n-        finally:\r\n-            self.is_running = False\r\n-    \r\n-    def stop_automation(self):\r\n-        \"\"\"è‡ªå‹•åŒ–ã‚’åœæ­¢\"\"\"\r\n-        self.is_running = False\r\n-        self.logger.info(\"è‡ªå‹•åŒ–ã‚’åœæ­¢ã—ã¾ã—ãŸ\")\r\n-    \r\n-    def get_statistics(self) -> Dict:\r\n-        \"\"\"çµ±è¨ˆæƒ…å ±ã‚’å–å¾—\"\"\"\r\n-        current_time = time.time()\r\n-        elapsed_time = current_time - self.start_time if self.start_time > 0 else 0\r\n-        \r\n-        stats = {\r\n-            'total_loops': self.total_loops,\r\n-            'elapsed_time': elapsed_time,\r\n-            'loops_per_hour': (self.total_loops / elapsed_time * 3600) if elapsed_time > 0 else 0,\r\n-            'active_devices': len([d for d in self.device_states.values() if d.is_active]),\r\n-            'total_devices': len(self.device_states),\r\n-            'device_details': {}\r\n-        }\r\n-        \r\n-        for device_id, state in self.device_states.items():\r\n-            stats['device_details'][device_id] = {\r\n-                'state': state.current_state.value,\r\n-                'tap_count': state.tap_count,\r\n-                'error_count': state.error_count,\r\n-                'is_active': state.is_active,\r\n-                'last_action_time': state.last_action_time\r\n-            }\r\n-        \r\n-        return stats\r\n-    \r\n-    def reset_statistics(self):\r\n-        \"\"\"çµ±è¨ˆæƒ…å ±ã‚’ãƒªã‚»ãƒƒãƒˆ\"\"\"\r\n-        self.total_loops = 0\r\n-        self.start_time = time.time()\r\n-        for state in self.device_states.values():\r\n-            state.tap_count = 0\r\n-            state.error_count = 0\r\n-    \r\n-    def set_detection_threshold(self, threshold: float):\r\n-        \"\"\"æ¤œå‡ºé–¾å€¤ã‚’è¨­å®š\"\"\"\r\n-        self.detection_threshold = max(0.1, min(1.0, threshold))\r\n-    \r\n-    def set_tap_cooldown(self, cooldown: float):\r\n-        \"\"\"ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’è¨­å®š\"\"\"\r\n-        self.tap_cooldown = max(0.1, cooldown)\r\n-    \r\n-    def set_capture_interval(self, interval: float):\r\n-        \"\"\"ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ã‚’è¨­å®š\"\"\"\r\n-        self.screen_capture_interval = max(0.05, interval)\r\n-import asyncio\r\n-import logging\r\n-import time\r\n-from typing import Dict, Optional, Tuple, List\r\n-from enum import Enum\r\n-from dataclasses import dataclass\r\n-from device_controller import MultiDeviceController\r\n-from image_detector import MultiDeviceImageDetector\r\n+            # hp_barãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ•ãƒ©ã‚°è§£é™¤\r\n+            if not detections.get('hp_bar'):\r\n+                device_state.hp_bar_tapped = False\r\n \r\n-\r\n-class GameState(Enum):\r\n-    \"\"\"ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®åˆ—æŒ™\"\"\"\r\n-    IDLE = \"idle\"\r\n-    BOSS_DETECTED = \"boss_detected\"\r\n-    PLAY_DETECTED = \"play_detected\"\r\n-    PUZZLE_DETECTED = \"puzzle_detected\"\r\n-    WAZA_OK_DETECTED = \"waza_ok_detected\"\r\n-    NEXT_DETECTED = \"next_detected\"\r\n-    STAGE_45_DETECTED = \"stage_45_detected\"\r\n-\r\n-\r\n-@dataclass\r\n-class DeviceState:\r\n-    \"\"\"ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹\"\"\"\r\n-    device_id: str\r\n-    current_state: GameState = GameState.IDLE\r\n-    last_action_time: float = 0\r\n-    tap_count: int = 0\r\n-    error_count: int = 0\r\n-    is_active: bool = True\r\n-    hp_bar_tap_time: float = 0  # hp_barã‚¿ãƒƒãƒ—æ™‚åˆ»\r\n-\r\n-\r\n-class AutomationEngine:\r\n-    \"\"\"å¦–æ€ªã‚¦ã‚©ãƒƒãƒã·ã«ã·ã«è‡ªå‹•å‘¨å›ã‚¨ãƒ³ã‚¸ãƒ³\"\"\"\r\n-    \r\n-    def __init__(self, template_dir: str = \"image\"):\r\n-        self.device_controller = MultiDeviceController()\r\n-        self.image_detector = MultiDeviceImageDetector(template_dir)\r\n-        self.device_states = {}\r\n-        self.is_running = False\r\n-        self.logger = logging.getLogger(__name__)\r\n-        \r\n-        # è¨­å®š\r\n-        self.detection_threshold = 0.8\r\n-        self.tap_cooldown = 0.5  # ã‚¿ãƒƒãƒ—é–“éš”ï¼ˆç§’ï¼‰\r\n-        self.screen_capture_interval = 0.1  # ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ï¼ˆç§’ï¼‰\r\n-        self.max_error_count = 5  # æœ€å¤§ã‚¨ãƒ©ãƒ¼å›æ•°\r\n-        \r\n-        # çµ±è¨ˆæƒ…å ±\r\n-        self.total_loops = 0\r\n-        self.start_time = 0\r\n-        \r\n-    def add_device(self, device_id: str) -> bool:\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’è¿½åŠ \"\"\"\r\n-        if self.device_controller.add_device(device_id):\r\n-            self.device_states[device_id] = DeviceState(device_id)\r\n-            self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã‚’è¿½åŠ ã—ã¾ã—ãŸ\")\r\n-            return True\r\n-        return False\r\n-    \r\n-    def remove_device(self, device_id: str):\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’å‰Šé™¤\"\"\"\r\n-        self.device_controller.remove_device(device_id)\r\n-        if device_id in self.device_states:\r\n-            del self.device_states[device_id]\r\n-        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã‚’å‰Šé™¤ã—ã¾ã—ãŸ\")\r\n-    \r\n-    def get_device_list(self) -> List[str]:\r\n-        \"\"\"ç®¡ç†ä¸­ã®ãƒ‡ãƒã‚¤ã‚¹ä¸€è¦§ã‚’å–å¾—\"\"\"\r\n-        return list(self.device_states.keys())\r\n-    \r\n-    def get_device_state(self, device_id: str) -> Optional[DeviceState]:\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’å–å¾—\"\"\"\r\n-        return self.device_states.get(device_id)\r\n-    \r\n-    def set_device_active(self, device_id: str, active: bool):\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è¨­å®š\"\"\"\r\n-        if device_id in self.device_states:\r\n-            self.device_states[device_id].is_active = active\r\n-    \r\n-    async def process_device_detection(self, device_id: str, \r\n-                                     detections: Dict[str, Optional[Tuple[int, int]]]):\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\"\"\"\r\n-        if device_id not in self.device_states:\r\n-            return\r\n-        \r\n-        device_state = self.device_states[device_id]\r\n-        if not device_state.is_active:\r\n-            return\r\n-        \r\n-        current_time = time.time()\r\n-        \r\n-        # ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\r\n-        if current_time - device_state.last_action_time < self.tap_cooldown:\r\n-            return\r\n-        \r\n-        try:\r\n-            # å„ªå…ˆåº¦é †ã§å‡¦ç†\r\n-            action_taken = False\r\n-\r\n-            # --- hp_baræ¤œçŸ¥æ™‚ã®ç‰¹æ®Šã‚¿ãƒƒãƒ— ---\r\n-            # ãŸã ã—waza_ok_1ã¾ãŸã¯waza_ok_2ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚Œã°hp_barã¯ã‚¹ã‚­ãƒƒãƒ—\r\n-            if (\r\n-                detections.get('hp_bar') and not action_taken and\r\n-                not (detections.get('waza_ok_1') or detections.get('waza_ok_2'))\r\n-            ):\r\n-                x, y = detections['hp_bar']\r\n-                # ç›´è¿‘1ç§’ä»¥å†…ã«ã‚¿ãƒƒãƒ—ã—ã¦ã„ãªã‘ã‚Œã°1å›ã ã‘ã‚¿ãƒƒãƒ—\r\n-                if current_time - device_state.hp_bar_tap_time > 1.0:\r\n-                    tap_x, tap_y = x, y + 200\r\n-                    success = await self.device_controller.devices[device_id].tap_async(tap_x, tap_y)\r\n-                    if success:\r\n-                        device_state.hp_bar_tap_time = current_time\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: hp_barã‚’æ¤œçŸ¥ã—ä¸­å¤®y+200ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            \r\n             # --- waza_ok_1, waza_ok_2, waza_ok ---\r\n             for waza_key in ('waza_ok', 'waza_ok_1', 'waza_ok_2'):\r\n                 if detections.get(waza_key) and not action_taken:\r\n                     x, y = detections[waza_key]\r\n"
                },
                {
                    "date": 1750513814346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -336,9 +336,9 @@\n         self.detection_threshold = max(0.1, min(1.0, threshold))\r\n     \r\n     def set_tap_cooldown(self, cooldown: float):\r\n         \"\"\"ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’è¨­å®š\"\"\"\r\n-        self.tap_cooldown = max(0.1, cooldown)\r\n+        self.tap_cooldown = max(0.005, cooldown)\r\n     \r\n     def set_capture_interval(self, interval: float):\r\n         \"\"\"ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ã‚’è¨­å®š\"\"\"\r\n-        self.screen_capture_interval = max(0.05, interval)\r\n+        self.screen_capture_interval = max(0.005, interval)\r\n"
                },
                {
                    "date": 1750517161072,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,344 +1,177 @@\n-import asyncio\r\n-import logging\r\n+import cv2\r\n+import numpy as np\r\n import time\r\n-from typing import Dict, Optional, Tuple, List\r\n-from enum import Enum\r\n-from dataclasses import dataclass\r\n-from device_controller import MultiDeviceController\r\n-from image_detector import MultiDeviceImageDetector\r\n+import threading\r\n+from image_detector import ImageDetector\r\n+from device_controller import DeviceController\r\n \r\n-\r\n-class GameState(Enum):\r\n-    \"\"\"ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®åˆ—æŒ™\"\"\"\r\n-    IDLE = \"idle\"\r\n-    BOSS_DETECTED = \"boss_detected\"\r\n-    PLAY_DETECTED = \"play_detected\"\r\n-    PUZZLE_DETECTED = \"puzzle_detected\"\r\n-    WAZA_OK_DETECTED = \"waza_ok_detected\"\r\n-    NEXT_DETECTED = \"next_detected\"\r\n-    STAGE_45_DETECTED = \"stage_45_detected\"\r\n-\r\n-\r\n-@dataclass\r\n-class DeviceState:\r\n-    \"\"\"ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹\"\"\"\r\n-    device_id: str\r\n-    current_state: GameState = GameState.IDLE\r\n-    last_action_time: float = 0\r\n-    tap_count: int = 0\r\n-    error_count: int = 0\r\n-    is_active: bool = True\r\n-    hp_bar_tap_time: float = 0  # hp_barã‚¿ãƒƒãƒ—æ™‚åˆ»\r\n-\r\n-\r\n class AutomationEngine:\r\n-    \"\"\"å¦–æ€ªã‚¦ã‚©ãƒƒãƒã·ã«ã·ã«è‡ªå‹•å‘¨å›ã‚¨ãƒ³ã‚¸ãƒ³\"\"\"\r\n-    \r\n-    def __init__(self, template_dir: str = \"image\"):\r\n-        self.device_controller = MultiDeviceController()\r\n-        self.image_detector = MultiDeviceImageDetector(template_dir)\r\n-        self.device_states = {}\r\n+    def __init__(self, config_manager):\r\n+        self.config_manager = config_manager\r\n+        self.image_detector = ImageDetector()\r\n+        self.device_controller = DeviceController()\r\n+        \r\n         self.is_running = False\r\n-        self.logger = logging.getLogger(__name__)\r\n+        self.log_callback = None\r\n         \r\n-        # è¨­å®š\r\n-        self.detection_threshold = 0.8\r\n-        self.tap_cooldown = 0.5  # ã‚¿ãƒƒãƒ—é–“éš”ï¼ˆç§’ï¼‰\r\n-        self.screen_capture_interval = 0.1  # ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ï¼ˆç§’ï¼‰\r\n-        self.max_error_count = 5  # æœ€å¤§ã‚¨ãƒ©ãƒ¼å›æ•°\r\n+        # ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹\r\n+        self.image_paths = {\r\n+            'play_1': 'image/play_1.png',\r\n+            'play_2': 'image/play_2.png',\r\n+            'next': 'image/next.png',\r\n+            'close': 'image/close.png',\r\n+            'close_mini': 'image/close_mini.png'\r\n+        }\r\n         \r\n-        # çµ±è¨ˆæƒ…å ±\r\n-        self.total_loops = 0\r\n-        self.start_time = 0\r\n+        # æœ€å¾Œã®ã‚¿ãƒƒãƒ—æ™‚é–“\r\n+        self.last_tap_time = 0\r\n         \r\n-    def add_device(self, device_id: str) -> bool:\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’è¿½åŠ \"\"\"\r\n-        if self.device_controller.add_device(device_id):\r\n-            self.device_states[device_id] = DeviceState(device_id)\r\n-            self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã‚’è¿½åŠ ã—ã¾ã—ãŸ\")\r\n-            return True\r\n-        return False\r\n-    \r\n-    def remove_device(self, device_id: str):\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã‚’å‰Šé™¤\"\"\"\r\n-        self.device_controller.remove_device(device_id)\r\n-        if device_id in self.device_states:\r\n-            del self.device_states[device_id]\r\n-        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã‚’å‰Šé™¤ã—ã¾ã—ãŸ\")\r\n-    \r\n-    def get_device_list(self) -> List[str]:\r\n-        \"\"\"ç®¡ç†ä¸­ã®ãƒ‡ãƒã‚¤ã‚¹ä¸€è¦§ã‚’å–å¾—\"\"\"\r\n-        return list(self.device_states.keys())\r\n-    \r\n-    def get_device_state(self, device_id: str) -> Optional[DeviceState]:\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹çŠ¶æ…‹ã‚’å–å¾—\"\"\"\r\n-        return self.device_states.get(device_id)\r\n-    \r\n-    def set_device_active(self, device_id: str, active: bool):\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è¨­å®š\"\"\"\r\n-        if device_id in self.device_states:\r\n-            self.device_states[device_id].is_active = active\r\n-    \r\n-    async def process_device_detection(self, device_id: str, \r\n-                                     detections: Dict[str, Optional[Tuple[int, int]]]):\r\n-        \"\"\"ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\"\"\"\r\n-        if device_id not in self.device_states:\r\n-            return\r\n+    def set_log_callback(self, callback):\r\n+        \"\"\"ãƒ­ã‚°ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®è¨­å®š\"\"\"\r\n+        self.log_callback = callback\r\n         \r\n-        device_state = self.device_states[device_id]\r\n-        if not device_state.is_active:\r\n-            return\r\n+    def log(self, message):\r\n+        \"\"\"ãƒ­ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡\"\"\"\r\n+        if self.log_callback:\r\n+            self.log_callback(message)\r\n+            \r\n+    def get_available_devices(self):\r\n+        \"\"\"åˆ©ç”¨å¯èƒ½ãªãƒ‡ãƒã‚¤ã‚¹ã®å–å¾—\"\"\"\r\n+        return self.device_controller.get_devices()\r\n         \r\n-        current_time = time.time()\r\n+    def start(self):\r\n+        \"\"\"è‡ªå‹•åŒ–ã®é–‹å§‹\"\"\"\r\n+        self.is_running = True\r\n         \r\n-        # ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\r\n-        if current_time - device_state.last_action_time < self.tap_cooldown:\r\n-            return\r\n+        # ãƒ‡ãƒã‚¤ã‚¹ã®è¨­å®š\r\n+        config = self.config_manager.get_config()\r\n+        device = config.get('device')\r\n         \r\n-        try:\r\n-            # å„ªå…ˆåº¦é †ã§å‡¦ç†\r\n-            action_taken = False\r\n-\r\n-            # --- hp_barã‚¿ãƒƒãƒ—æ¸ˆã¿ãƒ•ãƒ©ã‚° ---\r\n-            if not hasattr(device_state, 'hp_bar_tapped'):\r\n-                device_state.hp_bar_tapped = False\r\n-\r\n-            # --- hp_baræ¤œçŸ¥æ™‚ã®ç‰¹æ®Šã‚¿ãƒƒãƒ— ---\r\n-            # ãŸã ã—waza_ok_1ã¾ãŸã¯waza_ok_2ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚Œã°hp_barã¯ã‚¹ã‚­ãƒƒãƒ—\r\n-            if (\r\n-                detections.get('hp_bar') and not action_taken and\r\n-                not (detections.get('waza_ok_1') or detections.get('waza_ok_2'))\r\n-            ):\r\n-                if not device_state.hp_bar_tapped:\r\n-                    x, y = detections['hp_bar']\r\n-                    tap_x, tap_y = x, y + 500\r\n-                    success = await self.device_controller.devices[device_id].tap_async(tap_x, tap_y)\r\n-                    if success:\r\n-                        device_state.hp_bar_tap_time = current_time\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        device_state.hp_bar_tapped = True\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: hp_barã‚’æ¤œçŸ¥ã—ä¸­å¤®y+200ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            # hp_barãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ•ãƒ©ã‚°è§£é™¤\r\n-            if not detections.get('hp_bar'):\r\n-                device_state.hp_bar_tapped = False\r\n-\r\n-            # --- waza_ok_1, waza_ok_2, waza_ok ---\r\n-            for waza_key in ('waza_ok', 'waza_ok_1', 'waza_ok_2'):\r\n-                if detections.get(waza_key) and not action_taken:\r\n-                    x, y = detections[waza_key]\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.WAZA_OK_DETECTED\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: {waza_key.upper()}ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+        if not device:\r\n+            raise Exception(\"ãƒ‡ãƒã‚¤ã‚¹ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“\")\r\n             \r\n-            # menu, ranking, yubinãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ä½•ã‚‚ã—ãªã„\r\n-            if any([\r\n-                detections.get('menu'),\r\n-                detections.get('ranking'),\r\n-                detections.get('yubin')\r\n-            ]):\r\n-                self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: menu/ranking/yubinãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚ä½•ã‚‚ã‚¿ãƒƒãƒ—ã—ã¾ã›ã‚“\")\r\n-                return\r\n+        # ãƒ‡ãƒã‚¤ã‚¹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®åˆæœŸåŒ–\r\n+        self.device_controller.set_device(device)\r\n+        \r\n+        # ç”»åƒæ¤œå‡ºå™¨ã®åˆæœŸåŒ–\r\n+        threshold = config.get('detection_threshold', 0.8)\r\n+        self.image_detector.set_threshold(threshold)\r\n+        \r\n+        self.log(f\"è‡ªå‹•åŒ–é–‹å§‹: ãƒ‡ãƒã‚¤ã‚¹ {device}\")\r\n+        \r\n+    def stop(self):\r\n+        \"\"\"è‡ªå‹•åŒ–ã®åœæ­¢\"\"\"\r\n+        self.is_running = False\r\n+        self.log(\"è‡ªå‹•åŒ–åœæ­¢\")\r\n+        \r\n+    def process_frame(self):\r\n+        \"\"\"ãƒ•ãƒ¬ãƒ¼ãƒ ã®å‡¦ç†\"\"\"\r\n+        if not self.is_running:\r\n+            return False\r\n             \r\n-            # 1. bossãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('boss') and not action_taken:\r\n-                x, y = detections['boss']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.BOSS_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: BOSSã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+        try:\r\n+            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã®å–å¾—\r\n+            screenshot = self.device_controller.get_screenshot()\r\n+            if screenshot is None:\r\n+                return False\r\n+                \r\n+            # ã¾ãšãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³ã®æ¤œå‡ºã‚’ç¢ºèª\r\n+            play_detected = False\r\n+            play_positions = []\r\n             \r\n-            # --- play, play_1, play_2ãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ— ---\r\n-            for play_key in ('play', 'play_1', 'play_2'):\r\n-                if detections.get(play_key) and not action_taken:\r\n-                    x, y = detections[play_key]\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.PLAY_DETECTED\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: {play_key.upper()}ã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            # ãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³ã®æ¤œå‡º\r\n+            for play_image in ['play_1', 'play_2']:\r\n+                if play_image in self.image_paths:\r\n+                    positions = self.image_detector.detect_image(screenshot, self.image_paths[play_image])\r\n+                    if positions:\r\n+                        play_detected = True\r\n+                        play_positions.extend([(play_image, pos) for pos in positions])\r\n             \r\n-            # 3. close/close_miniãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—ï¼ˆãŸã ã—stage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰\r\n-            if not action_taken and not detections.get('stage_45'):\r\n-                if detections.get('close'):\r\n-                    x, y = detections['close']\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.IDLE\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-                elif detections.get('close_mini'):\r\n-                    x, y = detections['close_mini']\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.IDLE\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: CLOSE_MINIã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n-            elif detections.get('stage_45'):\r\n-                self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: stage_45ãŒæ¤œå‡ºã•ã‚ŒãŸãŸã‚ã€close/close_miniã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™\")\r\n+            # å„ç”»åƒã®æ¤œå‡ºã¨ã‚¿ãƒƒãƒ—ï¼ˆå„ªå…ˆé †ä½ä»˜ãï¼‰\r\n+            detected_any = False\r\n             \r\n-            # 4. puzzleãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('puzzle') and not action_taken:\r\n-                x, y = detections['puzzle']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.PUZZLE_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: PUZZLEã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+            # ãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³ãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã¯ã€ãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³ã®ã¿ã‚¿ãƒƒãƒ—\r\n+            if play_detected:\r\n+                current_time = time.time()\r\n+                tap_interval = self.config_manager.get_config().get('tap_interval', 0.5)\r\n+                \r\n+                if current_time - self.last_tap_time >= tap_interval:\r\n+                    # æœ€åˆã«è¦‹ã¤ã‹ã£ãŸãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³ã‚’ã‚¿ãƒƒãƒ—\r\n+                    image_name, (x, y) = play_positions[0]\r\n+                    self.device_controller.tap(x, y)\r\n+                    self.last_tap_time = current_time\r\n+                    \r\n+                    self.log(f\"{image_name} ã‚’æ¤œå‡ºã—ã¦ã‚¿ãƒƒãƒ—: ({x}, {y})\")\r\n+                    detected_any = True\r\n+                    \r\n+            else:\r\n+                # ãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³ãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ã€ä»–ã®ãƒœã‚¿ãƒ³ã‚’å‡¦ç†\r\n+                for image_name, image_path in self.image_paths.items():\r\n+                    # ãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³ã¯ã™ã§ã«å‡¦ç†æ¸ˆã¿ãªã®ã§ã‚¹ã‚­ãƒƒãƒ—\r\n+                    if image_name in ['play_1', 'play_2']:\r\n+                        continue\r\n+                        \r\n+                    positions = self.image_detector.detect_image(screenshot, image_path)\r\n+                    \r\n+                    if positions:\r\n+                        detected_any = True\r\n+                        \r\n+                        # ã‚¿ãƒƒãƒ—é–“éš”ã®ç¢ºèª\r\n+                        current_time = time.time()\r\n+                        tap_interval = self.config_manager.get_config().get('tap_interval', 0.5)\r\n+                        \r\n+                        if current_time - self.last_tap_time >= tap_interval:\r\n+                            # æœ€åˆã«è¦‹ã¤ã‹ã£ãŸä½ç½®ã‚’ã‚¿ãƒƒãƒ—\r\n+                            x, y = positions[0]\r\n+                            self.device_controller.tap(x, y)\r\n+                            self.last_tap_time = current_time\r\n+                            \r\n+                            self.log(f\"{image_name} ã‚’æ¤œå‡ºã—ã¦ã‚¿ãƒƒãƒ—: ({x}, {y})\")\r\n+                            \r\n+                            # ä¸€åº¦ã«ã²ã¨ã¤ã®ç”»åƒã®ã¿å‡¦ç†\r\n+                            break\r\n+                        \r\n+            return detected_any\r\n             \r\n-            # 5. waza_okãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('waza_ok') and not action_taken:\r\n-                x, y = detections['waza_ok']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.WAZA_OK_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: WAZA_OKã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸ\")\r\n+        except Exception as e:\r\n+            self.log(f\"å‡¦ç†ã‚¨ãƒ©ãƒ¼: {str(e)}\")\r\n+            return False\r\n             \r\n-            # 6. nextãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ã‚¿ãƒƒãƒ—\r\n-            if detections.get('next') and not action_taken:\r\n-                x, y = detections['next']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.NEXT_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.total_loops += 1  # ãƒ«ãƒ¼ãƒ—å®Œäº†ã®ã‚«ã‚¦ãƒ³ãƒˆ\r\n-                    self.logger.info(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id}: NEXTã‚’ã‚¿ãƒƒãƒ—ã—ã¾ã—ãŸï¼ˆãƒ«ãƒ¼ãƒ—å®Œäº†: {self.total_loops}ï¼‰\")\r\n+    def test_image_detection(self):\r\n+        \"\"\"ç”»åƒæ¤œå‡ºã®ãƒ†ã‚¹ãƒˆ\"\"\"\r\n+        config = self.config_manager.get_config()\r\n+        device = config.get('device')\r\n+        \r\n+        if not device:\r\n+            raise Exception(\"ãƒ‡ãƒã‚¤ã‚¹ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“\")\r\n             \r\n-            # ã‚¨ãƒ©ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆ\r\n-            if action_taken:\r\n-                device_state.error_count = 0\r\n+        # ãƒ‡ãƒã‚¤ã‚¹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®åˆæœŸåŒ–\r\n+        self.device_controller.set_device(device)\r\n+        \r\n+        # ç”»åƒæ¤œå‡ºå™¨ã®åˆæœŸåŒ–\r\n+        threshold = config.get('detection_threshold', 0.8)\r\n+        self.image_detector.set_threshold(threshold)\r\n+        \r\n+        # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã®å–å¾—\r\n+        screenshot = self.device_controller.get_screenshot()\r\n+        if screenshot is None:\r\n+            raise Exception(\"ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ\")\r\n             \r\n-        except Exception as e:\r\n-            device_state.error_count += 1\r\n-            self.logger.error(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ã®å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}\")\r\n-            \r\n-            # ã‚¨ãƒ©ãƒ¼å›æ•°ãŒä¸Šé™ã‚’è¶…ãˆãŸå ´åˆã€ãƒ‡ãƒã‚¤ã‚¹ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹\r\n-            if device_state.error_count >= self.max_error_count:\r\n-                device_state.is_active = False\r\n-                self.logger.warning(f\"ãƒ‡ãƒã‚¤ã‚¹ {device_id} ãŒã‚¨ãƒ©ãƒ¼ä¸Šé™ã«é”ã—ãŸãŸã‚éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ã¾ã—ãŸ\")\r\n-    \r\n-    async def automation_loop(self):\r\n-        \"\"\"ãƒ¡ã‚¤ãƒ³è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—\"\"\"\r\n-        self.logger.info(\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚’é–‹å§‹ã—ã¾ã™\")\r\n-        self.start_time = time.time()\r\n+        # å„ç”»åƒã®æ¤œå‡ºãƒ†ã‚¹ãƒˆ\r\n+        results = {}\r\n         \r\n-        while self.is_running:\r\n+        for image_name, image_path in self.image_paths.items():\r\n             try:\r\n-                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£\r\n-                screen_data = await self.device_controller.capture_all_screens()\r\n+                positions = self.image_detector.detect_image(screenshot, image_path)\r\n+                results[image_name] = len(positions) > 0\r\n                 \r\n-                if not screen_data:\r\n-                    await asyncio.sleep(self.screen_capture_interval)\r\n-                    continue\r\n+                if positions:\r\n+                    self.log(f\"{image_name}: æ¤œå‡º ({len(positions)}ç®‡æ‰€)\")\r\n+                else:\r\n+                    self.log(f\"{image_name}: æœªæ¤œå‡º\")\r\n+                    \r\n+            except Exception as e:\r\n+                self.log(f\"{image_name}: ã‚¨ãƒ©ãƒ¼ - {str(e)}\")\r\n+                results[image_name] = False\r\n                 \r\n-                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã§ç”»åƒæ¤œå‡º\r\n-                detection_results = await self.image_detector.detect_all_devices(\r\n-                    screen_data, self.detection_threshold\r\n-                )\r\n-                \r\n-                # å„ãƒ‡ãƒã‚¤ã‚¹ã®æ¤œå‡ºçµæœã‚’å‡¦ç†\r\n-                tasks = []\r\n-                for device_id, detections in detection_results.items():\r\n-                    if device_id in self.device_states:\r\n-                        task = self.process_device_detection(device_id, detections)\r\n-                        tasks.append(task)                \r\n-                # å…¨ãƒ‡ãƒã‚¤ã‚¹ã®å‡¦ç†ã‚’ä¸¦è¡Œå®Ÿè¡Œ\r\n-                if tasks:\r\n-                    await asyncio.gather(*tasks, return_exceptions=True)\r\n-                \r\n-                # çŸ­ã„å¾…æ©Ÿ\r\n-                await asyncio.sleep(self.screen_capture_interval)\r\n-                \r\n-            except Exception as e:\r\n-                self.logger.error(f\"è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—ã‚¨ãƒ©ãƒ¼: {e}\")\r\n-                await asyncio.sleep(1)  # ã‚¨ãƒ©ãƒ¼æ™‚ã¯å°‘ã—é•·ã‚ã«å¾…æ©Ÿ\r\n-    \r\n-    async def start_automation(self):\r\n-        \"\"\"è‡ªå‹•åŒ–ã‚’é–‹å§‹\"\"\"\r\n-        if self.is_running:\r\n-            self.logger.warning(\"è‡ªå‹•åŒ–ã¯æ—¢ã«å®Ÿè¡Œä¸­ã§ã™\")\r\n-            return\r\n-        \r\n-        if not self.device_states:\r\n-            self.logger.error(\"ãƒ‡ãƒã‚¤ã‚¹ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“\")\r\n-            return\r\n-        \r\n-        self.is_running = True\r\n-        self.total_loops = 0\r\n-        try:\r\n-            await self.automation_loop()\r\n-        except Exception as e:\r\n-            self.logger.error(f\"è‡ªå‹•åŒ–å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}\")\r\n-        finally:\r\n-            self.is_running = False\r\n-    \r\n-    def stop_automation(self):\r\n-        \"\"\"è‡ªå‹•åŒ–ã‚’åœæ­¢\"\"\"\r\n-        self.is_running = False\r\n-        self.logger.info(\"è‡ªå‹•åŒ–ã‚’åœæ­¢ã—ã¾ã—ãŸ\")\r\n-    \r\n-    def get_statistics(self) -> Dict:\r\n-        \"\"\"çµ±è¨ˆæƒ…å ±ã‚’å–å¾—\"\"\"\r\n-        current_time = time.time()\r\n-        elapsed_time = current_time - self.start_time if self.start_time > 0 else 0\r\n-        \r\n-        stats = {\r\n-            'total_loops': self.total_loops,\r\n-            'elapsed_time': elapsed_time,\r\n-            'loops_per_hour': (self.total_loops / elapsed_time * 3600) if elapsed_time > 0 else 0,\r\n-            'active_devices': len([d for d in self.device_states.values() if d.is_active]),\r\n-            'total_devices': len(self.device_states),\r\n-            'device_details': {}\r\n-        }\r\n-        \r\n-        for device_id, state in self.device_states.items():\r\n-            stats['device_details'][device_id] = {\r\n-                'state': state.current_state.value,\r\n-                'tap_count': state.tap_count,\r\n-                'error_count': state.error_count,\r\n-                'is_active': state.is_active,\r\n-                'last_action_time': state.last_action_time\r\n-            }\r\n-        \r\n-        return stats\r\n-    \r\n-    def reset_statistics(self):\r\n-        \"\"\"çµ±è¨ˆæƒ…å ±ã‚’ãƒªã‚»ãƒƒãƒˆ\"\"\"\r\n-        self.total_loops = 0\r\n-        self.start_time = time.time()\r\n-        for state in self.device_states.values():\r\n-            state.tap_count = 0\r\n-            state.error_count = 0\r\n-    \r\n-    def set_detection_threshold(self, threshold: float):\r\n-        \"\"\"æ¤œå‡ºé–¾å€¤ã‚’è¨­å®š\"\"\"\r\n-        self.detection_threshold = max(0.1, min(1.0, threshold))\r\n-    \r\n-    def set_tap_cooldown(self, cooldown: float):\r\n-        \"\"\"ã‚¿ãƒƒãƒ—ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’è¨­å®š\"\"\"\r\n-        self.tap_cooldown = max(0.005, cooldown)\r\n-    \r\n-    def set_capture_interval(self, interval: float):\r\n-        \"\"\"ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£é–“éš”ã‚’è¨­å®š\"\"\"\r\n-        self.screen_capture_interval = max(0.005, interval)\r\n+        return results\r\n"
                },
                {
                    "date": 1750517501504,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,16 +12,16 @@\n         self.device_controller = DeviceController()\r\n         \r\n         self.is_running = False\r\n         self.log_callback = None\r\n-        \r\n-        # ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹\r\n+          # ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹\r\n         self.image_paths = {\r\n             'play_1': 'image/play_1.png',\r\n             'play_2': 'image/play_2.png',\r\n             'next': 'image/next.png',\r\n             'close': 'image/close.png',\r\n-            'close_mini': 'image/close_mini.png'\r\n+            'close_mini': 'image/close_mini.png',\r\n+            'ok': 'image/ok.png'\r\n         }\r\n         \r\n         # æœ€å¾Œã®ã‚¿ãƒƒãƒ—æ™‚é–“\r\n         self.last_tap_time = 0\r\n"
                },
                {
                    "date": 1750518120659,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,10 @@\n         self.device_controller = DeviceController()\r\n         \r\n         self.is_running = False\r\n         self.log_callback = None\r\n-          # ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹\r\n+        \r\n+        # ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹\r\n         self.image_paths = {\r\n             'play_1': 'image/play_1.png',\r\n             'play_2': 'image/play_2.png',\r\n             'next': 'image/next.png',\r\n@@ -22,8 +23,16 @@\n             'close_mini': 'image/close_mini.png',\r\n             'ok': 'image/ok.png'\r\n         }\r\n         \r\n+        # ã‚¿ãƒƒãƒ—ã—ãªã„ç”»åƒï¼ˆæ¤œå‡ºã®ã¿è¡Œã†ï¼‰\r\n+        self.ignore_images = {\r\n+            'goukan': 'image/goukan.png',\r\n+            'menu': 'image/menu.png',\r\n+            'ranking': 'image/ranking.png',\r\n+            'yuubin': 'image/yuubin.png'\r\n+        }\r\n+        \r\n         # æœ€å¾Œã®ã‚¿ãƒƒãƒ—æ™‚é–“\r\n         self.last_tap_time = 0\r\n         \r\n     def set_log_callback(self, callback):\r\n@@ -73,8 +82,31 @@\n             # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã®å–å¾—\r\n             screenshot = self.device_controller.get_screenshot()\r\n             if screenshot is None:\r\n                 return False\r\n+                  # ã‚¿ãƒƒãƒ—ã—ãªã„ç”»åƒãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯\r\n+            ignore_detected = False\r\n+            config = self.config_manager.get_config()\r\n+            \r\n+            for ignore_name, ignore_path in self.ignore_images.items():\r\n+                # è¨­å®šã§ãã®ç”»åƒã®èª¤ã‚¿ãƒƒãƒ—é˜²æ­¢ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯\r\n+                prevent_key = f'prevent_{ignore_name}'\r\n+                if not config.get(prevent_key, True):\r\n+                    continue  # ã“ã®ç”»åƒã®èª¤ã‚¿ãƒƒãƒ—é˜²æ­¢ãŒç„¡åŠ¹ãªã®ã§ã‚¹ã‚­ãƒƒãƒ—\r\n+                    \r\n+                try:\r\n+                    positions = self.image_detector.detect_image(screenshot, ignore_path)\r\n+                    if positions:\r\n+                        ignore_detected = True\r\n+                        self.log(f\"{ignore_name} ã‚’æ¤œå‡ºï¼ˆã‚¿ãƒƒãƒ—ã—ã¾ã›ã‚“ï¼‰\")\r\n+                        break\r\n+                except:\r\n+                    # ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç„¡è¦–\r\n+                    pass\r\n+            \r\n+            # ã‚¿ãƒƒãƒ—ã—ãªã„ç”»åƒãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã¯ä½•ã‚‚ã—ãªã„\r\n+            if ignore_detected:\r\n+                return True\r\n                 \r\n             # ã¾ãšãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³ã®æ¤œå‡ºã‚’ç¢ºèª\r\n             play_detected = False\r\n             play_positions = []\r\n@@ -159,8 +191,9 @@\n             \r\n         # å„ç”»åƒã®æ¤œå‡ºãƒ†ã‚¹ãƒˆ\r\n         results = {}\r\n         \r\n+        # ã‚¿ãƒƒãƒ—ã™ã‚‹ç”»åƒã®æ¤œå‡ºãƒ†ã‚¹ãƒˆ\r\n         for image_name, image_path in self.image_paths.items():\r\n             try:\r\n                 positions = self.image_detector.detect_image(screenshot, image_path)\r\n                 results[image_name] = len(positions) > 0\r\n@@ -172,6 +205,28 @@\n                     \r\n             except Exception as e:\r\n                 self.log(f\"{image_name}: ã‚¨ãƒ©ãƒ¼ - {str(e)}\")\r\n                 results[image_name] = False\r\n+          # ã‚¿ãƒƒãƒ—ã—ãªã„ç”»åƒã®æ¤œå‡ºãƒ†ã‚¹ãƒˆ\r\n+        config = self.config_manager.get_config()\r\n+        for ignore_name, ignore_path in self.ignore_images.items():\r\n+            # è¨­å®šã§ãã®ç”»åƒã®èª¤ã‚¿ãƒƒãƒ—é˜²æ­¢ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯\r\n+            prevent_key = f'prevent_{ignore_name}'\r\n+            if not config.get(prevent_key, True):\r\n+                results[f\"{ignore_name}(ç„¡åŠ¹)\"] = False\r\n+                self.log(f\"{ignore_name}(ç„¡åŠ¹): èª¤ã‚¿ãƒƒãƒ—é˜²æ­¢ãŒç„¡åŠ¹ã§ã™\")\r\n+                continue\r\n                 \r\n+            try:\r\n+                positions = self.image_detector.detect_image(screenshot, ignore_path)\r\n+                results[f\"{ignore_name}(ç„¡è¦–)\"] = len(positions) > 0\r\n+                \r\n+                if positions:\r\n+                    self.log(f\"{ignore_name}(ç„¡è¦–): æ¤œå‡º ({len(positions)}ç®‡æ‰€)\")\r\n+                else:\r\n+                    self.log(f\"{ignore_name}(ç„¡è¦–): æœªæ¤œå‡º\")\r\n+                    \r\n+            except Exception as e:\r\n+                self.log(f\"{ignore_name}(ç„¡è¦–): ã‚¨ãƒ©ãƒ¼ - {str(e)}\")\r\n+                results[f\"{ignore_name}(ç„¡è¦–)\"] = False\r\n+                \r\n         return results\r\n"
                },
                {
                    "date": 1750518382849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n import cv2\r\n import numpy as np\r\n import time\r\n import threading\r\n+import os\r\n from image_detector import ImageDetector\r\n from device_controller import DeviceController\r\n \r\n class AutomationEngine:\r\n@@ -13,29 +14,51 @@\n         \r\n         self.is_running = False\r\n         self.log_callback = None\r\n         \r\n-        # ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹\r\n-        self.image_paths = {\r\n-            'play_1': 'image/play_1.png',\r\n-            'play_2': 'image/play_2.png',\r\n-            'next': 'image/next.png',\r\n-            'close': 'image/close.png',\r\n-            'close_mini': 'image/close_mini.png',\r\n-            'ok': 'image/ok.png'\r\n-        }\r\n-        \r\n-        # ã‚¿ãƒƒãƒ—ã—ãªã„ç”»åƒï¼ˆæ¤œå‡ºã®ã¿è¡Œã†ï¼‰\r\n-        self.ignore_images = {\r\n-            'goukan': 'image/goukan.png',\r\n-            'menu': 'image/menu.png',\r\n-            'ranking': 'image/ranking.png',\r\n-            'yuubin': 'image/yuubin.png'\r\n-        }\r\n-        \r\n         # æœ€å¾Œã®ã‚¿ãƒƒãƒ—æ™‚é–“\r\n         self.last_tap_time = 0\r\n         \r\n+        # ç”»åƒãƒ‘ã‚¹ã‚’åˆæœŸåŒ–\r\n+        self.reload_images()\r\n+        \r\n+    def reload_images(self):\r\n+        \"\"\"imageãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰ç”»åƒã‚’å†èª­ã¿è¾¼ã¿ã—ã€åˆ†é¡ã™ã‚‹\"\"\"\r\n+        image_dir = \"image\"\r\n+        if not os.path.exists(image_dir):\r\n+            os.makedirs(image_dir)\r\n+            \r\n+        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ãƒƒãƒ—ã™ã‚‹ç”»åƒ\r\n+        default_tap_images = ['play_1.png', 'play_2.png', 'next.png', 'close.png', 'close_mini.png', 'ok.png']\r\n+        \r\n+        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ãƒƒãƒ—ã—ãªã„ç”»åƒ\r\n+        default_ignore_images = ['koukan.png', 'menu.png', 'ranking.png', 'yubin.png']\r\n+        \r\n+        # ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’å†æ§‹ç¯‰\r\n+        self.image_paths = {}\r\n+        self.ignore_images = {}\r\n+        \r\n+        # imageãƒ•ã‚©ãƒ«ãƒ€å†…ã®ã™ã¹ã¦ã®ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèª\r\n+        for filename in os.listdir(image_dir):\r\n+            if filename.lower().endswith(('.png', '.jpg', '.jpeg')):\r\n+                file_path = os.path.join(image_dir, filename)\r\n+                \r\n+                # ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰æ‹¡å¼µå­ã‚’é™¤å»\r\n+                name_without_ext = os.path.splitext(filename)[0]\r\n+                \r\n+                if filename in default_ignore_images:\r\n+                    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ãƒƒãƒ—ã—ãªã„ç”»åƒ\r\n+                    self.ignore_images[name_without_ext] = file_path\r\n+                elif filename in default_tap_images:\r\n+                    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ãƒƒãƒ—ã™ã‚‹ç”»åƒ\r\n+                    self.image_paths[name_without_ext] = file_path\r\n+                else:\r\n+                    # æ–°è¦è¿½åŠ ã•ã‚ŒãŸç”»åƒã¯åˆæœŸçŠ¶æ…‹ã§ã‚¿ãƒƒãƒ—ã™ã‚‹ç”»åƒã¨ã—ã¦æ‰±ã†\r\n+                    # ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ˜ç¤ºçš„ã«ã‚¿ãƒƒãƒ—ã—ãªã„ç”»åƒã¨ã—ã¦è¿½åŠ ã—ãŸå ´åˆã®å‡¦ç†ã¯å°†æ¥æ‹¡å¼µ\r\n+                    self.image_paths[name_without_ext] = file_path\r\n+                    \r\n+        self.log(f\"ç”»åƒã‚’å†èª­ã¿è¾¼ã¿ã—ã¾ã—ãŸ - ã‚¿ãƒƒãƒ—: {len(self.image_paths)}å€‹, ç„¡è¦–: {len(self.ignore_images)}å€‹\")\r\n+        \r\n     def set_log_callback(self, callback):\r\n         \"\"\"ãƒ­ã‚°ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®è¨­å®š\"\"\"\r\n         self.log_callback = callback\r\n         \r\n"
                }
            ],
            "date": 1750493481590,
            "name": "Commit-0",
            "content": "\"\"\"\r\nè‡ªå‹•åŒ–ã‚¨ãƒ³ã‚¸ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«\r\nè‡ªå‹•å‘¨å›ã®ãƒ¡ã‚¤ãƒ³ãƒ­ã‚¸ãƒƒã‚¯ã€ãƒãƒˆãƒ«ãƒ«ãƒ¼ãƒ—ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–æ©Ÿèƒ½\r\n\"\"\"\r\n\r\nimport time\r\nimport threading\r\nimport random\r\nfrom image_detector import ImageDetector\r\nfrom device_controller import DeviceController\r\n\r\n\r\nclass AutomationEngine:\r\n    def __init__(self, image_paths, settings, log_callback):\r\n        self.image_paths = image_paths\r\n        self.settings = settings\r\n        self.log = log_callback\r\n        \r\n        self.image_detector = ImageDetector(settings['similarity_threshold'])\r\n        self.device_controller = DeviceController()\r\n        \r\n        self.running = False\r\n        self.threads = {}\r\n        self.device_status = {}\r\n        \r\n        # ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ç”¨\r\n        self.realtime_monitoring = False\r\n        self.realtime_monitor_thread = None\r\n        \r\n    def update_settings(self, settings):\r\n        \"\"\"è¨­å®šã‚’æ›´æ–°\"\"\"\r\n        self.settings = settings\r\n        self.image_detector.similarity_threshold = settings['similarity_threshold']\r\n    \r\n    def human_like_delay(self):\r\n        \"\"\"äººé–“ã‚‰ã—ã„ãƒ©ãƒ³ãƒ€ãƒ ãªé…å»¶\"\"\"\r\n        delay = random.uniform(\r\n            self.settings['human_like_delay_min'], \r\n            self.settings['human_like_delay_max']\r\n        )\r\n        time.sleep(delay)\r\n    \r\n    def start_automation(self, selected_devices):\r\n        \"\"\"è‡ªå‹•åŒ–é–‹å§‹\"\"\"\r\n        self.running = True\r\n        \r\n        # ãƒ‡ãƒã‚¤ã‚¹äº’æ›æ€§ãƒã‚§ãƒƒã‚¯\r\n        for device_id in selected_devices:\r\n            self.log_device_compatibility(device_id)\r\n        \r\n        # å„ãƒ‡ãƒã‚¤ã‚¹ã§ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é–‹å§‹\r\n        for device_id in selected_devices:\r\n            thread = threading.Thread(target=self.automation_loop, args=(device_id,))\r\n            thread.daemon = True\r\n            self.threads[device_id] = thread\r\n            thread.start()\r\n            self.log(\"è‡ªå‹•åŒ–é–‹å§‹\", device_id)\r\n    \r\n    def stop_automation(self):\r\n        \"\"\"è‡ªå‹•åŒ–åœæ­¢\"\"\"\r\n        self.running = False\r\n        self.threads.clear()\r\n        self.log(\"å…¨ãƒ‡ãƒã‚¤ã‚¹ã®è‡ªå‹•åŒ–ã‚’åœæ­¢\")\r\n    \r\n    def automation_loop(self, device_id):\r\n        \"\"\"æœ€é©åŒ–ã•ã‚ŒãŸãƒ¡ã‚¤ãƒ³ã®è‡ªå‹•åŒ–ãƒ«ãƒ¼ãƒ—\"\"\"\r\n        self.device_status[device_id] = \"å®Ÿè¡Œä¸­\"\r\n        puzzle_tap_count = 0\r\n        stage_45_detected = False\r\n        \r\n        while self.running and device_id in self.threads:\r\n            try:\r\n                # å„ªå…ˆåº¦ã®é«˜ã„ç”»åƒã‚’åŒæ™‚æ¤œç´¢\r\n                priority_images = {}\r\n                \r\n                # stage_45.pngã‚’æœ€åˆã«ãƒã‚§ãƒƒã‚¯\r\n                screenshot = self.device_controller.fast_screenshot_to_memory(\r\n                    device_id, self.settings.get('use_memory_capture', True)\r\n                )\r\n                if screenshot is None:\r\n                    time.sleep(0.5)\r\n                    continue\r\n                \r\n                stage_45_pos = self.image_detector.find_image_on_screen_optimized(\r\n                    self.image_paths['stage_45'], screenshot\r\n                )\r\n                \r\n                if stage_45_pos and not stage_45_detected:\r\n                    stage_45_detected = True\r\n                    self.log(\"ã‚¹ãƒ†ãƒ¼ã‚¸45æ¤œå‡º - closeç³»ãƒœã‚¿ãƒ³ã®ç›£è¦–ã‚’åœæ­¢\", device_id)\r\n                elif not stage_45_pos and stage_45_detected:\r\n                    stage_45_detected = False\r\n                    self.log(\"ã‚¹ãƒ†ãƒ¼ã‚¸45çµ‚äº† - closeç³»ãƒœã‚¿ãƒ³ã®ç›£è¦–ã‚’å†é–‹\", device_id)\r\n                \r\n                # closeç³»ã®ç›£è¦–ï¼ˆstage_45æ¤œå‡ºæ™‚ã¯é™¤ãï¼‰\r\n                if not stage_45_detected:\r\n                    priority_images['close'] = self.image_paths['close']\r\n                    priority_images['close_mini'] = self.image_paths['close_mini']\r\n                \r\n                # ç¾åœ¨ã®çŠ¶æ…‹ã«å¿œã˜ãŸç”»åƒã‚’è¿½åŠ \r\n                priority_images['boss'] = self.image_paths['boss']\r\n                priority_images['play'] = self.image_paths['play']\r\n                priority_images['next'] = self.image_paths['next']\r\n                \r\n                # è¤‡æ•°ç”»åƒã‚’åŒæ™‚æ¤œç´¢ï¼ˆæœ€é©åŒ–ç‰ˆï¼‰\r\n                detected_images = self.image_detector.find_multiple_images_on_screen_optimized(\r\n                    priority_images, screenshot\r\n                )\r\n                \r\n                # playãƒœã‚¿ãƒ³ã‚’ç›´æ¥æ¤œå‡ºã—ãŸå ´åˆã®å‡¦ç†ã‚’è¿½åŠ \r\n                if 'play' in detected_images:\r\n                    self.log(\"playãƒœã‚¿ãƒ³ã‚’ç›´æ¥æ¤œå‡ºã—ã¾ã—ãŸ\", device_id)\r\n                    pos = detected_images['play']['pos']\r\n                    \r\n                    # play.pngã‚’ã‚¿ãƒƒãƒ—å‰ã«å†åº¦stage_45.pngã‚’ãƒã‚§ãƒƒã‚¯\r\n                    stage_45_pos = self.image_detector.find_image_on_screen_optimized(\r\n                        self.image_paths['stage_45'], screenshot\r\n                    )\r\n                    if stage_45_pos:\r\n                        stage_45_detected = True\r\n                        self.log(\"ãƒ—ãƒ¬ã‚¤å‰ã‚¹ãƒ†ãƒ¼ã‚¸45æ¤œå‡º - closeç³»ãƒœã‚¿ãƒ³ã®ç›£è¦–ã‚’åœæ­¢\", device_id)\r\n                    \r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"play\", self.settings['tap_delay']\r\n                    )\r\n                    \r\n                    # ãƒãƒˆãƒ«ãƒ«ãƒ¼ãƒ—ï¼ˆâ‘¢â‘£ã®å‡¦ç†ï¼‰\r\n                    self.battle_loop(device_id, puzzle_tap_count)\r\n                    puzzle_tap_count = 0\r\n                    continue\r\n                \r\n                # å„ªå…ˆé †ä½ã«å¾“ã£ã¦å‡¦ç†\r\n                if 'close' in detected_images and not stage_45_detected:\r\n                    pos = detected_images['close']['pos']\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n                    )\r\n                    continue\r\n                    \r\n                if 'close_mini' in detected_images and not stage_45_detected:\r\n                    pos = detected_images['close_mini']['pos']\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n                    )\r\n                    continue\r\n                \r\n                # next.pngãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆï¼ˆæœ€å„ªå…ˆï¼‰\r\n                if 'next' in detected_images:\r\n                    pos = detected_images['next']['pos']\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"next\", self.settings['tap_delay']\r\n                    )\r\n                    stage_45_detected = False  # ãƒªã‚»ãƒƒãƒˆ\r\n                    puzzle_tap_count = 0\r\n                    continue\r\n                \r\n                # boss.pngãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆ\r\n                if 'boss' in detected_images:\r\n                    pos = detected_images['boss']['pos']\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"boss\", self.settings['tap_delay']\r\n                    )\r\n                    \r\n                    # play.pngã‚’å¾…æ©Ÿã—ã¦æ¤œç´¢ï¼ˆæœ€é©åŒ–ç‰ˆãƒ»å¼·åŒ–ï¼‰\r\n                    self.log(\"bossæ¤œå‡ºå¾Œã€playãƒœã‚¿ãƒ³ã‚’æ¤œç´¢ä¸­...\", device_id)\r\n                    play_found = False\r\n                    max_attempts = 10  # æœ€å¤§è©¦è¡Œå›æ•°\r\n                    \r\n                    for attempt in range(max_attempts):\r\n                        time.sleep(0.5)  # ç”»é¢é·ç§»ã‚’å¾…ã¤\r\n                        # æ–°ã—ã„ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’å–å¾—\r\n                        new_screenshot = self.device_controller.fast_screenshot_to_memory(\r\n                            device_id, self.settings.get('use_memory_capture', True)\r\n                        )\r\n                        if new_screenshot is None:\r\n                            continue\r\n                            \r\n                        # æ®µéšçš„é–¾å€¤æ¤œç´¢ã‚’ä½¿ç”¨\r\n                        play_pos = self.image_detector.find_image_with_multiple_thresholds(\r\n                            self.image_paths['play'], new_screenshot\r\n                        )\r\n                        \r\n                        if play_pos:\r\n                            self.log(f\"playãƒœã‚¿ãƒ³æ¤œå‡ºæˆåŠŸ (è©¦è¡Œ{attempt + 1}å›ç›®): {play_pos}\", device_id)\r\n                            play_found = True\r\n                            \r\n                            self.device_controller.smart_tap_screen(\r\n                                play_pos[0], play_pos[1], device_id, \"play\", self.settings['tap_delay']\r\n                            )\r\n                            \r\n                            # ãƒãƒˆãƒ«ãƒ«ãƒ¼ãƒ—ï¼ˆâ‘¢â‘£ã®å‡¦ç†ï¼‰\r\n                            self.battle_loop(device_id, puzzle_tap_count)\r\n                            puzzle_tap_count = 0\r\n                            break\r\n                        else:\r\n                            self.log(f\"playãƒœã‚¿ãƒ³æœªæ¤œå‡º (è©¦è¡Œ{attempt + 1}å›ç›®)\", device_id)\r\n                    \r\n                    if not play_found:\r\n                        self.log(f\"playãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸï¼ˆ{max_attempts}å›è©¦è¡Œï¼‰\", device_id)\r\n                \r\n                # çŸ­ã„é–“éš”ã§æ¬¡ã®ãƒã‚§ãƒƒã‚¯\r\n                time.sleep(self.settings['check_interval'])\r\n                \r\n            except Exception as e:\r\n                self.log(f\"è‡ªå‹•åŒ–ã‚¨ãƒ©ãƒ¼: {str(e)}\", device_id)\r\n                time.sleep(0.5)\r\n        \r\n        self.device_status[device_id] = \"åœæ­¢\"\r\n        self.log(\"è‡ªå‹•åŒ–åœæ­¢\", device_id)\r\n    \r\n    def battle_loop(self, device_id, initial_puzzle_count=0):\r\n        \"\"\"ãƒãƒˆãƒ«ä¸­ã®ãƒ«ãƒ¼ãƒ—å‡¦ç†ï¼ˆâ‘¢â‘£ã®æœ€é©åŒ–ãƒ»puzzleæ¤œçŸ¥å¼·åŒ–ï¼‰\"\"\"\r\n        puzzle_tap_count = initial_puzzle_count\r\n        battle_start_time = time.time()\r\n        max_battle_time = 60  # æœ€å¤§ãƒãƒˆãƒ«æ™‚é–“ï¼ˆç§’ï¼‰\r\n        stage_45_in_battle = False\r\n        puzzle_search_attempts = 0  # puzzleæ¤œç´¢è©¦è¡Œå›æ•°\r\n        \r\n        self.log(f\"ãƒãƒˆãƒ«é–‹å§‹ (åˆæœŸpuzzleå›æ•°: {puzzle_tap_count})\", device_id)\r\n        \r\n        while self.running and device_id in self.threads:\r\n            # æœ€å¤§æ™‚é–“ãƒã‚§ãƒƒã‚¯\r\n            if time.time() - battle_start_time > max_battle_time:\r\n                self.log(\"ãƒãƒˆãƒ«æ™‚é–“è¶…é - æ¬¡ã®ã‚µã‚¤ã‚¯ãƒ«ã«ç§»è¡Œ\", device_id)\r\n                break\r\n            \r\n            # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆå–å¾—\r\n            screenshot = self.device_controller.fast_screenshot_to_memory(\r\n                device_id, self.settings.get('use_memory_capture', True)\r\n            )\r\n            if screenshot is None:\r\n                time.sleep(0.3)\r\n                continue\r\n            \r\n            # ãƒãƒˆãƒ«é–‹å§‹æ™‚ã«stage_45ã‚’ãƒã‚§ãƒƒã‚¯\r\n            if not stage_45_in_battle:\r\n                stage_45_pos = self.image_detector.find_image_on_screen_optimized(\r\n                    self.image_paths['stage_45'], screenshot\r\n                )\r\n                if stage_45_pos:\r\n                    stage_45_in_battle = True\r\n                    self.log(\"ãƒãƒˆãƒ«ä¸­ã‚¹ãƒ†ãƒ¼ã‚¸45æ¤œå‡º - closeç³»ç›£è¦–åœæ­¢\", device_id)\r\n            \r\n            # ãƒãƒˆãƒ«é–¢é€£ã®ç”»åƒã‚’åŒæ™‚æ¤œç´¢ï¼ˆpuzzleå„ªå…ˆé †åºï¼‰\r\n            battle_images = {\r\n                'puzzle': self.image_paths['puzzle'],  # puzzleã‚’æœ€åˆã«é…ç½®\r\n                'next': self.image_paths['next'],\r\n                'waza_ok': self.image_paths['waza_ok']\r\n            }\r\n            \r\n            # stage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿closeç³»ã‚’è¿½åŠ \r\n            if not stage_45_in_battle:\r\n                battle_images['close'] = self.image_paths['close']\r\n                battle_images['close_mini'] = self.image_paths['close_mini']\r\n            \r\n            detected = self.image_detector.find_multiple_images_on_screen_optimized(\r\n                battle_images, screenshot\r\n            )\r\n            \r\n            # æœ€å„ªå…ˆ: puzzle.pngã‚’ã‚¿ãƒƒãƒ—ï¼ˆå›æ•°åˆ¶é™ã‚ã‚Šãƒ»è¶…ç©æ¥µçš„æ¤œçŸ¥ï¼‰\r\n            if puzzle_tap_count < self.settings['puzzle_tap_count']:\r\n                puzzle_detected = False\r\n                \r\n                # æ–¹æ³•1: é€šå¸¸ã®æ¤œçŸ¥ã‚’è©¦è¡Œ\r\n                if 'puzzle' in detected:\r\n                    pos = detected['puzzle']['pos']\r\n                    confidence = detected['puzzle']['confidence']\r\n                    self.log(f\"puzzleé€šå¸¸æ¤œå‡º (å›æ•°: {puzzle_tap_count + 1}/{self.settings['puzzle_tap_count']}, ä¿¡é ¼åº¦: {confidence:.3f})\", device_id)\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"puzzle\", self.settings['tap_delay']\r\n                    )\r\n                    puzzle_tap_count += 1\r\n                    puzzle_detected = True\r\n                \r\n                # æ–¹æ³•2: é€šå¸¸æ¤œçŸ¥ã§å¤±æ•—ã—ãŸå ´åˆã€ã™ãã«å¼·åŒ–æ¤œçŸ¥ã‚’è©¦è¡Œ\r\n                if not puzzle_detected:\r\n                    puzzle_pos = self.image_detector.find_puzzle_with_enhanced_detection(\r\n                        self.image_paths['puzzle'], screenshot\r\n                    )\r\n                    if puzzle_pos:\r\n                        self.log(f\"puzzleå¼·åŒ–æ¤œå‡º (å›æ•°: {puzzle_tap_count + 1}/{self.settings['puzzle_tap_count']})\", device_id)\r\n                        self.device_controller.smart_tap_screen(\r\n                            puzzle_pos[0], puzzle_pos[1], device_id, \"puzzle\", self.settings['tap_delay']\r\n                        )\r\n                        puzzle_tap_count += 1\r\n                        puzzle_detected = True\r\n                \r\n                # æ–¹æ³•3: ãã‚Œã§ã‚‚å¤±æ•—ã—ãŸå ´åˆã€ä½é–¾å€¤ã§æœ€å¾Œã®è©¦è¡Œ\r\n                if not puzzle_detected and puzzle_search_attempts % 3 == 0:  # 3å›ã«1å›ã ã‘\r\n                    low_threshold_pos = self.image_detector.find_image_on_screen_optimized(\r\n                        self.image_paths['puzzle'], screenshot, threshold=0.5\r\n                    )\r\n                    if low_threshold_pos:\r\n                        self.log(f\"puzzleä½é–¾å€¤æ¤œå‡º (å›æ•°: {puzzle_tap_count + 1}/{self.settings['puzzle_tap_count']})\", device_id)\r\n                        self.device_controller.smart_tap_screen(\r\n                            low_threshold_pos[0], low_threshold_pos[1], device_id, \"puzzle\", self.settings['tap_delay']\r\n                        )\r\n                        puzzle_tap_count += 1\r\n                        puzzle_detected = True\r\n                \r\n                # puzzleæ¤œå‡ºæˆåŠŸæ™‚ã¯çŸ­ã„ã‚¹ãƒªãƒ¼ãƒ—ã§æ¬¡ã®ãƒ«ãƒ¼ãƒ—ã¸\r\n                if puzzle_detected:\r\n                    time.sleep(0.2)  # ã•ã‚‰ã«çŸ­ã„ãƒ‡ã‚£ãƒ¬ã‚¤ã§puzzleã‚’é€£ç¶šæ¤œç´¢\r\n                    continue\r\n                else:\r\n                    # puzzleæ¤œå‡ºå¤±æ•—æ™‚ã®å‡¦ç†ï¼ˆãƒ­ã‚°é »åº¦ã‚’åˆ¶å¾¡ï¼‰\r\n                    puzzle_search_attempts += 1\r\n                    if puzzle_search_attempts % 3 == 1:  # 3å›ã«1å›ãƒ­ã‚°ï¼ˆé »åº¦ã‚’ä¸Šã’ã‚‹ï¼‰\r\n                        self.log(f\"puzzleå…¨æ¤œå‡ºå¤±æ•— ({puzzle_search_attempts}å›ç›®) - waza_okã‚’å¾…æ©Ÿä¸­\", device_id)\r\n                        # å¤±æ•—æ™‚ã¯ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çŠ¶æ³ã‚’ãƒ­ã‚°\r\n                        if puzzle_search_attempts % 9 == 1:  # 9å›ã«1å›ã¯è©³ç´°ãƒ­ã‚°\r\n                            current_images = self.image_detector.find_multiple_images_on_screen_optimized(\r\n                                {'waza_ok': self.image_paths['waza_ok'], 'next': self.image_paths['next']}, screenshot\r\n                            )\r\n                            detected_names = list(current_images.keys())\r\n                            self.log(f\"ç¾åœ¨æ¤œå‡ºä¸­ã®ç”»åƒ: {detected_names if detected_names else 'ãªã—'}\", device_id)\r\n            \r\n            # æ¬¡ã®å„ªå…ˆåº¦: waza_ok.pngã‚’ã‚¿ãƒƒãƒ—\r\n            if 'waza_ok' in detected:\r\n                pos = detected['waza_ok']['pos']\r\n                self.device_controller.smart_tap_screen(\r\n                    pos[0], pos[1], device_id, \"waza_ok\", self.settings['tap_delay']\r\n                )\r\n                puzzle_tap_count = 0  # ãƒ‘ã‚ºãƒ«ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ãƒªã‚»ãƒƒãƒˆ\r\n                puzzle_search_attempts = 0  # æ¤œç´¢è©¦è¡Œå›æ•°ã‚‚ãƒªã‚»ãƒƒãƒˆ\r\n                continue\r\n            \r\n            # closeç³»ã®å‡¦ç†ï¼ˆstage_45ãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ï¼‰\r\n            if not stage_45_in_battle:\r\n                if 'close' in detected:\r\n                    pos = detected['close']['pos']\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n                    )\r\n                    continue\r\n                    \r\n                if 'close_mini' in detected:\r\n                    pos = detected['close_mini']['pos']\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n                    )\r\n                    continue\r\n            \r\n            # æœ€å¾Œ: next.pngãŒæ¤œå‡ºã•ã‚ŒãŸã‚‰ãƒãƒˆãƒ«çµ‚äº†\r\n            if 'next' in detected:\r\n                pos = detected['next']['pos']\r\n                self.device_controller.smart_tap_screen(\r\n                    pos[0], pos[1], device_id, \"next\", self.settings['tap_delay']\r\n                )\r\n                break\r\n            \r\n            # puzzleãŒå¿…è¦ãªå ´åˆã¯çŸ­ã„é–“éš”ã€ãã†ã§ãªã‘ã‚Œã°é€šå¸¸é–“éš”\r\n            if puzzle_tap_count < self.settings['puzzle_tap_count']:\r\n                time.sleep(max(0.15, self.settings['check_interval'] * 0.3))  # puzzleæ¤œç´¢æ™‚ã¯è¶…é«˜é€Ÿ\r\n            else:\r\n                time.sleep(self.settings['check_interval'])\r\n    \r\n    def toggle_realtime_monitor(self, device_id):\r\n        \"\"\"ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ã®é–‹å§‹/åœæ­¢\"\"\"\r\n        if not self.realtime_monitoring:\r\n            self.realtime_monitoring = True\r\n            \r\n            # ç›£è¦–ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’é–‹å§‹\r\n            self.realtime_monitor_thread = threading.Thread(\r\n                target=self.realtime_monitor_loop, \r\n                args=(device_id,)\r\n            )\r\n            self.realtime_monitor_thread.daemon = True\r\n            self.realtime_monitor_thread.start()\r\n            \r\n            self.log(\"ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–é–‹å§‹\")\r\n            return True\r\n        else:\r\n            self.realtime_monitoring = False\r\n            self.log(\"ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–åœæ­¢\")\r\n            return False\r\n    \r\n    def realtime_monitor_loop(self, device_id):\r\n        \"\"\"ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ã®ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—\"\"\"\r\n        last_detection_status = {}\r\n        \r\n        while self.realtime_monitoring:\r\n            try:\r\n                # ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆå–å¾—\r\n                screenshot = self.device_controller.fast_screenshot_to_memory(\r\n                    device_id, self.settings.get('use_memory_capture', True)\r\n                )\r\n                if screenshot is None:\r\n                    time.sleep(1.0)\r\n                    continue\r\n                \r\n                # å…¨ç”»åƒã‚’åŒæ™‚æ¤œç´¢\r\n                all_images = self.image_paths.copy()\r\n                detected = self.image_detector.find_multiple_images_on_screen_optimized(\r\n                    all_images, screenshot\r\n                )\r\n                \r\n                # æ¤œå‡ºçŠ¶æ³ã®å¤‰åŒ–ã‚’ãƒ­ã‚°\r\n                current_status = {}\r\n                for name in all_images.keys():\r\n                    current_status[name] = name in detected\r\n                    \r\n                    # çŠ¶æ…‹ãŒå¤‰åŒ–ã—ãŸå ´åˆã®ã¿ãƒ­ã‚°\r\n                    if name not in last_detection_status or last_detection_status[name] != current_status[name]:\r\n                        if current_status[name]:\r\n                            confidence = detected[name]['confidence']\r\n                            pos = detected[name]['pos']\r\n                            self.log(f\"ğŸ” æ¤œå‡º: {name} (ä¿¡é ¼åº¦: {confidence:.3f}, ä½ç½®: {pos})\", device_id)\r\n                        else:\r\n                            self.log(f\"âŒ æ¶ˆå¤±: {name}\", device_id)\r\n                \r\n                # puzzle.pngãŒæ¤œå‡ºã•ã‚Œã¦ã„ãªã„å ´åˆã¯å¼·åŒ–æ¤œçŸ¥ã‚’è©¦è¡Œ\r\n                if not current_status.get('puzzle', False):\r\n                    puzzle_pos = self.image_detector.find_puzzle_with_enhanced_detection(\r\n                        self.image_paths['puzzle'], screenshot\r\n                    )\r\n                    if puzzle_pos:\r\n                        self.log(f\"ğŸ” å¼·åŒ–æ¤œå‡º: puzzle (ä½ç½®: {puzzle_pos})\", device_id)\r\n                        current_status['puzzle'] = True\r\n                \r\n                last_detection_status = current_status.copy()\r\n                \r\n                # 1ç§’é–“éš”ã§ç›£è¦–\r\n                time.sleep(1.0)\r\n                \r\n            except Exception as e:\r\n                self.log(f\"ç›£è¦–ã‚¨ãƒ©ãƒ¼: {str(e)}\", device_id)\r\n                time.sleep(1.0)\r\n    \r\n    def log_device_compatibility(self, device_id):\r\n        \"\"\"ãƒ‡ãƒã‚¤ã‚¹äº’æ›æ€§æƒ…å ±ã‚’ãƒ­ã‚°å‡ºåŠ›\"\"\"\r\n        compat = self.device_controller.check_device_compatibility(device_id)\r\n        self.log(f\"ãƒ‡ãƒã‚¤ã‚¹äº’æ›æ€§ãƒã‚§ãƒƒã‚¯: Android {compat['android_version']}\", device_id)\r\n        if compat['memory_capture_supported']:\r\n            self.log(\"ãƒ¡ãƒ¢ãƒªç›´æ¥å–å¾—: ã‚µãƒãƒ¼ãƒˆ\", device_id)\r\n        else:\r\n            self.log(f\"ãƒ¡ãƒ¢ãƒªç›´æ¥å–å¾—: éã‚µãƒãƒ¼ãƒˆ - {compat['reason']}\", device_id)\r\n            self.log(\"é€šå¸¸ã®ãƒ•ã‚¡ã‚¤ãƒ«æ–¹å¼ã‚’ä½¿ç”¨ã—ã¾ã™\", device_id)\r\n"
        }
    ]
}