{
    "sourceFile": "automation_engine.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 19,
            "patches": [
                {
                    "date": 1750493481590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750495704628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,438 +1,274 @@\n-\"\"\"\r\n-自動化エンジンモジュール\r\n-自動周回のメインロジック、バトルループ、リアルタイム監視機能\r\n-\"\"\"\r\n-\r\n+import asyncio\r\n+import logging\r\n import time\r\n-import threading\r\n-import random\r\n-from image_detector import ImageDetector\r\n-from device_controller import DeviceController\r\n+from typing import Dict, Optional, Tuple, List\r\n+from enum import Enum\r\n+from dataclasses import dataclass\r\n+from device_controller import MultiDeviceController\r\n+from image_detector import MultiDeviceImageDetector\r\n \r\n \r\n+class GameState(Enum):\r\n+    \"\"\"ゲーム状態の列挙\"\"\"\r\n+    IDLE = \"idle\"\r\n+    BOSS_DETECTED = \"boss_detected\"\r\n+    PLAY_DETECTED = \"play_detected\"\r\n+    PUZZLE_DETECTED = \"puzzle_detected\"\r\n+    WAZA_OK_DETECTED = \"waza_ok_detected\"\r\n+    NEXT_DETECTED = \"next_detected\"\r\n+    STAGE_45_DETECTED = \"stage_45_detected\"\r\n+\r\n+\r\n+@dataclass\r\n+class DeviceState:\r\n+    \"\"\"デバイス状態を管理するデータクラス\"\"\"\r\n+    device_id: str\r\n+    current_state: GameState = GameState.IDLE\r\n+    last_action_time: float = 0\r\n+    tap_count: int = 0\r\n+    error_count: int = 0\r\n+    is_active: bool = True\r\n+\r\n+\r\n class AutomationEngine:\r\n-    def __init__(self, image_paths, settings, log_callback):\r\n-        self.image_paths = image_paths\r\n-        self.settings = settings\r\n-        self.log = log_callback\r\n+    \"\"\"妖怪ウォッチぷにぷに自動周回エンジン\"\"\"\r\n+    \r\n+    def __init__(self, template_dir: str = \"image\"):\r\n+        self.device_controller = MultiDeviceController()\r\n+        self.image_detector = MultiDeviceImageDetector(template_dir)\r\n+        self.device_states = {}\r\n+        self.is_running = False\r\n+        self.logger = logging.getLogger(__name__)\r\n         \r\n-        self.image_detector = ImageDetector(settings['similarity_threshold'])\r\n-        self.device_controller = DeviceController()\r\n+        # 設定\r\n+        self.detection_threshold = 0.8\r\n+        self.tap_cooldown = 0.5  # タップ間隔（秒）\r\n+        self.screen_capture_interval = 0.1  # 画面キャプチャ間隔（秒）\r\n+        self.max_error_count = 5  # 最大エラー回数\r\n         \r\n-        self.running = False\r\n-        self.threads = {}\r\n-        self.device_status = {}\r\n+        # 統計情報\r\n+        self.total_loops = 0\r\n+        self.start_time = 0\r\n         \r\n-        # リアルタイム監視用\r\n-        self.realtime_monitoring = False\r\n-        self.realtime_monitor_thread = None\r\n-        \r\n-    def update_settings(self, settings):\r\n-        \"\"\"設定を更新\"\"\"\r\n-        self.settings = settings\r\n-        self.image_detector.similarity_threshold = settings['similarity_threshold']\r\n+    def add_device(self, device_id: str) -> bool:\r\n+        \"\"\"デバイスを追加\"\"\"\r\n+        if self.device_controller.add_device(device_id):\r\n+            self.device_states[device_id] = DeviceState(device_id)\r\n+            self.logger.info(f\"デバイス {device_id} を追加しました\")\r\n+            return True\r\n+        return False\r\n     \r\n-    def human_like_delay(self):\r\n-        \"\"\"人間らしいランダムな遅延\"\"\"\r\n-        delay = random.uniform(\r\n-            self.settings['human_like_delay_min'], \r\n-            self.settings['human_like_delay_max']\r\n-        )\r\n-        time.sleep(delay)\r\n+    def remove_device(self, device_id: str):\r\n+        \"\"\"デバイスを削除\"\"\"\r\n+        self.device_controller.remove_device(device_id)\r\n+        if device_id in self.device_states:\r\n+            del self.device_states[device_id]\r\n+        self.logger.info(f\"デバイス {device_id} を削除しました\")\r\n     \r\n-    def start_automation(self, selected_devices):\r\n-        \"\"\"自動化開始\"\"\"\r\n-        self.running = True\r\n-        \r\n-        # デバイス互換性チェック\r\n-        for device_id in selected_devices:\r\n-            self.log_device_compatibility(device_id)\r\n-        \r\n-        # 各デバイスでスレッドを開始\r\n-        for device_id in selected_devices:\r\n-            thread = threading.Thread(target=self.automation_loop, args=(device_id,))\r\n-            thread.daemon = True\r\n-            self.threads[device_id] = thread\r\n-            thread.start()\r\n-            self.log(\"自動化開始\", device_id)\r\n+    def get_device_list(self) -> List[str]:\r\n+        \"\"\"管理中のデバイス一覧を取得\"\"\"\r\n+        return list(self.device_states.keys())\r\n     \r\n-    def stop_automation(self):\r\n-        \"\"\"自動化停止\"\"\"\r\n-        self.running = False\r\n-        self.threads.clear()\r\n-        self.log(\"全デバイスの自動化を停止\")\r\n+    def get_device_state(self, device_id: str) -> Optional[DeviceState]:\r\n+        \"\"\"デバイス状態を取得\"\"\"\r\n+        return self.device_states.get(device_id)\r\n     \r\n-    def automation_loop(self, device_id):\r\n-        \"\"\"最適化されたメインの自動化ループ\"\"\"\r\n-        self.device_status[device_id] = \"実行中\"\r\n-        puzzle_tap_count = 0\r\n-        stage_45_detected = False\r\n+    def set_device_active(self, device_id: str, active: bool):\r\n+        \"\"\"デバイスのアクティブ状態を設定\"\"\"\r\n+        if device_id in self.device_states:\r\n+            self.device_states[device_id].is_active = active\r\n+    \r\n+    async def process_device_detection(self, device_id: str, \r\n+                                     detections: Dict[str, Optional[Tuple[int, int]]]):\r\n+        \"\"\"デバイスの検出結果を処理\"\"\"\r\n+        if device_id not in self.device_states:\r\n+            return\r\n         \r\n-        while self.running and device_id in self.threads:\r\n-            try:\r\n-                # 優先度の高い画像を同時検索\r\n-                priority_images = {}\r\n-                \r\n-                # stage_45.pngを最初にチェック\r\n-                screenshot = self.device_controller.fast_screenshot_to_memory(\r\n-                    device_id, self.settings.get('use_memory_capture', True)\r\n-                )\r\n-                if screenshot is None:\r\n-                    time.sleep(0.5)\r\n-                    continue\r\n-                \r\n-                stage_45_pos = self.image_detector.find_image_on_screen_optimized(\r\n-                    self.image_paths['stage_45'], screenshot\r\n-                )\r\n-                \r\n-                if stage_45_pos and not stage_45_detected:\r\n-                    stage_45_detected = True\r\n-                    self.log(\"ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n-                elif not stage_45_pos and stage_45_detected:\r\n-                    stage_45_detected = False\r\n-                    self.log(\"ステージ45終了 - close系ボタンの監視を再開\", device_id)\r\n-                \r\n-                # close系の監視（stage_45検出時は除く）\r\n-                if not stage_45_detected:\r\n-                    priority_images['close'] = self.image_paths['close']\r\n-                    priority_images['close_mini'] = self.image_paths['close_mini']\r\n-                \r\n-                # 現在の状態に応じた画像を追加\r\n-                priority_images['boss'] = self.image_paths['boss']\r\n-                priority_images['play'] = self.image_paths['play']\r\n-                priority_images['next'] = self.image_paths['next']\r\n-                \r\n-                # 複数画像を同時検索（最適化版）\r\n-                detected_images = self.image_detector.find_multiple_images_on_screen_optimized(\r\n-                    priority_images, screenshot\r\n-                )\r\n-                \r\n-                # playボタンを直接検出した場合の処理を追加\r\n-                if 'play' in detected_images:\r\n-                    self.log(\"playボタンを直接検出しました\", device_id)\r\n-                    pos = detected_images['play']['pos']\r\n-                    \r\n-                    # play.pngをタップ前に再度stage_45.pngをチェック\r\n-                    stage_45_pos = self.image_detector.find_image_on_screen_optimized(\r\n-                        self.image_paths['stage_45'], screenshot\r\n-                    )\r\n-                    if stage_45_pos:\r\n-                        stage_45_detected = True\r\n-                        self.log(\"プレイ前ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n-                    \r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"play\", self.settings['tap_delay']\r\n-                    )\r\n-                    \r\n-                    # バトルループ（③④の処理）\r\n-                    self.battle_loop(device_id, puzzle_tap_count)\r\n-                    puzzle_tap_count = 0\r\n-                    continue\r\n-                \r\n-                # 優先順位に従って処理\r\n-                if 'close' in detected_images and not stage_45_detected:\r\n-                    pos = detected_images['close']['pos']\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n-                    )\r\n-                    continue\r\n-                    \r\n-                if 'close_mini' in detected_images and not stage_45_detected:\r\n-                    pos = detected_images['close_mini']['pos']\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n-                    )\r\n-                    continue\r\n-                \r\n-                # next.pngが検出された場合（最優先）\r\n-                if 'next' in detected_images:\r\n-                    pos = detected_images['next']['pos']\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"next\", self.settings['tap_delay']\r\n-                    )\r\n-                    stage_45_detected = False  # リセット\r\n-                    puzzle_tap_count = 0\r\n-                    continue\r\n-                \r\n-                # boss.pngが検出された場合\r\n-                if 'boss' in detected_images:\r\n-                    pos = detected_images['boss']['pos']\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"boss\", self.settings['tap_delay']\r\n-                    )\r\n-                    \r\n-                    # play.pngを待機して検索（最適化版・強化）\r\n-                    self.log(\"boss検出後、playボタンを検索中...\", device_id)\r\n-                    play_found = False\r\n-                    max_attempts = 10  # 最大試行回数\r\n-                    \r\n-                    for attempt in range(max_attempts):\r\n-                        time.sleep(0.5)  # 画面遷移を待つ\r\n-                        # 新しいスクリーンショットを取得\r\n-                        new_screenshot = self.device_controller.fast_screenshot_to_memory(\r\n-                            device_id, self.settings.get('use_memory_capture', True)\r\n-                        )\r\n-                        if new_screenshot is None:\r\n-                            continue\r\n-                            \r\n-                        # 段階的閾値検索を使用\r\n-                        play_pos = self.image_detector.find_image_with_multiple_thresholds(\r\n-                            self.image_paths['play'], new_screenshot\r\n-                        )\r\n-                        \r\n-                        if play_pos:\r\n-                            self.log(f\"playボタン検出成功 (試行{attempt + 1}回目): {play_pos}\", device_id)\r\n-                            play_found = True\r\n-                            \r\n-                            self.device_controller.smart_tap_screen(\r\n-                                play_pos[0], play_pos[1], device_id, \"play\", self.settings['tap_delay']\r\n-                            )\r\n-                            \r\n-                            # バトルループ（③④の処理）\r\n-                            self.battle_loop(device_id, puzzle_tap_count)\r\n-                            puzzle_tap_count = 0\r\n-                            break\r\n-                        else:\r\n-                            self.log(f\"playボタン未検出 (試行{attempt + 1}回目)\", device_id)\r\n-                    \r\n-                    if not play_found:\r\n-                        self.log(f\"playボタンが見つかりませんでした（{max_attempts}回試行）\", device_id)\r\n-                \r\n-                # 短い間隔で次のチェック\r\n-                time.sleep(self.settings['check_interval'])\r\n-                \r\n-            except Exception as e:\r\n-                self.log(f\"自動化エラー: {str(e)}\", device_id)\r\n-                time.sleep(0.5)\r\n+        device_state = self.device_states[device_id]\r\n+        if not device_state.is_active:\r\n+            return\r\n         \r\n-        self.device_status[device_id] = \"停止\"\r\n-        self.log(\"自動化停止\", device_id)\r\n-    \r\n-    def battle_loop(self, device_id, initial_puzzle_count=0):\r\n-        \"\"\"バトル中のループ処理（③④の最適化・puzzle検知強化）\"\"\"\r\n-        puzzle_tap_count = initial_puzzle_count\r\n-        battle_start_time = time.time()\r\n-        max_battle_time = 60  # 最大バトル時間（秒）\r\n-        stage_45_in_battle = False\r\n-        puzzle_search_attempts = 0  # puzzle検索試行回数\r\n+        current_time = time.time()\r\n         \r\n-        self.log(f\"バトル開始 (初期puzzle回数: {puzzle_tap_count})\", device_id)\r\n+        # タップクールダウンチェック\r\n+        if current_time - device_state.last_action_time < self.tap_cooldown:\r\n+            return\r\n         \r\n-        while self.running and device_id in self.threads:\r\n-            # 最大時間チェック\r\n-            if time.time() - battle_start_time > max_battle_time:\r\n-                self.log(\"バトル時間超過 - 次のサイクルに移行\", device_id)\r\n-                break\r\n+        try:\r\n+            # 優先度順で処理\r\n+            action_taken = False\r\n             \r\n-            # スクリーンショット取得\r\n-            screenshot = self.device_controller.fast_screenshot_to_memory(\r\n-                device_id, self.settings.get('use_memory_capture', True)\r\n-            )\r\n-            if screenshot is None:\r\n-                time.sleep(0.3)\r\n-                continue\r\n+            # 1. bossが検出されたらタップ\r\n+            if detections.get('boss') and not action_taken:\r\n+                x, y = detections['boss']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.BOSS_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"デバイス {device_id}: BOSSをタップしました\")\r\n             \r\n-            # バトル開始時にstage_45をチェック\r\n-            if not stage_45_in_battle:\r\n-                stage_45_pos = self.image_detector.find_image_on_screen_optimized(\r\n-                    self.image_paths['stage_45'], screenshot\r\n-                )\r\n-                if stage_45_pos:\r\n-                    stage_45_in_battle = True\r\n-                    self.log(\"バトル中ステージ45検出 - close系監視停止\", device_id)\r\n-            \r\n-            # バトル関連の画像を同時検索（puzzle優先順序）\r\n-            battle_images = {\r\n-                'puzzle': self.image_paths['puzzle'],  # puzzleを最初に配置\r\n-                'next': self.image_paths['next'],\r\n-                'waza_ok': self.image_paths['waza_ok']\r\n-            }\r\n-            \r\n-            # stage_45が検出されていない場合のみclose系を追加\r\n-            if not stage_45_in_battle:\r\n-                battle_images['close'] = self.image_paths['close']\r\n-                battle_images['close_mini'] = self.image_paths['close_mini']\r\n-            \r\n-            detected = self.image_detector.find_multiple_images_on_screen_optimized(\r\n-                battle_images, screenshot\r\n-            )\r\n-            \r\n-            # 最優先: puzzle.pngをタップ（回数制限あり・超積極的検知）\r\n-            if puzzle_tap_count < self.settings['puzzle_tap_count']:\r\n-                puzzle_detected = False\r\n-                \r\n-                # 方法1: 通常の検知を試行\r\n-                if 'puzzle' in detected:\r\n-                    pos = detected['puzzle']['pos']\r\n-                    confidence = detected['puzzle']['confidence']\r\n-                    self.log(f\"puzzle通常検出 (回数: {puzzle_tap_count + 1}/{self.settings['puzzle_tap_count']}, 信頼度: {confidence:.3f})\", device_id)\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"puzzle\", self.settings['tap_delay']\r\n-                    )\r\n-                    puzzle_tap_count += 1\r\n-                    puzzle_detected = True\r\n-                \r\n-                # 方法2: 通常検知で失敗した場合、すぐに強化検知を試行\r\n-                if not puzzle_detected:\r\n-                    puzzle_pos = self.image_detector.find_puzzle_with_enhanced_detection(\r\n-                        self.image_paths['puzzle'], screenshot\r\n-                    )\r\n-                    if puzzle_pos:\r\n-                        self.log(f\"puzzle強化検出 (回数: {puzzle_tap_count + 1}/{self.settings['puzzle_tap_count']})\", device_id)\r\n-                        self.device_controller.smart_tap_screen(\r\n-                            puzzle_pos[0], puzzle_pos[1], device_id, \"puzzle\", self.settings['tap_delay']\r\n-                        )\r\n-                        puzzle_tap_count += 1\r\n-                        puzzle_detected = True\r\n-                \r\n-                # 方法3: それでも失敗した場合、低閾値で最後の試行\r\n-                if not puzzle_detected and puzzle_search_attempts % 3 == 0:  # 3回に1回だけ\r\n-                    low_threshold_pos = self.image_detector.find_image_on_screen_optimized(\r\n-                        self.image_paths['puzzle'], screenshot, threshold=0.5\r\n-                    )\r\n-                    if low_threshold_pos:\r\n-                        self.log(f\"puzzle低閾値検出 (回数: {puzzle_tap_count + 1}/{self.settings['puzzle_tap_count']})\", device_id)\r\n-                        self.device_controller.smart_tap_screen(\r\n-                            low_threshold_pos[0], low_threshold_pos[1], device_id, \"puzzle\", self.settings['tap_delay']\r\n-                        )\r\n-                        puzzle_tap_count += 1\r\n-                        puzzle_detected = True\r\n-                \r\n-                # puzzle検出成功時は短いスリープで次のループへ\r\n-                if puzzle_detected:\r\n-                    time.sleep(0.2)  # さらに短いディレイでpuzzleを連続検索\r\n-                    continue\r\n+            # 2. playが検出されたらタップ（ただしstage_45が検出されている場合は処理しない）\r\n+            if detections.get('play') and not action_taken:\r\n+                # stage_45の特別処理\r\n+                if detections.get('stage_45'):\r\n+                    self.logger.info(f\"デバイス {device_id}: stage_45が検出されたため、playをスキップします\")\r\n+                    device_state.current_state = GameState.STAGE_45_DETECTED\r\n                 else:\r\n-                    # puzzle検出失敗時の処理（ログ頻度を制御）\r\n-                    puzzle_search_attempts += 1\r\n-                    if puzzle_search_attempts % 3 == 1:  # 3回に1回ログ（頻度を上げる）\r\n-                        self.log(f\"puzzle全検出失敗 ({puzzle_search_attempts}回目) - waza_okを待機中\", device_id)\r\n-                        # 失敗時はリアルタイム状況をログ\r\n-                        if puzzle_search_attempts % 9 == 1:  # 9回に1回は詳細ログ\r\n-                            current_images = self.image_detector.find_multiple_images_on_screen_optimized(\r\n-                                {'waza_ok': self.image_paths['waza_ok'], 'next': self.image_paths['next']}, screenshot\r\n-                            )\r\n-                            detected_names = list(current_images.keys())\r\n-                            self.log(f\"現在検出中の画像: {detected_names if detected_names else 'なし'}\", device_id)\r\n+                    x, y = detections['play']\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.PLAY_DETECTED\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"デバイス {device_id}: PLAYをタップしました\")\r\n             \r\n-            # 次の優先度: waza_ok.pngをタップ\r\n-            if 'waza_ok' in detected:\r\n-                pos = detected['waza_ok']['pos']\r\n-                self.device_controller.smart_tap_screen(\r\n-                    pos[0], pos[1], device_id, \"waza_ok\", self.settings['tap_delay']\r\n-                )\r\n-                puzzle_tap_count = 0  # パズルカウンターリセット\r\n-                puzzle_search_attempts = 0  # 検索試行回数もリセット\r\n-                continue\r\n+            # 3. puzzleが検出されたらタップ\r\n+            if detections.get('puzzle') and not action_taken:\r\n+                x, y = detections['puzzle']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.PUZZLE_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"デバイス {device_id}: PUZZLEをタップしました\")\r\n             \r\n-            # close系の処理（stage_45が検出されていない場合のみ）\r\n-            if not stage_45_in_battle:\r\n-                if 'close' in detected:\r\n-                    pos = detected['close']['pos']\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n-                    )\r\n-                    continue\r\n-                    \r\n-                if 'close_mini' in detected:\r\n-                    pos = detected['close_mini']['pos']\r\n-                    self.device_controller.smart_tap_screen(\r\n-                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n-                    )\r\n-                    continue\r\n+            # 4. waza_okが検出されたらタップ\r\n+            if detections.get('waza_ok') and not action_taken:\r\n+                x, y = detections['waza_ok']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.WAZA_OK_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"デバイス {device_id}: WAZA_OKをタップしました\")\r\n             \r\n-            # 最後: next.pngが検出されたらバトル終了\r\n-            if 'next' in detected:\r\n-                pos = detected['next']['pos']\r\n-                self.device_controller.smart_tap_screen(\r\n-                    pos[0], pos[1], device_id, \"next\", self.settings['tap_delay']\r\n-                )\r\n-                break\r\n+            # 5. nextが検出されたらタップ\r\n+            if detections.get('next') and not action_taken:\r\n+                x, y = detections['next']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.NEXT_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.total_loops += 1  # ループ完了のカウント\r\n+                    self.logger.info(f\"デバイス {device_id}: NEXTをタップしました（ループ完了: {self.total_loops}）\")\r\n             \r\n-            # puzzleが必要な場合は短い間隔、そうでなければ通常間隔\r\n-            if puzzle_tap_count < self.settings['puzzle_tap_count']:\r\n-                time.sleep(max(0.15, self.settings['check_interval'] * 0.3))  # puzzle検索時は超高速\r\n-            else:\r\n-                time.sleep(self.settings['check_interval'])\r\n-    \r\n-    def toggle_realtime_monitor(self, device_id):\r\n-        \"\"\"リアルタイム監視の開始/停止\"\"\"\r\n-        if not self.realtime_monitoring:\r\n-            self.realtime_monitoring = True\r\n+            # エラーカウントリセット\r\n+            if action_taken:\r\n+                device_state.error_count = 0\r\n             \r\n-            # 監視スレッドを開始\r\n-            self.realtime_monitor_thread = threading.Thread(\r\n-                target=self.realtime_monitor_loop, \r\n-                args=(device_id,)\r\n-            )\r\n-            self.realtime_monitor_thread.daemon = True\r\n-            self.realtime_monitor_thread.start()\r\n+        except Exception as e:\r\n+            device_state.error_count += 1\r\n+            self.logger.error(f\"デバイス {device_id} の処理エラー: {e}\")\r\n             \r\n-            self.log(\"リアルタイム監視開始\")\r\n-            return True\r\n-        else:\r\n-            self.realtime_monitoring = False\r\n-            self.log(\"リアルタイム監視停止\")\r\n-            return False\r\n+            # エラー回数が上限を超えた場合、デバイスを非アクティブにする\r\n+            if device_state.error_count >= self.max_error_count:\r\n+                device_state.is_active = False\r\n+                self.logger.warning(f\"デバイス {device_id} がエラー上限に達したため非アクティブにしました\")\r\n     \r\n-    def realtime_monitor_loop(self, device_id):\r\n-        \"\"\"リアルタイム監視のメインループ\"\"\"\r\n-        last_detection_status = {}\r\n+    async def automation_loop(self):\r\n+        \"\"\"メイン自動化ループ\"\"\"\r\n+        self.logger.info(\"自動化ループを開始します\")\r\n+        self.start_time = time.time()\r\n         \r\n-        while self.realtime_monitoring:\r\n+        while self.is_running:\r\n             try:\r\n-                # スクリーンショット取得\r\n-                screenshot = self.device_controller.fast_screenshot_to_memory(\r\n-                    device_id, self.settings.get('use_memory_capture', True)\r\n-                )\r\n-                if screenshot is None:\r\n-                    time.sleep(1.0)\r\n+                # 全デバイスの画面キャプチャ\r\n+                screen_data = await self.device_controller.capture_all_screens()\r\n+                \r\n+                if not screen_data:\r\n+                    await asyncio.sleep(self.screen_capture_interval)\r\n                     continue\r\n                 \r\n-                # 全画像を同時検索\r\n-                all_images = self.image_paths.copy()\r\n-                detected = self.image_detector.find_multiple_images_on_screen_optimized(\r\n-                    all_images, screenshot\r\n+                # 全デバイスで画像検出\r\n+                detection_results = await self.image_detector.detect_all_devices(\r\n+                    screen_data, self.detection_threshold\r\n                 )\r\n                 \r\n-                # 検出状況の変化をログ\r\n-                current_status = {}\r\n-                for name in all_images.keys():\r\n-                    current_status[name] = name in detected\r\n-                    \r\n-                    # 状態が変化した場合のみログ\r\n-                    if name not in last_detection_status or last_detection_status[name] != current_status[name]:\r\n-                        if current_status[name]:\r\n-                            confidence = detected[name]['confidence']\r\n-                            pos = detected[name]['pos']\r\n-                            self.log(f\"🔍 検出: {name} (信頼度: {confidence:.3f}, 位置: {pos})\", device_id)\r\n-                        else:\r\n-                            self.log(f\"❌ 消失: {name}\", device_id)\r\n+                # 各デバイスの検出結果を処理\r\n+                tasks = []\r\n+                for device_id, detections in detection_results.items():\r\n+                    if device_id in self.device_states:\r\n+                        task = self.process_device_detection(device_id, detections)\r\n+                        tasks.append(task)\r\n                 \r\n-                # puzzle.pngが検出されていない場合は強化検知を試行\r\n-                if not current_status.get('puzzle', False):\r\n-                    puzzle_pos = self.image_detector.find_puzzle_with_enhanced_detection(\r\n-                        self.image_paths['puzzle'], screenshot\r\n-                    )\r\n-                    if puzzle_pos:\r\n-                        self.log(f\"🔍 強化検出: puzzle (位置: {puzzle_pos})\", device_id)\r\n-                        current_status['puzzle'] = True\r\n+                # 全デバイスの処理を並行実行\r\n+                if tasks:\r\n+                    await asyncio.gather(*tasks, return_exceptions=True)\r\n                 \r\n-                last_detection_status = current_status.copy()\r\n+                # 短い待機\r\n+                await asyncio.sleep(self.screen_capture_interval)\r\n                 \r\n-                # 1秒間隔で監視\r\n-                time.sleep(1.0)\r\n-                \r\n             except Exception as e:\r\n-                self.log(f\"監視エラー: {str(e)}\", device_id)\r\n-                time.sleep(1.0)\r\n+                self.logger.error(f\"自動化ループエラー: {e}\")\r\n+                await asyncio.sleep(1)  # エラー時は少し長めに待機\r\n     \r\n-    def log_device_compatibility(self, device_id):\r\n-        \"\"\"デバイス互換性情報をログ出力\"\"\"\r\n-        compat = self.device_controller.check_device_compatibility(device_id)\r\n-        self.log(f\"デバイス互換性チェック: Android {compat['android_version']}\", device_id)\r\n-        if compat['memory_capture_supported']:\r\n-            self.log(\"メモリ直接取得: サポート\", device_id)\r\n-        else:\r\n-            self.log(f\"メモリ直接取得: 非サポート - {compat['reason']}\", device_id)\r\n-            self.log(\"通常のファイル方式を使用します\", device_id)\r\n+    async def start_automation(self):\r\n+        \"\"\"自動化を開始\"\"\"\r\n+        if self.is_running:\r\n+            self.logger.warning(\"自動化は既に実行中です\")\r\n+            return\r\n+        \r\n+        if not self.device_states:\r\n+            self.logger.error(\"デバイスが登録されていません\")\r\n+            return\r\n+        \r\n+        self.is_running = True\r\n+        self.total_loops = 0\r\n+        await self.automation_loop()\r\n+    \r\n+    def stop_automation(self):\r\n+        \"\"\"自動化を停止\"\"\"\r\n+        self.is_running = False\r\n+        self.logger.info(\"自動化を停止しました\")\r\n+    \r\n+    def get_statistics(self) -> Dict:\r\n+        \"\"\"統計情報を取得\"\"\"\r\n+        current_time = time.time()\r\n+        elapsed_time = current_time - self.start_time if self.start_time > 0 else 0\r\n+        \r\n+        stats = {\r\n+            'total_loops': self.total_loops,\r\n+            'elapsed_time': elapsed_time,\r\n+            'loops_per_hour': (self.total_loops / elapsed_time * 3600) if elapsed_time > 0 else 0,\r\n+            'active_devices': len([d for d in self.device_states.values() if d.is_active]),\r\n+            'total_devices': len(self.device_states),\r\n+            'device_details': {}\r\n+        }\r\n+        \r\n+        for device_id, state in self.device_states.items():\r\n+            stats['device_details'][device_id] = {\r\n+                'state': state.current_state.value,\r\n+                'tap_count': state.tap_count,\r\n+                'error_count': state.error_count,\r\n+                'is_active': state.is_active,\r\n+                'last_action_time': state.last_action_time\r\n+            }\r\n+        \r\n+        return stats\r\n+    \r\n+    def reset_statistics(self):\r\n+        \"\"\"統計情報をリセット\"\"\"\r\n+        self.total_loops = 0\r\n+        self.start_time = time.time()\r\n+        for state in self.device_states.values():\r\n+            state.tap_count = 0\r\n+            state.error_count = 0\r\n+    \r\n+    def set_detection_threshold(self, threshold: float):\r\n+        \"\"\"検出閾値を設定\"\"\"\r\n+        self.detection_threshold = max(0.1, min(1.0, threshold))\r\n+    \r\n+    def set_tap_cooldown(self, cooldown: float):\r\n+        \"\"\"タップクールダウンを設定\"\"\"\r\n+        self.tap_cooldown = max(0.1, cooldown)\r\n+    \r\n+    def set_capture_interval(self, interval: float):\r\n+        \"\"\"画面キャプチャ間隔を設定\"\"\"\r\n+        self.screen_capture_interval = max(0.05, interval)\r\n"
                },
                {
                    "date": 1750496229563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,10 +195,9 @@\n                 tasks = []\r\n                 for device_id, detections in detection_results.items():\r\n                     if device_id in self.device_states:\r\n                         task = self.process_device_detection(device_id, detections)\r\n-                        tasks.append(task)\r\n-                \r\n+                        tasks.append(task)                \r\n                 # 全デバイスの処理を並行実行\r\n                 if tasks:\r\n                     await asyncio.gather(*tasks, return_exceptions=True)\r\n                 \r\n@@ -220,9 +219,14 @@\n             return\r\n         \r\n         self.is_running = True\r\n         self.total_loops = 0\r\n-        await self.automation_loop()\r\n+        try:\r\n+            await self.automation_loop()\r\n+        except Exception as e:\r\n+            self.logger.error(f\"自動化実行エラー: {e}\")\r\n+        finally:\r\n+            self.is_running = False\r\n     \r\n     def stop_automation(self):\r\n         \"\"\"自動化を停止\"\"\"\r\n         self.is_running = False\r\n"
                },
                {
                    "date": 1750499271477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,10 +88,9 @@\n         if not device_state.is_active:\r\n             return\r\n         \r\n         current_time = time.time()\r\n-        \r\n-        # タップクールダウンチェック\r\n+          # タップクールダウンチェック\r\n         if current_time - device_state.last_action_time < self.tap_cooldown:\r\n             return\r\n         \r\n         try:\r\n@@ -108,25 +107,43 @@\n                     device_state.tap_count += 1\r\n                     action_taken = True\r\n                     self.logger.info(f\"デバイス {device_id}: BOSSをタップしました\")\r\n             \r\n-            # 2. playが検出されたらタップ（ただしstage_45が検出されている場合は処理しない）\r\n+            # 2. playが検出されたらタップ\r\n             if detections.get('play') and not action_taken:\r\n-                # stage_45の特別処理\r\n-                if detections.get('stage_45'):\r\n-                    self.logger.info(f\"デバイス {device_id}: stage_45が検出されたため、playをスキップします\")\r\n-                    device_state.current_state = GameState.STAGE_45_DETECTED\r\n-                else:\r\n-                    x, y = detections['play']\r\n+                x, y = detections['play']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.PLAY_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"デバイス {device_id}: PLAYをタップしました\")\r\n+            \r\n+            # 3. close/close_miniが検出されたらタップ（ただしstage_45が検出されている場合はスキップ）\r\n+            if not action_taken and not detections.get('stage_45'):\r\n+                if detections.get('close'):\r\n+                    x, y = detections['close']\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n-                        device_state.current_state = GameState.PLAY_DETECTED\r\n+                        device_state.current_state = GameState.IDLE\r\n                         device_state.last_action_time = current_time\r\n                         device_state.tap_count += 1\r\n                         action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: PLAYをタップしました\")\r\n+                        self.logger.info(f\"デバイス {device_id}: CLOSEをタップしました\")\r\n+                elif detections.get('close_mini'):\r\n+                    x, y = detections['close_mini']\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.IDLE\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"デバイス {device_id}: CLOSE_MINIをタップしました\")\r\n+            elif detections.get('stage_45'):\r\n+                self.logger.info(f\"デバイス {device_id}: stage_45が検出されたため、close/close_miniをスキップします\")\r\n             \r\n-            # 3. puzzleが検出されたらタップ\r\n+            # 4. puzzleが検出されたらタップ\r\n             if detections.get('puzzle') and not action_taken:\r\n                 x, y = detections['puzzle']\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n@@ -135,9 +152,9 @@\n                     device_state.tap_count += 1\r\n                     action_taken = True\r\n                     self.logger.info(f\"デバイス {device_id}: PUZZLEをタップしました\")\r\n             \r\n-            # 4. waza_okが検出されたらタップ\r\n+            # 5. waza_okが検出されたらタップ\r\n             if detections.get('waza_ok') and not action_taken:\r\n                 x, y = detections['waza_ok']\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n@@ -146,9 +163,9 @@\n                     device_state.tap_count += 1\r\n                     action_taken = True\r\n                     self.logger.info(f\"デバイス {device_id}: WAZA_OKをタップしました\")\r\n             \r\n-            # 5. nextが検出されたらタップ\r\n+            # 6. nextが検出されたらタップ\r\n             if detections.get('next') and not action_taken:\r\n                 x, y = detections['next']\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n@@ -165,10 +182,9 @@\n             \r\n         except Exception as e:\r\n             device_state.error_count += 1\r\n             self.logger.error(f\"デバイス {device_id} の処理エラー: {e}\")\r\n-            \r\n-            # エラー回数が上限を超えた場合、デバイスを非アクティブにする\r\n+              # エラー回数が上限を超えた場合、デバイスを非アクティブにする\r\n             if device_state.error_count >= self.max_error_count:\r\n                 device_state.is_active = False\r\n                 self.logger.warning(f\"デバイス {device_id} がエラー上限に達したため非アクティブにしました\")\r\n     \r\n@@ -195,16 +211,20 @@\n                 tasks = []\r\n                 for device_id, detections in detection_results.items():\r\n                     if device_id in self.device_states:\r\n                         task = self.process_device_detection(device_id, detections)\r\n-                        tasks.append(task)                \r\n+                        tasks.append(task)\r\n+                \r\n                 # 全デバイスの処理を並行実行\r\n                 if tasks:\r\n                     await asyncio.gather(*tasks, return_exceptions=True)\r\n-                \r\n-                # 短い待機\r\n+                  # 短い待機\r\n                 await asyncio.sleep(self.screen_capture_interval)\r\n                 \r\n+            except asyncio.CancelledError:\r\n+                # キャンセルされた場合は正常終了\r\n+                self.logger.info(\"自動化ループがキャンセルされました\")\r\n+                break\r\n             except Exception as e:\r\n                 self.logger.error(f\"自動化ループエラー: {e}\")\r\n                 await asyncio.sleep(1)  # エラー時は少し長めに待機\r\n     \r\n@@ -228,10 +248,20 @@\n             self.is_running = False\r\n     \r\n     def stop_automation(self):\r\n         \"\"\"自動化を停止\"\"\"\r\n+        self.logger.info(\"自動化停止要求を受信しました\")\r\n         self.is_running = False\r\n-        self.logger.info(\"自動化を停止しました\")\r\n+        \r\n+        # 現在実行中のタスクがあればキャンセル\r\n+        try:\r\n+            current_loop = asyncio.get_running_loop()\r\n+            for task in asyncio.all_tasks(current_loop):\r\n+                if not task.done() and task != asyncio.current_task():\r\n+                    task.cancel()\r\n+        except RuntimeError:\r\n+            # イベントループが実行されていない場合は無視\r\n+            pass\r\n     \r\n     def get_statistics(self) -> Dict:\r\n         \"\"\"統計情報を取得\"\"\"\r\n         current_time = time.time()\r\n"
                },
                {
                    "date": 1750499362725,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,17 +88,17 @@\n         if not device_state.is_active:\r\n             return\r\n         \r\n         current_time = time.time()\r\n-          # タップクールダウンチェック\r\n+        \r\n+        # タップクールダウンチェック\r\n         if current_time - device_state.last_action_time < self.tap_cooldown:\r\n             return\r\n         \r\n         try:\r\n             # 優先度順で処理\r\n             action_taken = False\r\n-            \r\n-            # 1. bossが検出されたらタップ\r\n+              # 1. bossが検出されたらタップ\r\n             if detections.get('boss') and not action_taken:\r\n                 x, y = detections['boss']\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n@@ -182,9 +182,10 @@\n             \r\n         except Exception as e:\r\n             device_state.error_count += 1\r\n             self.logger.error(f\"デバイス {device_id} の処理エラー: {e}\")\r\n-              # エラー回数が上限を超えた場合、デバイスを非アクティブにする\r\n+            \r\n+            # エラー回数が上限を超えた場合、デバイスを非アクティブにする\r\n             if device_state.error_count >= self.max_error_count:\r\n                 device_state.is_active = False\r\n                 self.logger.warning(f\"デバイス {device_id} がエラー上限に達したため非アクティブにしました\")\r\n     \r\n@@ -211,20 +212,16 @@\n                 tasks = []\r\n                 for device_id, detections in detection_results.items():\r\n                     if device_id in self.device_states:\r\n                         task = self.process_device_detection(device_id, detections)\r\n-                        tasks.append(task)\r\n-                \r\n+                        tasks.append(task)                \r\n                 # 全デバイスの処理を並行実行\r\n                 if tasks:\r\n                     await asyncio.gather(*tasks, return_exceptions=True)\r\n-                  # 短い待機\r\n+                \r\n+                # 短い待機\r\n                 await asyncio.sleep(self.screen_capture_interval)\r\n                 \r\n-            except asyncio.CancelledError:\r\n-                # キャンセルされた場合は正常終了\r\n-                self.logger.info(\"自動化ループがキャンセルされました\")\r\n-                break\r\n             except Exception as e:\r\n                 self.logger.error(f\"自動化ループエラー: {e}\")\r\n                 await asyncio.sleep(1)  # エラー時は少し長めに待機\r\n     \r\n@@ -248,20 +245,10 @@\n             self.is_running = False\r\n     \r\n     def stop_automation(self):\r\n         \"\"\"自動化を停止\"\"\"\r\n-        self.logger.info(\"自動化停止要求を受信しました\")\r\n         self.is_running = False\r\n-        \r\n-        # 現在実行中のタスクがあればキャンセル\r\n-        try:\r\n-            current_loop = asyncio.get_running_loop()\r\n-            for task in asyncio.all_tasks(current_loop):\r\n-                if not task.done() and task != asyncio.current_task():\r\n-                    task.cancel()\r\n-        except RuntimeError:\r\n-            # イベントループが実行されていない場合は無視\r\n-            pass\r\n+        self.logger.info(\"自動化を停止しました\")\r\n     \r\n     def get_statistics(self) -> Dict:\r\n         \"\"\"統計情報を取得\"\"\"\r\n         current_time = time.time()\r\n"
                },
                {
                    "date": 1750499785187,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,305 @@\n+import asyncio\r\n+import logging\r\n+import time\r\n+from typing import Dict, Optional, Tuple, List\r\n+from enum import Enum\r\n+from dataclasses import dataclass\r\n+from device_controller import MultiDeviceController\r\n+from image_detector import MultiDeviceImageDetector\r\n+\r\n+\r\n+class GameState(Enum):\r\n+    \"\"\"ゲーム状態の列挙\"\"\"\r\n+    IDLE = \"idle\"\r\n+    BOSS_DETECTED = \"boss_detected\"\r\n+    PLAY_DETECTED = \"play_detected\"\r\n+    PUZZLE_DETECTED = \"puzzle_detected\"\r\n+    WAZA_OK_DETECTED = \"waza_ok_detected\"\r\n+    NEXT_DETECTED = \"next_detected\"\r\n+    STAGE_45_DETECTED = \"stage_45_detected\"\r\n+\r\n+\r\n+@dataclass\r\n+class DeviceState:\r\n+    \"\"\"デバイス状態を管理するデータクラス\"\"\"\r\n+    device_id: str\r\n+    current_state: GameState = GameState.IDLE\r\n+    last_action_time: float = 0\r\n+    tap_count: int = 0\r\n+    error_count: int = 0\r\n+    is_active: bool = True\r\n+\r\n+\r\n+class AutomationEngine:\r\n+    \"\"\"妖怪ウォッチぷにぷに自動周回エンジン\"\"\"\r\n+    \r\n+    def __init__(self, template_dir: str = \"image\"):\r\n+        self.device_controller = MultiDeviceController()\r\n+        self.image_detector = MultiDeviceImageDetector(template_dir)\r\n+        self.device_states = {}\r\n+        self.is_running = False\r\n+        self.logger = logging.getLogger(__name__)\r\n+        \r\n+        # 設定\r\n+        self.detection_threshold = 0.8\r\n+        self.tap_cooldown = 0.5  # タップ間隔（秒）\r\n+        self.screen_capture_interval = 0.1  # 画面キャプチャ間隔（秒）\r\n+        self.max_error_count = 5  # 最大エラー回数\r\n+        \r\n+        # 統計情報\r\n+        self.total_loops = 0\r\n+        self.start_time = 0\r\n+        \r\n+    def add_device(self, device_id: str) -> bool:\r\n+        \"\"\"デバイスを追加\"\"\"\r\n+        if self.device_controller.add_device(device_id):\r\n+            self.device_states[device_id] = DeviceState(device_id)\r\n+            self.logger.info(f\"デバイス {device_id} を追加しました\")\r\n+            return True\r\n+        return False\r\n+    \r\n+    def remove_device(self, device_id: str):\r\n+        \"\"\"デバイスを削除\"\"\"\r\n+        self.device_controller.remove_device(device_id)\r\n+        if device_id in self.device_states:\r\n+            del self.device_states[device_id]\r\n+        self.logger.info(f\"デバイス {device_id} を削除しました\")\r\n+    \r\n+    def get_device_list(self) -> List[str]:\r\n+        \"\"\"管理中のデバイス一覧を取得\"\"\"\r\n+        return list(self.device_states.keys())\r\n+    \r\n+    def get_device_state(self, device_id: str) -> Optional[DeviceState]:\r\n+        \"\"\"デバイス状態を取得\"\"\"\r\n+        return self.device_states.get(device_id)\r\n+    \r\n+    def set_device_active(self, device_id: str, active: bool):\r\n+        \"\"\"デバイスのアクティブ状態を設定\"\"\"\r\n+        if device_id in self.device_states:\r\n+            self.device_states[device_id].is_active = active\r\n+    \r\n+    async def process_device_detection(self, device_id: str, \r\n+                                     detections: Dict[str, Optional[Tuple[int, int]]]):\r\n+        \"\"\"デバイスの検出結果を処理\"\"\"\r\n+        if device_id not in self.device_states:\r\n+            return\r\n+        \r\n+        device_state = self.device_states[device_id]\r\n+        if not device_state.is_active:\r\n+            return\r\n+        \r\n+        current_time = time.time()\r\n+        \r\n+        # タップクールダウンチェック\r\n+        if current_time - device_state.last_action_time < self.tap_cooldown:\r\n+            return\r\n+        \r\n+        try:\r\n+            # 優先度順で処理\r\n+            action_taken = False\r\n+            \r\n+            # menu, ranking, yubinが検出されたら何もしない\r\n+            if any([\r\n+                detections.get('menu'),\r\n+                detections.get('ranking'),\r\n+                detections.get('yubin')\r\n+            ]):\r\n+                self.logger.info(f\"デバイス {device_id}: menu/ranking/yubinが検出されたため何もタップしません\")\r\n+                return\r\n+            \r\n+            # 1. bossが検出されたらタップ\r\n+            if detections.get('boss') and not action_taken:\r\n+                x, y = detections['boss']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.BOSS_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"デバイス {device_id}: BOSSをタップしました\")\r\n+            \r\n+            # 2. playが検出されたらタップ\r\n+            if detections.get('play') and not action_taken:\r\n+                x, y = detections['play']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.PLAY_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"デバイス {device_id}: PLAYをタップしました\")\r\n+            \r\n+            # 3. close/close_miniが検出されたらタップ（ただしstage_45が検出されている場合はスキップ）\r\n+            if not action_taken and not detections.get('stage_45'):\r\n+                if detections.get('close'):\r\n+                    x, y = detections['close']\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.IDLE\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"デバイス {device_id}: CLOSEをタップしました\")\r\n+                elif detections.get('close_mini'):\r\n+                    x, y = detections['close_mini']\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.IDLE\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"デバイス {device_id}: CLOSE_MINIをタップしました\")\r\n+            elif detections.get('stage_45'):\r\n+                self.logger.info(f\"デバイス {device_id}: stage_45が検出されたため、close/close_miniをスキップします\")\r\n+            \r\n+            # 4. puzzleが検出されたらタップ\r\n+            if detections.get('puzzle') and not action_taken:\r\n+                x, y = detections['puzzle']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.PUZZLE_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"デバイス {device_id}: PUZZLEをタップしました\")\r\n+            \r\n+            # 5. waza_okが検出されたらタップ\r\n+            if detections.get('waza_ok') and not action_taken:\r\n+                x, y = detections['waza_ok']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.WAZA_OK_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"デバイス {device_id}: WAZA_OKをタップしました\")\r\n+            \r\n+            # 6. nextが検出されたらタップ\r\n+            if detections.get('next') and not action_taken:\r\n+                x, y = detections['next']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.NEXT_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.total_loops += 1  # ループ完了のカウント\r\n+                    self.logger.info(f\"デバイス {device_id}: NEXTをタップしました（ループ完了: {self.total_loops}）\")\r\n+            \r\n+            # エラーカウントリセット\r\n+            if action_taken:\r\n+                device_state.error_count = 0\r\n+            \r\n+        except Exception as e:\r\n+            device_state.error_count += 1\r\n+            self.logger.error(f\"デバイス {device_id} の処理エラー: {e}\")\r\n+            \r\n+            # エラー回数が上限を超えた場合、デバイスを非アクティブにする\r\n+            if device_state.error_count >= self.max_error_count:\r\n+                device_state.is_active = False\r\n+                self.logger.warning(f\"デバイス {device_id} がエラー上限に達したため非アクティブにしました\")\r\n+    \r\n+    async def automation_loop(self):\r\n+        \"\"\"メイン自動化ループ\"\"\"\r\n+        self.logger.info(\"自動化ループを開始します\")\r\n+        self.start_time = time.time()\r\n+        \r\n+        while self.is_running:\r\n+            try:\r\n+                # 全デバイスの画面キャプチャ\r\n+                screen_data = await self.device_controller.capture_all_screens()\r\n+                \r\n+                if not screen_data:\r\n+                    await asyncio.sleep(self.screen_capture_interval)\r\n+                    continue\r\n+                \r\n+                # 全デバイスで画像検出\r\n+                detection_results = await self.image_detector.detect_all_devices(\r\n+                    screen_data, self.detection_threshold\r\n+                )\r\n+                \r\n+                # 各デバイスの検出結果を処理\r\n+                tasks = []\r\n+                for device_id, detections in detection_results.items():\r\n+                    if device_id in self.device_states:\r\n+                        task = self.process_device_detection(device_id, detections)\r\n+                        tasks.append(task)                \r\n+                # 全デバイスの処理を並行実行\r\n+                if tasks:\r\n+                    await asyncio.gather(*tasks, return_exceptions=True)\r\n+                \r\n+                # 短い待機\r\n+                await asyncio.sleep(self.screen_capture_interval)\r\n+                \r\n+            except Exception as e:\r\n+                self.logger.error(f\"自動化ループエラー: {e}\")\r\n+                await asyncio.sleep(1)  # エラー時は少し長めに待機\r\n+    \r\n+    async def start_automation(self):\r\n+        \"\"\"自動化を開始\"\"\"\r\n+        if self.is_running:\r\n+            self.logger.warning(\"自動化は既に実行中です\")\r\n+            return\r\n+        \r\n+        if not self.device_states:\r\n+            self.logger.error(\"デバイスが登録されていません\")\r\n+            return\r\n+        \r\n+        self.is_running = True\r\n+        self.total_loops = 0\r\n+        try:\r\n+            await self.automation_loop()\r\n+        except Exception as e:\r\n+            self.logger.error(f\"自動化実行エラー: {e}\")\r\n+        finally:\r\n+            self.is_running = False\r\n+    \r\n+    def stop_automation(self):\r\n+        \"\"\"自動化を停止\"\"\"\r\n+        self.is_running = False\r\n+        self.logger.info(\"自動化を停止しました\")\r\n+    \r\n+    def get_statistics(self) -> Dict:\r\n+        \"\"\"統計情報を取得\"\"\"\r\n+        current_time = time.time()\r\n+        elapsed_time = current_time - self.start_time if self.start_time > 0 else 0\r\n+        \r\n+        stats = {\r\n+            'total_loops': self.total_loops,\r\n+            'elapsed_time': elapsed_time,\r\n+            'loops_per_hour': (self.total_loops / elapsed_time * 3600) if elapsed_time > 0 else 0,\r\n+            'active_devices': len([d for d in self.device_states.values() if d.is_active]),\r\n+            'total_devices': len(self.device_states),\r\n+            'device_details': {}\r\n+        }\r\n+        \r\n+        for device_id, state in self.device_states.items():\r\n+            stats['device_details'][device_id] = {\r\n+                'state': state.current_state.value,\r\n+                'tap_count': state.tap_count,\r\n+                'error_count': state.error_count,\r\n+                'is_active': state.is_active,\r\n+                'last_action_time': state.last_action_time\r\n+            }\r\n+        \r\n+        return stats\r\n+    \r\n+    def reset_statistics(self):\r\n+        \"\"\"統計情報をリセット\"\"\"\r\n+        self.total_loops = 0\r\n+        self.start_time = time.time()\r\n+        for state in self.device_states.values():\r\n+            state.tap_count = 0\r\n+            state.error_count = 0\r\n+    \r\n+    def set_detection_threshold(self, threshold: float):\r\n+        \"\"\"検出閾値を設定\"\"\"\r\n+        self.detection_threshold = max(0.1, min(1.0, threshold))\r\n+    \r\n+    def set_tap_cooldown(self, cooldown: float):\r\n+        \"\"\"タップクールダウンを設定\"\"\"\r\n+        self.tap_cooldown = max(0.1, cooldown)\r\n+    \r\n+    def set_capture_interval(self, interval: float):\r\n+        \"\"\"画面キャプチャ間隔を設定\"\"\"\r\n+        self.screen_capture_interval = max(0.05, interval)\r\n"
                },
                {
                    "date": 1750503530469,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,14 @@\n import asyncio\r\n import logging\r\n import time\r\n+import random\r\n from typing import Dict, Optional, Tuple, List\r\n from enum import Enum\r\n from dataclasses import dataclass\r\n from device_controller import MultiDeviceController\r\n from image_detector import MultiDeviceImageDetector\r\n+from config_manager import ConfigManager\r\n \r\n \r\n class GameState(Enum):\r\n     \"\"\"ゲーム状態の列挙\"\"\"\r\n@@ -49,8 +51,12 @@\n         # 統計情報\r\n         self.total_loops = 0\r\n         self.start_time = 0\r\n         \r\n+        # 画像タップランダム幅設定\r\n+        self.config_manager = ConfigManager()\r\n+        self.image_random_ranges = self.config_manager.get_image_random_ranges()\r\n+        \r\n     def add_device(self, device_id: str) -> bool:\r\n         \"\"\"デバイスを追加\"\"\"\r\n         if self.device_controller.add_device(device_id):\r\n             self.device_states[device_id] = DeviceState(device_id)\r\n@@ -77,8 +83,12 @@\n         \"\"\"デバイスのアクティブ状態を設定\"\"\"\r\n         if device_id in self.device_states:\r\n             self.device_states[device_id].is_active = active\r\n     \r\n+    def reload_image_random_ranges(self):\r\n+        \"\"\"画像タップランダム幅設定をリロード\"\"\"\r\n+        self.image_random_ranges = self.config_manager.get_image_random_ranges()\r\n+\r\n     async def process_device_detection(self, device_id: str, \r\n                                      detections: Dict[str, Optional[Tuple[int, int]]]):\r\n         \"\"\"デバイスの検出結果を処理\"\"\"\r\n         if device_id not in self.device_states:\r\n@@ -109,326 +119,41 @@\n             \r\n             # 1. bossが検出されたらタップ\r\n             if detections.get('boss') and not action_taken:\r\n                 x, y = detections['boss']\r\n+                rx = self.image_random_ranges.get('boss.jpg', 0)\r\n+                x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.BOSS_DETECTED\r\n                     device_state.last_action_time = current_time\r\n                     device_state.tap_count += 1\r\n                     action_taken = True\r\n                     self.logger.info(f\"デバイス {device_id}: BOSSをタップしました\")\r\n             \r\n-            # 2. playが検出されたらタップ\r\n-            if detections.get('play') and not action_taken:\r\n-                x, y = detections['play']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.PLAY_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"デバイス {device_id}: PLAYをタップしました\")\r\n-            \r\n-            # 3. close/close_miniが検出されたらタップ（ただしstage_45が検出されている場合はスキップ）\r\n-            if not action_taken and not detections.get('stage_45'):\r\n-                if detections.get('close'):\r\n-                    x, y = detections['close']\r\n+            # 2. play, play_2が検出されたらタップ\r\n+            for play_key, play_file in [('play', 'play.png'), ('play_2', 'play_2.png')]:\r\n+                if detections.get(play_key) and not action_taken:\r\n+                    x, y = detections[play_key]\r\n+                    rx = self.image_random_ranges.get(play_file, 0)\r\n+                    x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                    y += random.randint(-rx, rx) if rx > 0 else 0\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n-                        device_state.current_state = GameState.IDLE\r\n+                        device_state.current_state = GameState.PLAY_DETECTED\r\n                         device_state.last_action_time = current_time\r\n                         device_state.tap_count += 1\r\n                         action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: CLOSEをタップしました\")\r\n-                elif detections.get('close_mini'):\r\n-                    x, y = detections['close_mini']\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.IDLE\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: CLOSE_MINIをタップしました\")\r\n-            elif detections.get('stage_45'):\r\n-                self.logger.info(f\"デバイス {device_id}: stage_45が検出されたため、close/close_miniをスキップします\")\r\n+                        self.logger.info(f\"デバイス {device_id}: {play_key.upper()}をタップしました\")\r\n             \r\n-            # 4. puzzleが検出されたらタップ\r\n-            if detections.get('puzzle') and not action_taken:\r\n-                x, y = detections['puzzle']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.PUZZLE_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"デバイス {device_id}: PUZZLEをタップしました\")\r\n-            \r\n-            # 5. waza_okが検出されたらタップ\r\n-            if detections.get('waza_ok') and not action_taken:\r\n-                x, y = detections['waza_ok']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.WAZA_OK_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"デバイス {device_id}: WAZA_OKをタップしました\")\r\n-            \r\n-            # 6. nextが検出されたらタップ\r\n-            if detections.get('next') and not action_taken:\r\n-                x, y = detections['next']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.NEXT_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.total_loops += 1  # ループ完了のカウント\r\n-                    self.logger.info(f\"デバイス {device_id}: NEXTをタップしました（ループ完了: {self.total_loops}）\")\r\n-            \r\n-            # エラーカウントリセット\r\n-            if action_taken:\r\n-                device_state.error_count = 0\r\n-            \r\n-        except Exception as e:\r\n-            device_state.error_count += 1\r\n-            self.logger.error(f\"デバイス {device_id} の処理エラー: {e}\")\r\n-            \r\n-            # エラー回数が上限を超えた場合、デバイスを非アクティブにする\r\n-            if device_state.error_count >= self.max_error_count:\r\n-                device_state.is_active = False\r\n-                self.logger.warning(f\"デバイス {device_id} がエラー上限に達したため非アクティブにしました\")\r\n-    \r\n-    async def automation_loop(self):\r\n-        \"\"\"メイン自動化ループ\"\"\"\r\n-        self.logger.info(\"自動化ループを開始します\")\r\n-        self.start_time = time.time()\r\n-        \r\n-        while self.is_running:\r\n-            try:\r\n-                # 全デバイスの画面キャプチャ\r\n-                screen_data = await self.device_controller.capture_all_screens()\r\n-                \r\n-                if not screen_data:\r\n-                    await asyncio.sleep(self.screen_capture_interval)\r\n-                    continue\r\n-                \r\n-                # 全デバイスで画像検出\r\n-                detection_results = await self.image_detector.detect_all_devices(\r\n-                    screen_data, self.detection_threshold\r\n-                )\r\n-                \r\n-                # 各デバイスの検出結果を処理\r\n-                tasks = []\r\n-                for device_id, detections in detection_results.items():\r\n-                    if device_id in self.device_states:\r\n-                        task = self.process_device_detection(device_id, detections)\r\n-                        tasks.append(task)                \r\n-                # 全デバイスの処理を並行実行\r\n-                if tasks:\r\n-                    await asyncio.gather(*tasks, return_exceptions=True)\r\n-                \r\n-                # 短い待機\r\n-                await asyncio.sleep(self.screen_capture_interval)\r\n-                \r\n-            except Exception as e:\r\n-                self.logger.error(f\"自動化ループエラー: {e}\")\r\n-                await asyncio.sleep(1)  # エラー時は少し長めに待機\r\n-    \r\n-    async def start_automation(self):\r\n-        \"\"\"自動化を開始\"\"\"\r\n-        if self.is_running:\r\n-            self.logger.warning(\"自動化は既に実行中です\")\r\n-            return\r\n-        \r\n-        if not self.device_states:\r\n-            self.logger.error(\"デバイスが登録されていません\")\r\n-            return\r\n-        \r\n-        self.is_running = True\r\n-        self.total_loops = 0\r\n-        try:\r\n-            await self.automation_loop()\r\n-        except Exception as e:\r\n-            self.logger.error(f\"自動化実行エラー: {e}\")\r\n-        finally:\r\n-            self.is_running = False\r\n-    \r\n-    def stop_automation(self):\r\n-        \"\"\"自動化を停止\"\"\"\r\n-        self.is_running = False\r\n-        self.logger.info(\"自動化を停止しました\")\r\n-    \r\n-    def get_statistics(self) -> Dict:\r\n-        \"\"\"統計情報を取得\"\"\"\r\n-        current_time = time.time()\r\n-        elapsed_time = current_time - self.start_time if self.start_time > 0 else 0\r\n-        \r\n-        stats = {\r\n-            'total_loops': self.total_loops,\r\n-            'elapsed_time': elapsed_time,\r\n-            'loops_per_hour': (self.total_loops / elapsed_time * 3600) if elapsed_time > 0 else 0,\r\n-            'active_devices': len([d for d in self.device_states.values() if d.is_active]),\r\n-            'total_devices': len(self.device_states),\r\n-            'device_details': {}\r\n-        }\r\n-        \r\n-        for device_id, state in self.device_states.items():\r\n-            stats['device_details'][device_id] = {\r\n-                'state': state.current_state.value,\r\n-                'tap_count': state.tap_count,\r\n-                'error_count': state.error_count,\r\n-                'is_active': state.is_active,\r\n-                'last_action_time': state.last_action_time\r\n-            }\r\n-        \r\n-        return stats\r\n-    \r\n-    def reset_statistics(self):\r\n-        \"\"\"統計情報をリセット\"\"\"\r\n-        self.total_loops = 0\r\n-        self.start_time = time.time()\r\n-        for state in self.device_states.values():\r\n-            state.tap_count = 0\r\n-            state.error_count = 0\r\n-    \r\n-    def set_detection_threshold(self, threshold: float):\r\n-        \"\"\"検出閾値を設定\"\"\"\r\n-        self.detection_threshold = max(0.1, min(1.0, threshold))\r\n-    \r\n-    def set_tap_cooldown(self, cooldown: float):\r\n-        \"\"\"タップクールダウンを設定\"\"\"\r\n-        self.tap_cooldown = max(0.1, cooldown)\r\n-    \r\n-    def set_capture_interval(self, interval: float):\r\n-        \"\"\"画面キャプチャ間隔を設定\"\"\"\r\n-        self.screen_capture_interval = max(0.05, interval)\r\n-import asyncio\r\n-import logging\r\n-import time\r\n-from typing import Dict, Optional, Tuple, List\r\n-from enum import Enum\r\n-from dataclasses import dataclass\r\n-from device_controller import MultiDeviceController\r\n-from image_detector import MultiDeviceImageDetector\r\n-\r\n-\r\n-class GameState(Enum):\r\n-    \"\"\"ゲーム状態の列挙\"\"\"\r\n-    IDLE = \"idle\"\r\n-    BOSS_DETECTED = \"boss_detected\"\r\n-    PLAY_DETECTED = \"play_detected\"\r\n-    PUZZLE_DETECTED = \"puzzle_detected\"\r\n-    WAZA_OK_DETECTED = \"waza_ok_detected\"\r\n-    NEXT_DETECTED = \"next_detected\"\r\n-    STAGE_45_DETECTED = \"stage_45_detected\"\r\n-\r\n-\r\n-@dataclass\r\n-class DeviceState:\r\n-    \"\"\"デバイス状態を管理するデータクラス\"\"\"\r\n-    device_id: str\r\n-    current_state: GameState = GameState.IDLE\r\n-    last_action_time: float = 0\r\n-    tap_count: int = 0\r\n-    error_count: int = 0\r\n-    is_active: bool = True\r\n-\r\n-\r\n-class AutomationEngine:\r\n-    \"\"\"妖怪ウォッチぷにぷに自動周回エンジン\"\"\"\r\n-    \r\n-    def __init__(self, template_dir: str = \"image\"):\r\n-        self.device_controller = MultiDeviceController()\r\n-        self.image_detector = MultiDeviceImageDetector(template_dir)\r\n-        self.device_states = {}\r\n-        self.is_running = False\r\n-        self.logger = logging.getLogger(__name__)\r\n-        \r\n-        # 設定\r\n-        self.detection_threshold = 0.8\r\n-        self.tap_cooldown = 0.5  # タップ間隔（秒）\r\n-        self.screen_capture_interval = 0.1  # 画面キャプチャ間隔（秒）\r\n-        self.max_error_count = 5  # 最大エラー回数\r\n-        \r\n-        # 統計情報\r\n-        self.total_loops = 0\r\n-        self.start_time = 0\r\n-        \r\n-    def add_device(self, device_id: str) -> bool:\r\n-        \"\"\"デバイスを追加\"\"\"\r\n-        if self.device_controller.add_device(device_id):\r\n-            self.device_states[device_id] = DeviceState(device_id)\r\n-            self.logger.info(f\"デバイス {device_id} を追加しました\")\r\n-            return True\r\n-        return False\r\n-    \r\n-    def remove_device(self, device_id: str):\r\n-        \"\"\"デバイスを削除\"\"\"\r\n-        self.device_controller.remove_device(device_id)\r\n-        if device_id in self.device_states:\r\n-            del self.device_states[device_id]\r\n-        self.logger.info(f\"デバイス {device_id} を削除しました\")\r\n-    \r\n-    def get_device_list(self) -> List[str]:\r\n-        \"\"\"管理中のデバイス一覧を取得\"\"\"\r\n-        return list(self.device_states.keys())\r\n-    \r\n-    def get_device_state(self, device_id: str) -> Optional[DeviceState]:\r\n-        \"\"\"デバイス状態を取得\"\"\"\r\n-        return self.device_states.get(device_id)\r\n-    \r\n-    def set_device_active(self, device_id: str, active: bool):\r\n-        \"\"\"デバイスのアクティブ状態を設定\"\"\"\r\n-        if device_id in self.device_states:\r\n-            self.device_states[device_id].is_active = active\r\n-    \r\n-    async def process_device_detection(self, device_id: str, \r\n-                                     detections: Dict[str, Optional[Tuple[int, int]]]):\r\n-        \"\"\"デバイスの検出結果を処理\"\"\"\r\n-        if device_id not in self.device_states:\r\n-            return\r\n-        \r\n-        device_state = self.device_states[device_id]\r\n-        if not device_state.is_active:\r\n-            return\r\n-        \r\n-        current_time = time.time()\r\n-        \r\n-        # タップクールダウンチェック\r\n-        if current_time - device_state.last_action_time < self.tap_cooldown:\r\n-            return\r\n-        \r\n-        try:\r\n-            # 優先度順で処理\r\n-            action_taken = False\r\n-              # 1. bossが検出されたらタップ\r\n-            if detections.get('boss') and not action_taken:\r\n-                x, y = detections['boss']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.BOSS_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"デバイス {device_id}: BOSSをタップしました\")\r\n-            \r\n-            # 2. playが検出されたらタップ\r\n-            if detections.get('play') and not action_taken:\r\n-                x, y = detections['play']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.PLAY_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"デバイス {device_id}: PLAYをタップしました\")\r\n-            \r\n             # 3. close/close_miniが検出されたらタップ（ただしstage_45が検出されている場合はスキップ）\r\n             if not action_taken and not detections.get('stage_45'):\r\n                 if detections.get('close'):\r\n                     x, y = detections['close']\r\n+                    rx = self.image_random_ranges.get('close.png', 0)\r\n+                    x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                    y += random.randint(-rx, rx) if rx > 0 else 0\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n                         device_state.current_state = GameState.IDLE\r\n                         device_state.last_action_time = current_time\r\n@@ -436,8 +161,11 @@\n                         action_taken = True\r\n                         self.logger.info(f\"デバイス {device_id}: CLOSEをタップしました\")\r\n                 elif detections.get('close_mini'):\r\n                     x, y = detections['close_mini']\r\n+                    rx = self.image_random_ranges.get('close_mini.png', 0)\r\n+                    x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                    y += random.randint(-rx, rx) if rx > 0 else 0\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n                         device_state.current_state = GameState.IDLE\r\n                         device_state.last_action_time = current_time\r\n@@ -449,8 +177,11 @@\n             \r\n             # 4. puzzleが検出されたらタップ\r\n             if detections.get('puzzle') and not action_taken:\r\n                 x, y = detections['puzzle']\r\n+                rx = self.image_random_ranges.get('puzzle.png', 0)\r\n+                x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.PUZZLE_DETECTED\r\n                     device_state.last_action_time = current_time\r\n@@ -460,8 +191,11 @@\n             \r\n             # 5. waza_okが検出されたらタップ\r\n             if detections.get('waza_ok') and not action_taken:\r\n                 x, y = detections['waza_ok']\r\n+                rx = self.image_random_ranges.get('waza_ok.png', 0)\r\n+                x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.WAZA_OK_DETECTED\r\n                     device_state.last_action_time = current_time\r\n@@ -471,8 +205,11 @@\n             \r\n             # 6. nextが検出されたらタップ\r\n             if detections.get('next') and not action_taken:\r\n                 x, y = detections['next']\r\n+                rx = self.image_random_ranges.get('next.png', 0)\r\n+                x += random.randint(-rx, rx) if rx > 0 else 0\r\n+                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.NEXT_DETECTED\r\n                     device_state.last_action_time = current_time\r\n"
                },
                {
                    "date": 1750503616001,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,12 @@\n import asyncio\r\n import logging\r\n import time\r\n-import random\r\n from typing import Dict, Optional, Tuple, List\r\n from enum import Enum\r\n from dataclasses import dataclass\r\n from device_controller import MultiDeviceController\r\n from image_detector import MultiDeviceImageDetector\r\n-from config_manager import ConfigManager\r\n \r\n \r\n class GameState(Enum):\r\n     \"\"\"ゲーム状態の列挙\"\"\"\r\n@@ -51,12 +49,8 @@\n         # 統計情報\r\n         self.total_loops = 0\r\n         self.start_time = 0\r\n         \r\n-        # 画像タップランダム幅設定\r\n-        self.config_manager = ConfigManager()\r\n-        self.image_random_ranges = self.config_manager.get_image_random_ranges()\r\n-        \r\n     def add_device(self, device_id: str) -> bool:\r\n         \"\"\"デバイスを追加\"\"\"\r\n         if self.device_controller.add_device(device_id):\r\n             self.device_states[device_id] = DeviceState(device_id)\r\n@@ -83,12 +77,8 @@\n         \"\"\"デバイスのアクティブ状態を設定\"\"\"\r\n         if device_id in self.device_states:\r\n             self.device_states[device_id].is_active = active\r\n     \r\n-    def reload_image_random_ranges(self):\r\n-        \"\"\"画像タップランダム幅設定をリロード\"\"\"\r\n-        self.image_random_ranges = self.config_manager.get_image_random_ranges()\r\n-\r\n     async def process_device_detection(self, device_id: str, \r\n                                      detections: Dict[str, Optional[Tuple[int, int]]]):\r\n         \"\"\"デバイスの検出結果を処理\"\"\"\r\n         if device_id not in self.device_states:\r\n@@ -119,11 +109,8 @@\n             \r\n             # 1. bossが検出されたらタップ\r\n             if detections.get('boss') and not action_taken:\r\n                 x, y = detections['boss']\r\n-                rx = self.image_random_ranges.get('boss.jpg', 0)\r\n-                x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.BOSS_DETECTED\r\n                     device_state.last_action_time = current_time\r\n@@ -131,14 +118,11 @@\n                     action_taken = True\r\n                     self.logger.info(f\"デバイス {device_id}: BOSSをタップしました\")\r\n             \r\n             # 2. play, play_2が検出されたらタップ\r\n-            for play_key, play_file in [('play', 'play.png'), ('play_2', 'play_2.png')]:\r\n+            for play_key in ('play', 'play_2'):\r\n                 if detections.get(play_key) and not action_taken:\r\n                     x, y = detections[play_key]\r\n-                    rx = self.image_random_ranges.get(play_file, 0)\r\n-                    x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                    y += random.randint(-rx, rx) if rx > 0 else 0\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n                         device_state.current_state = GameState.PLAY_DETECTED\r\n                         device_state.last_action_time = current_time\r\n@@ -149,11 +133,8 @@\n             # 3. close/close_miniが検出されたらタップ（ただしstage_45が検出されている場合はスキップ）\r\n             if not action_taken and not detections.get('stage_45'):\r\n                 if detections.get('close'):\r\n                     x, y = detections['close']\r\n-                    rx = self.image_random_ranges.get('close.png', 0)\r\n-                    x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                    y += random.randint(-rx, rx) if rx > 0 else 0\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n                         device_state.current_state = GameState.IDLE\r\n                         device_state.last_action_time = current_time\r\n@@ -161,11 +142,8 @@\n                         action_taken = True\r\n                         self.logger.info(f\"デバイス {device_id}: CLOSEをタップしました\")\r\n                 elif detections.get('close_mini'):\r\n                     x, y = detections['close_mini']\r\n-                    rx = self.image_random_ranges.get('close_mini.png', 0)\r\n-                    x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                    y += random.randint(-rx, rx) if rx > 0 else 0\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n                         device_state.current_state = GameState.IDLE\r\n                         device_state.last_action_time = current_time\r\n@@ -177,11 +155,8 @@\n             \r\n             # 4. puzzleが検出されたらタップ\r\n             if detections.get('puzzle') and not action_taken:\r\n                 x, y = detections['puzzle']\r\n-                rx = self.image_random_ranges.get('puzzle.png', 0)\r\n-                x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.PUZZLE_DETECTED\r\n                     device_state.last_action_time = current_time\r\n@@ -191,11 +166,8 @@\n             \r\n             # 5. waza_okが検出されたらタップ\r\n             if detections.get('waza_ok') and not action_taken:\r\n                 x, y = detections['waza_ok']\r\n-                rx = self.image_random_ranges.get('waza_ok.png', 0)\r\n-                x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.WAZA_OK_DETECTED\r\n                     device_state.last_action_time = current_time\r\n@@ -205,11 +177,8 @@\n             \r\n             # 6. nextが検出されたらタップ\r\n             if detections.get('next') and not action_taken:\r\n                 x, y = detections['next']\r\n-                rx = self.image_random_ranges.get('next.png', 0)\r\n-                x += random.randint(-rx, rx) if rx > 0 else 0\r\n-                y += random.randint(-rx, rx) if rx > 0 else 0\r\n                 success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                 if success:\r\n                     device_state.current_state = GameState.NEXT_DETECTED\r\n                     device_state.last_action_time = current_time\r\n"
                },
                {
                    "date": 1750512636088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,8 +27,9 @@\n     last_action_time: float = 0\r\n     tap_count: int = 0\r\n     error_count: int = 0\r\n     is_active: bool = True\r\n+    hp_bar_tapped: bool = False  # hp_barタップ済みフラグを追加\r\n \r\n \r\n class AutomationEngine:\r\n     \"\"\"妖怪ウォッチぷにぷに自動周回エンジン\"\"\"\r\n@@ -186,8 +187,22 @@\n                     action_taken = True\r\n                     self.total_loops += 1  # ループ完了のカウント\r\n                     self.logger.info(f\"デバイス {device_id}: NEXTをタップしました（ループ完了: {self.total_loops}）\")\r\n             \r\n+            # hp_barが検出された場合、1回だけy+200をタップ\r\n+            if detections.get('hp_bar') and not device_state.hp_bar_tapped and not action_taken:\r\n+                x, y = detections['hp_bar']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y + 200)\r\n+                if success:\r\n+                    device_state.hp_bar_tapped = True\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"デバイス {device_id}: HP_BARをy+200でタップしました\")\r\n+            # hp_barが検出されていない場合はフラグをリセット\r\n+            if not detections.get('hp_bar'):\r\n+                device_state.hp_bar_tapped = False\r\n+            \r\n             # エラーカウントリセット\r\n             if action_taken:\r\n                 device_state.error_count = 0\r\n             \r\n"
                },
                {
                    "date": 1750512866272,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,8 @@\n     last_action_time: float = 0\r\n     tap_count: int = 0\r\n     error_count: int = 0\r\n     is_active: bool = True\r\n-    hp_bar_tapped: bool = False  # hp_barタップ済みフラグを追加\r\n \r\n \r\n class AutomationEngine:\r\n     \"\"\"妖怪ウォッチぷにぷに自動周回エンジン\"\"\"\r\n@@ -187,22 +186,8 @@\n                     action_taken = True\r\n                     self.total_loops += 1  # ループ完了のカウント\r\n                     self.logger.info(f\"デバイス {device_id}: NEXTをタップしました（ループ完了: {self.total_loops}）\")\r\n             \r\n-            # hp_barが検出された場合、1回だけy+200をタップ\r\n-            if detections.get('hp_bar') and not device_state.hp_bar_tapped and not action_taken:\r\n-                x, y = detections['hp_bar']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y + 200)\r\n-                if success:\r\n-                    device_state.hp_bar_tapped = True\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"デバイス {device_id}: HP_BARをy+200でタップしました\")\r\n-            # hp_barが検出されていない場合はフラグをリセット\r\n-            if not detections.get('hp_bar'):\r\n-                device_state.hp_bar_tapped = False\r\n-            \r\n             # エラーカウントリセット\r\n             if action_taken:\r\n                 device_state.error_count = 0\r\n             \r\n"
                },
                {
                    "date": 1750513034024,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,8 +27,9 @@\n     last_action_time: float = 0\r\n     tap_count: int = 0\r\n     error_count: int = 0\r\n     is_active: bool = True\r\n+    hp_bar_tap_time: float = 0  # hp_barタップ時刻\r\n \r\n \r\n class AutomationEngine:\r\n     \"\"\"妖怪ウォッチぷにぷに自動周回エンジン\"\"\"\r\n@@ -96,8 +97,22 @@\n         \r\n         try:\r\n             # 優先度順で処理\r\n             action_taken = False\r\n+\r\n+            # --- hp_bar検知時の特殊タップ ---\r\n+            if detections.get('hp_bar') and not action_taken:\r\n+                x, y = detections['hp_bar']\r\n+                # 直近1秒以内にタップしていなければ1回だけタップ\r\n+                if current_time - device_state.hp_bar_tap_time > 1.0:\r\n+                    tap_x, tap_y = x, y + 200\r\n+                    success = await self.device_controller.devices[device_id].tap_async(tap_x, tap_y)\r\n+                    if success:\r\n+                        device_state.hp_bar_tap_time = current_time\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"デバイス {device_id}: hp_barを検知し中央y+200をタップしました\")\r\n             \r\n             # menu, ranking, yubinが検出されたら何もしない\r\n             if any([\r\n                 detections.get('menu'),\r\n"
                },
                {
                    "date": 1750513169157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -132,10 +132,10 @@\n                     device_state.tap_count += 1\r\n                     action_taken = True\r\n                     self.logger.info(f\"デバイス {device_id}: BOSSをタップしました\")\r\n             \r\n-            # 2. play, play_2が検出されたらタップ\r\n-            for play_key in ('play', 'play_2'):\r\n+            # --- play, play_1, play_2が検出されたらタップ ---\r\n+            for play_key in ('play', 'play_1', 'play_2'):\r\n                 if detections.get(play_key) and not action_taken:\r\n                     x, y = detections[play_key]\r\n                     success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n                     if success:\r\n"
                },
                {
                    "date": 1750513273040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -99,9 +99,13 @@\n             # 優先度順で処理\r\n             action_taken = False\r\n \r\n             # --- hp_bar検知時の特殊タップ ---\r\n-            if detections.get('hp_bar') and not action_taken:\r\n+            # ただしwaza_ok_1またはwaza_ok_2が検出されていればhp_barはスキップ\r\n+            if (\r\n+                detections.get('hp_bar') and not action_taken and\r\n+                not (detections.get('waza_ok_1') or detections.get('waza_ok_2'))\r\n+            ):\r\n                 x, y = detections['hp_bar']\r\n                 # 直近1秒以内にタップしていなければ1回だけタップ\r\n                 if current_time - device_state.hp_bar_tap_time > 1.0:\r\n                     tap_x, tap_y = x, y + 200\r\n@@ -112,8 +116,20 @@\n                         device_state.tap_count += 1\r\n                         action_taken = True\r\n                         self.logger.info(f\"デバイス {device_id}: hp_barを検知し中央y+200をタップしました\")\r\n             \r\n+            # --- waza_ok_1, waza_ok_2, waza_ok ---\r\n+            for waza_key in ('waza_ok', 'waza_ok_1', 'waza_ok_2'):\r\n+                if detections.get(waza_key) and not action_taken:\r\n+                    x, y = detections[waza_key]\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.WAZA_OK_DETECTED\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"デバイス {device_id}: {waza_key.upper()}をタップしました\")\r\n+            \r\n             # menu, ranking, yubinが検出されたら何もしない\r\n             if any([\r\n                 detections.get('menu'),\r\n                 detections.get('ranking'),\r\n"
                },
                {
                    "date": 1750513288467,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,337 @@\n+import asyncio\r\n+import logging\r\n+import time\r\n+from typing import Dict, Optional, Tuple, List\r\n+from enum import Enum\r\n+from dataclasses import dataclass\r\n+from device_controller import MultiDeviceController\r\n+from image_detector import MultiDeviceImageDetector\r\n+\r\n+\r\n+class GameState(Enum):\r\n+    \"\"\"ゲーム状態の列挙\"\"\"\r\n+    IDLE = \"idle\"\r\n+    BOSS_DETECTED = \"boss_detected\"\r\n+    PLAY_DETECTED = \"play_detected\"\r\n+    PUZZLE_DETECTED = \"puzzle_detected\"\r\n+    WAZA_OK_DETECTED = \"waza_ok_detected\"\r\n+    NEXT_DETECTED = \"next_detected\"\r\n+    STAGE_45_DETECTED = \"stage_45_detected\"\r\n+\r\n+\r\n+@dataclass\r\n+class DeviceState:\r\n+    \"\"\"デバイス状態を管理するデータクラス\"\"\"\r\n+    device_id: str\r\n+    current_state: GameState = GameState.IDLE\r\n+    last_action_time: float = 0\r\n+    tap_count: int = 0\r\n+    error_count: int = 0\r\n+    is_active: bool = True\r\n+    hp_bar_tap_time: float = 0  # hp_barタップ時刻\r\n+\r\n+\r\n+class AutomationEngine:\r\n+    \"\"\"妖怪ウォッチぷにぷに自動周回エンジン\"\"\"\r\n+    \r\n+    def __init__(self, template_dir: str = \"image\"):\r\n+        self.device_controller = MultiDeviceController()\r\n+        self.image_detector = MultiDeviceImageDetector(template_dir)\r\n+        self.device_states = {}\r\n+        self.is_running = False\r\n+        self.logger = logging.getLogger(__name__)\r\n+        \r\n+        # 設定\r\n+        self.detection_threshold = 0.8\r\n+        self.tap_cooldown = 0.5  # タップ間隔（秒）\r\n+        self.screen_capture_interval = 0.1  # 画面キャプチャ間隔（秒）\r\n+        self.max_error_count = 5  # 最大エラー回数\r\n+        \r\n+        # 統計情報\r\n+        self.total_loops = 0\r\n+        self.start_time = 0\r\n+        \r\n+    def add_device(self, device_id: str) -> bool:\r\n+        \"\"\"デバイスを追加\"\"\"\r\n+        if self.device_controller.add_device(device_id):\r\n+            self.device_states[device_id] = DeviceState(device_id)\r\n+            self.logger.info(f\"デバイス {device_id} を追加しました\")\r\n+            return True\r\n+        return False\r\n+    \r\n+    def remove_device(self, device_id: str):\r\n+        \"\"\"デバイスを削除\"\"\"\r\n+        self.device_controller.remove_device(device_id)\r\n+        if device_id in self.device_states:\r\n+            del self.device_states[device_id]\r\n+        self.logger.info(f\"デバイス {device_id} を削除しました\")\r\n+    \r\n+    def get_device_list(self) -> List[str]:\r\n+        \"\"\"管理中のデバイス一覧を取得\"\"\"\r\n+        return list(self.device_states.keys())\r\n+    \r\n+    def get_device_state(self, device_id: str) -> Optional[DeviceState]:\r\n+        \"\"\"デバイス状態を取得\"\"\"\r\n+        return self.device_states.get(device_id)\r\n+    \r\n+    def set_device_active(self, device_id: str, active: bool):\r\n+        \"\"\"デバイスのアクティブ状態を設定\"\"\"\r\n+        if device_id in self.device_states:\r\n+            self.device_states[device_id].is_active = active\r\n+    \r\n+    async def process_device_detection(self, device_id: str, \r\n+                                     detections: Dict[str, Optional[Tuple[int, int]]]):\r\n+        \"\"\"デバイスの検出結果を処理\"\"\"\r\n+        if device_id not in self.device_states:\r\n+            return\r\n+        \r\n+        device_state = self.device_states[device_id]\r\n+        if not device_state.is_active:\r\n+            return\r\n+        \r\n+        current_time = time.time()\r\n+        \r\n+        # タップクールダウンチェック\r\n+        if current_time - device_state.last_action_time < self.tap_cooldown:\r\n+            return\r\n+        \r\n+        try:\r\n+            # 優先度順で処理\r\n+            action_taken = False\r\n+\r\n+            # --- hp_bar検知時の特殊タップ ---\r\n+            # ただしwaza_ok_1またはwaza_ok_2が検出されていればhp_barはスキップ\r\n+            if (\r\n+                detections.get('hp_bar') and not action_taken and\r\n+                not (detections.get('waza_ok_1') or detections.get('waza_ok_2'))\r\n+            ):\r\n+                x, y = detections['hp_bar']\r\n+                # 直近1秒以内にタップしていなければ1回だけタップ\r\n+                if current_time - device_state.hp_bar_tap_time > 1.0:\r\n+                    tap_x, tap_y = x, y + 2700\r\n+                    success = await self.device_controller.devices[device_id].tap_async(tap_x, tap_y)\r\n+                    if success:\r\n+                        device_state.hp_bar_tap_time = current_time\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"デバイス {device_id}: hp_barを検知し中央y+200をタップしました\")\r\n+            \r\n+            # --- waza_ok_1, waza_ok_2, waza_ok ---\r\n+            for waza_key in ('waza_ok', 'waza_ok_1', 'waza_ok_2'):\r\n+                if detections.get(waza_key) and not action_taken:\r\n+                    x, y = detections[waza_key]\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.WAZA_OK_DETECTED\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"デバイス {device_id}: {waza_key.upper()}をタップしました\")\r\n+            \r\n+            # menu, ranking, yubinが検出されたら何もしない\r\n+            if any([\r\n+                detections.get('menu'),\r\n+                detections.get('ranking'),\r\n+                detections.get('yubin')\r\n+            ]):\r\n+                self.logger.info(f\"デバイス {device_id}: menu/ranking/yubinが検出されたため何もタップしません\")\r\n+                return\r\n+            \r\n+            # 1. bossが検出されたらタップ\r\n+            if detections.get('boss') and not action_taken:\r\n+                x, y = detections['boss']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.BOSS_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"デバイス {device_id}: BOSSをタップしました\")\r\n+            \r\n+            # --- play, play_1, play_2が検出されたらタップ ---\r\n+            for play_key in ('play', 'play_1', 'play_2'):\r\n+                if detections.get(play_key) and not action_taken:\r\n+                    x, y = detections[play_key]\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.PLAY_DETECTED\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"デバイス {device_id}: {play_key.upper()}をタップしました\")\r\n+            \r\n+            # 3. close/close_miniが検出されたらタップ（ただしstage_45が検出されている場合はスキップ）\r\n+            if not action_taken and not detections.get('stage_45'):\r\n+                if detections.get('close'):\r\n+                    x, y = detections['close']\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.IDLE\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"デバイス {device_id}: CLOSEをタップしました\")\r\n+                elif detections.get('close_mini'):\r\n+                    x, y = detections['close_mini']\r\n+                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                    if success:\r\n+                        device_state.current_state = GameState.IDLE\r\n+                        device_state.last_action_time = current_time\r\n+                        device_state.tap_count += 1\r\n+                        action_taken = True\r\n+                        self.logger.info(f\"デバイス {device_id}: CLOSE_MINIをタップしました\")\r\n+            elif detections.get('stage_45'):\r\n+                self.logger.info(f\"デバイス {device_id}: stage_45が検出されたため、close/close_miniをスキップします\")\r\n+            \r\n+            # 4. puzzleが検出されたらタップ\r\n+            if detections.get('puzzle') and not action_taken:\r\n+                x, y = detections['puzzle']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.PUZZLE_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"デバイス {device_id}: PUZZLEをタップしました\")\r\n+            \r\n+            # 5. waza_okが検出されたらタップ\r\n+            if detections.get('waza_ok') and not action_taken:\r\n+                x, y = detections['waza_ok']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.WAZA_OK_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.logger.info(f\"デバイス {device_id}: WAZA_OKをタップしました\")\r\n+            \r\n+            # 6. nextが検出されたらタップ\r\n+            if detections.get('next') and not action_taken:\r\n+                x, y = detections['next']\r\n+                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n+                if success:\r\n+                    device_state.current_state = GameState.NEXT_DETECTED\r\n+                    device_state.last_action_time = current_time\r\n+                    device_state.tap_count += 1\r\n+                    action_taken = True\r\n+                    self.total_loops += 1  # ループ完了のカウント\r\n+                    self.logger.info(f\"デバイス {device_id}: NEXTをタップしました（ループ完了: {self.total_loops}）\")\r\n+            \r\n+            # エラーカウントリセット\r\n+            if action_taken:\r\n+                device_state.error_count = 0\r\n+            \r\n+        except Exception as e:\r\n+            device_state.error_count += 1\r\n+            self.logger.error(f\"デバイス {device_id} の処理エラー: {e}\")\r\n+            \r\n+            # エラー回数が上限を超えた場合、デバイスを非アクティブにする\r\n+            if device_state.error_count >= self.max_error_count:\r\n+                device_state.is_active = False\r\n+                self.logger.warning(f\"デバイス {device_id} がエラー上限に達したため非アクティブにしました\")\r\n+    \r\n+    async def automation_loop(self):\r\n+        \"\"\"メイン自動化ループ\"\"\"\r\n+        self.logger.info(\"自動化ループを開始します\")\r\n+        self.start_time = time.time()\r\n+        \r\n+        while self.is_running:\r\n+            try:\r\n+                # 全デバイスの画面キャプチャ\r\n+                screen_data = await self.device_controller.capture_all_screens()\r\n+                \r\n+                if not screen_data:\r\n+                    await asyncio.sleep(self.screen_capture_interval)\r\n+                    continue\r\n+                \r\n+                # 全デバイスで画像検出\r\n+                detection_results = await self.image_detector.detect_all_devices(\r\n+                    screen_data, self.detection_threshold\r\n+                )\r\n+                \r\n+                # 各デバイスの検出結果を処理\r\n+                tasks = []\r\n+                for device_id, detections in detection_results.items():\r\n+                    if device_id in self.device_states:\r\n+                        task = self.process_device_detection(device_id, detections)\r\n+                        tasks.append(task)                \r\n+                # 全デバイスの処理を並行実行\r\n+                if tasks:\r\n+                    await asyncio.gather(*tasks, return_exceptions=True)\r\n+                \r\n+                # 短い待機\r\n+                await asyncio.sleep(self.screen_capture_interval)\r\n+                \r\n+            except Exception as e:\r\n+                self.logger.error(f\"自動化ループエラー: {e}\")\r\n+                await asyncio.sleep(1)  # エラー時は少し長めに待機\r\n+    \r\n+    async def start_automation(self):\r\n+        \"\"\"自動化を開始\"\"\"\r\n+        if self.is_running:\r\n+            self.logger.warning(\"自動化は既に実行中です\")\r\n+            return\r\n+        \r\n+        if not self.device_states:\r\n+            self.logger.error(\"デバイスが登録されていません\")\r\n+            return\r\n+        \r\n+        self.is_running = True\r\n+        self.total_loops = 0\r\n+        try:\r\n+            await self.automation_loop()\r\n+        except Exception as e:\r\n+            self.logger.error(f\"自動化実行エラー: {e}\")\r\n+        finally:\r\n+            self.is_running = False\r\n+    \r\n+    def stop_automation(self):\r\n+        \"\"\"自動化を停止\"\"\"\r\n+        self.is_running = False\r\n+        self.logger.info(\"自動化を停止しました\")\r\n+    \r\n+    def get_statistics(self) -> Dict:\r\n+        \"\"\"統計情報を取得\"\"\"\r\n+        current_time = time.time()\r\n+        elapsed_time = current_time - self.start_time if self.start_time > 0 else 0\r\n+        \r\n+        stats = {\r\n+            'total_loops': self.total_loops,\r\n+            'elapsed_time': elapsed_time,\r\n+            'loops_per_hour': (self.total_loops / elapsed_time * 3600) if elapsed_time > 0 else 0,\r\n+            'active_devices': len([d for d in self.device_states.values() if d.is_active]),\r\n+            'total_devices': len(self.device_states),\r\n+            'device_details': {}\r\n+        }\r\n+        \r\n+        for device_id, state in self.device_states.items():\r\n+            stats['device_details'][device_id] = {\r\n+                'state': state.current_state.value,\r\n+                'tap_count': state.tap_count,\r\n+                'error_count': state.error_count,\r\n+                'is_active': state.is_active,\r\n+                'last_action_time': state.last_action_time\r\n+            }\r\n+        \r\n+        return stats\r\n+    \r\n+    def reset_statistics(self):\r\n+        \"\"\"統計情報をリセット\"\"\"\r\n+        self.total_loops = 0\r\n+        self.start_time = time.time()\r\n+        for state in self.device_states.values():\r\n+            state.tap_count = 0\r\n+            state.error_count = 0\r\n+    \r\n+    def set_detection_threshold(self, threshold: float):\r\n+        \"\"\"検出閾値を設定\"\"\"\r\n+        self.detection_threshold = max(0.1, min(1.0, threshold))\r\n+    \r\n+    def set_tap_cooldown(self, cooldown: float):\r\n+        \"\"\"タップクールダウンを設定\"\"\"\r\n+        self.tap_cooldown = max(0.1, cooldown)\r\n+    \r\n+    def set_capture_interval(self, interval: float):\r\n+        \"\"\"画面キャプチャ間隔を設定\"\"\"\r\n+        self.screen_capture_interval = max(0.05, interval)\r\n"
                },
                {
                    "date": 1750513611653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -98,363 +98,33 @@\n         try:\r\n             # 優先度順で処理\r\n             action_taken = False\r\n \r\n+            # --- hp_barタップ済みフラグ ---\r\n+            if not hasattr(device_state, 'hp_bar_tapped'):\r\n+                device_state.hp_bar_tapped = False\r\n+\r\n             # --- hp_bar検知時の特殊タップ ---\r\n             # ただしwaza_ok_1またはwaza_ok_2が検出されていればhp_barはスキップ\r\n             if (\r\n                 detections.get('hp_bar') and not action_taken and\r\n                 not (detections.get('waza_ok_1') or detections.get('waza_ok_2'))\r\n             ):\r\n-                x, y = detections['hp_bar']\r\n-                # 直近1秒以内にタップしていなければ1回だけタップ\r\n-                if current_time - device_state.hp_bar_tap_time > 1.0:\r\n-                    tap_x, tap_y = x, y + 2700\r\n+                if not device_state.hp_bar_tapped:\r\n+                    x, y = detections['hp_bar']\r\n+                    tap_x, tap_y = x, y + 500\r\n                     success = await self.device_controller.devices[device_id].tap_async(tap_x, tap_y)\r\n                     if success:\r\n                         device_state.hp_bar_tap_time = current_time\r\n                         device_state.last_action_time = current_time\r\n                         device_state.tap_count += 1\r\n+                        device_state.hp_bar_tapped = True\r\n                         action_taken = True\r\n                         self.logger.info(f\"デバイス {device_id}: hp_barを検知し中央y+200をタップしました\")\r\n-            \r\n-            # --- waza_ok_1, waza_ok_2, waza_ok ---\r\n-            for waza_key in ('waza_ok', 'waza_ok_1', 'waza_ok_2'):\r\n-                if detections.get(waza_key) and not action_taken:\r\n-                    x, y = detections[waza_key]\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.WAZA_OK_DETECTED\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: {waza_key.upper()}をタップしました\")\r\n-            \r\n-            # menu, ranking, yubinが検出されたら何もしない\r\n-            if any([\r\n-                detections.get('menu'),\r\n-                detections.get('ranking'),\r\n-                detections.get('yubin')\r\n-            ]):\r\n-                self.logger.info(f\"デバイス {device_id}: menu/ranking/yubinが検出されたため何もタップしません\")\r\n-                return\r\n-            \r\n-            # 1. bossが検出されたらタップ\r\n-            if detections.get('boss') and not action_taken:\r\n-                x, y = detections['boss']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.BOSS_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"デバイス {device_id}: BOSSをタップしました\")\r\n-            \r\n-            # --- play, play_1, play_2が検出されたらタップ ---\r\n-            for play_key in ('play', 'play_1', 'play_2'):\r\n-                if detections.get(play_key) and not action_taken:\r\n-                    x, y = detections[play_key]\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.PLAY_DETECTED\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: {play_key.upper()}をタップしました\")\r\n-            \r\n-            # 3. close/close_miniが検出されたらタップ（ただしstage_45が検出されている場合はスキップ）\r\n-            if not action_taken and not detections.get('stage_45'):\r\n-                if detections.get('close'):\r\n-                    x, y = detections['close']\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.IDLE\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: CLOSEをタップしました\")\r\n-                elif detections.get('close_mini'):\r\n-                    x, y = detections['close_mini']\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.IDLE\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: CLOSE_MINIをタップしました\")\r\n-            elif detections.get('stage_45'):\r\n-                self.logger.info(f\"デバイス {device_id}: stage_45が検出されたため、close/close_miniをスキップします\")\r\n-            \r\n-            # 4. puzzleが検出されたらタップ\r\n-            if detections.get('puzzle') and not action_taken:\r\n-                x, y = detections['puzzle']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.PUZZLE_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"デバイス {device_id}: PUZZLEをタップしました\")\r\n-            \r\n-            # 5. waza_okが検出されたらタップ\r\n-            if detections.get('waza_ok') and not action_taken:\r\n-                x, y = detections['waza_ok']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.WAZA_OK_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"デバイス {device_id}: WAZA_OKをタップしました\")\r\n-            \r\n-            # 6. nextが検出されたらタップ\r\n-            if detections.get('next') and not action_taken:\r\n-                x, y = detections['next']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.NEXT_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.total_loops += 1  # ループ完了のカウント\r\n-                    self.logger.info(f\"デバイス {device_id}: NEXTをタップしました（ループ完了: {self.total_loops}）\")\r\n-            \r\n-            # エラーカウントリセット\r\n-            if action_taken:\r\n-                device_state.error_count = 0\r\n-            \r\n-        except Exception as e:\r\n-            device_state.error_count += 1\r\n-            self.logger.error(f\"デバイス {device_id} の処理エラー: {e}\")\r\n-            \r\n-            # エラー回数が上限を超えた場合、デバイスを非アクティブにする\r\n-            if device_state.error_count >= self.max_error_count:\r\n-                device_state.is_active = False\r\n-                self.logger.warning(f\"デバイス {device_id} がエラー上限に達したため非アクティブにしました\")\r\n-    \r\n-    async def automation_loop(self):\r\n-        \"\"\"メイン自動化ループ\"\"\"\r\n-        self.logger.info(\"自動化ループを開始します\")\r\n-        self.start_time = time.time()\r\n-        \r\n-        while self.is_running:\r\n-            try:\r\n-                # 全デバイスの画面キャプチャ\r\n-                screen_data = await self.device_controller.capture_all_screens()\r\n-                \r\n-                if not screen_data:\r\n-                    await asyncio.sleep(self.screen_capture_interval)\r\n-                    continue\r\n-                \r\n-                # 全デバイスで画像検出\r\n-                detection_results = await self.image_detector.detect_all_devices(\r\n-                    screen_data, self.detection_threshold\r\n-                )\r\n-                \r\n-                # 各デバイスの検出結果を処理\r\n-                tasks = []\r\n-                for device_id, detections in detection_results.items():\r\n-                    if device_id in self.device_states:\r\n-                        task = self.process_device_detection(device_id, detections)\r\n-                        tasks.append(task)                \r\n-                # 全デバイスの処理を並行実行\r\n-                if tasks:\r\n-                    await asyncio.gather(*tasks, return_exceptions=True)\r\n-                \r\n-                # 短い待機\r\n-                await asyncio.sleep(self.screen_capture_interval)\r\n-                \r\n-            except Exception as e:\r\n-                self.logger.error(f\"自動化ループエラー: {e}\")\r\n-                await asyncio.sleep(1)  # エラー時は少し長めに待機\r\n-    \r\n-    async def start_automation(self):\r\n-        \"\"\"自動化を開始\"\"\"\r\n-        if self.is_running:\r\n-            self.logger.warning(\"自動化は既に実行中です\")\r\n-            return\r\n-        \r\n-        if not self.device_states:\r\n-            self.logger.error(\"デバイスが登録されていません\")\r\n-            return\r\n-        \r\n-        self.is_running = True\r\n-        self.total_loops = 0\r\n-        try:\r\n-            await self.automation_loop()\r\n-        except Exception as e:\r\n-            self.logger.error(f\"自動化実行エラー: {e}\")\r\n-        finally:\r\n-            self.is_running = False\r\n-    \r\n-    def stop_automation(self):\r\n-        \"\"\"自動化を停止\"\"\"\r\n-        self.is_running = False\r\n-        self.logger.info(\"自動化を停止しました\")\r\n-    \r\n-    def get_statistics(self) -> Dict:\r\n-        \"\"\"統計情報を取得\"\"\"\r\n-        current_time = time.time()\r\n-        elapsed_time = current_time - self.start_time if self.start_time > 0 else 0\r\n-        \r\n-        stats = {\r\n-            'total_loops': self.total_loops,\r\n-            'elapsed_time': elapsed_time,\r\n-            'loops_per_hour': (self.total_loops / elapsed_time * 3600) if elapsed_time > 0 else 0,\r\n-            'active_devices': len([d for d in self.device_states.values() if d.is_active]),\r\n-            'total_devices': len(self.device_states),\r\n-            'device_details': {}\r\n-        }\r\n-        \r\n-        for device_id, state in self.device_states.items():\r\n-            stats['device_details'][device_id] = {\r\n-                'state': state.current_state.value,\r\n-                'tap_count': state.tap_count,\r\n-                'error_count': state.error_count,\r\n-                'is_active': state.is_active,\r\n-                'last_action_time': state.last_action_time\r\n-            }\r\n-        \r\n-        return stats\r\n-    \r\n-    def reset_statistics(self):\r\n-        \"\"\"統計情報をリセット\"\"\"\r\n-        self.total_loops = 0\r\n-        self.start_time = time.time()\r\n-        for state in self.device_states.values():\r\n-            state.tap_count = 0\r\n-            state.error_count = 0\r\n-    \r\n-    def set_detection_threshold(self, threshold: float):\r\n-        \"\"\"検出閾値を設定\"\"\"\r\n-        self.detection_threshold = max(0.1, min(1.0, threshold))\r\n-    \r\n-    def set_tap_cooldown(self, cooldown: float):\r\n-        \"\"\"タップクールダウンを設定\"\"\"\r\n-        self.tap_cooldown = max(0.1, cooldown)\r\n-    \r\n-    def set_capture_interval(self, interval: float):\r\n-        \"\"\"画面キャプチャ間隔を設定\"\"\"\r\n-        self.screen_capture_interval = max(0.05, interval)\r\n-import asyncio\r\n-import logging\r\n-import time\r\n-from typing import Dict, Optional, Tuple, List\r\n-from enum import Enum\r\n-from dataclasses import dataclass\r\n-from device_controller import MultiDeviceController\r\n-from image_detector import MultiDeviceImageDetector\r\n+            # hp_barが検出されていない場合はフラグ解除\r\n+            if not detections.get('hp_bar'):\r\n+                device_state.hp_bar_tapped = False\r\n \r\n-\r\n-class GameState(Enum):\r\n-    \"\"\"ゲーム状態の列挙\"\"\"\r\n-    IDLE = \"idle\"\r\n-    BOSS_DETECTED = \"boss_detected\"\r\n-    PLAY_DETECTED = \"play_detected\"\r\n-    PUZZLE_DETECTED = \"puzzle_detected\"\r\n-    WAZA_OK_DETECTED = \"waza_ok_detected\"\r\n-    NEXT_DETECTED = \"next_detected\"\r\n-    STAGE_45_DETECTED = \"stage_45_detected\"\r\n-\r\n-\r\n-@dataclass\r\n-class DeviceState:\r\n-    \"\"\"デバイス状態を管理するデータクラス\"\"\"\r\n-    device_id: str\r\n-    current_state: GameState = GameState.IDLE\r\n-    last_action_time: float = 0\r\n-    tap_count: int = 0\r\n-    error_count: int = 0\r\n-    is_active: bool = True\r\n-    hp_bar_tap_time: float = 0  # hp_barタップ時刻\r\n-\r\n-\r\n-class AutomationEngine:\r\n-    \"\"\"妖怪ウォッチぷにぷに自動周回エンジン\"\"\"\r\n-    \r\n-    def __init__(self, template_dir: str = \"image\"):\r\n-        self.device_controller = MultiDeviceController()\r\n-        self.image_detector = MultiDeviceImageDetector(template_dir)\r\n-        self.device_states = {}\r\n-        self.is_running = False\r\n-        self.logger = logging.getLogger(__name__)\r\n-        \r\n-        # 設定\r\n-        self.detection_threshold = 0.8\r\n-        self.tap_cooldown = 0.5  # タップ間隔（秒）\r\n-        self.screen_capture_interval = 0.1  # 画面キャプチャ間隔（秒）\r\n-        self.max_error_count = 5  # 最大エラー回数\r\n-        \r\n-        # 統計情報\r\n-        self.total_loops = 0\r\n-        self.start_time = 0\r\n-        \r\n-    def add_device(self, device_id: str) -> bool:\r\n-        \"\"\"デバイスを追加\"\"\"\r\n-        if self.device_controller.add_device(device_id):\r\n-            self.device_states[device_id] = DeviceState(device_id)\r\n-            self.logger.info(f\"デバイス {device_id} を追加しました\")\r\n-            return True\r\n-        return False\r\n-    \r\n-    def remove_device(self, device_id: str):\r\n-        \"\"\"デバイスを削除\"\"\"\r\n-        self.device_controller.remove_device(device_id)\r\n-        if device_id in self.device_states:\r\n-            del self.device_states[device_id]\r\n-        self.logger.info(f\"デバイス {device_id} を削除しました\")\r\n-    \r\n-    def get_device_list(self) -> List[str]:\r\n-        \"\"\"管理中のデバイス一覧を取得\"\"\"\r\n-        return list(self.device_states.keys())\r\n-    \r\n-    def get_device_state(self, device_id: str) -> Optional[DeviceState]:\r\n-        \"\"\"デバイス状態を取得\"\"\"\r\n-        return self.device_states.get(device_id)\r\n-    \r\n-    def set_device_active(self, device_id: str, active: bool):\r\n-        \"\"\"デバイスのアクティブ状態を設定\"\"\"\r\n-        if device_id in self.device_states:\r\n-            self.device_states[device_id].is_active = active\r\n-    \r\n-    async def process_device_detection(self, device_id: str, \r\n-                                     detections: Dict[str, Optional[Tuple[int, int]]]):\r\n-        \"\"\"デバイスの検出結果を処理\"\"\"\r\n-        if device_id not in self.device_states:\r\n-            return\r\n-        \r\n-        device_state = self.device_states[device_id]\r\n-        if not device_state.is_active:\r\n-            return\r\n-        \r\n-        current_time = time.time()\r\n-        \r\n-        # タップクールダウンチェック\r\n-        if current_time - device_state.last_action_time < self.tap_cooldown:\r\n-            return\r\n-        \r\n-        try:\r\n-            # 優先度順で処理\r\n-            action_taken = False\r\n-\r\n-            # --- hp_bar検知時の特殊タップ ---\r\n-            # ただしwaza_ok_1またはwaza_ok_2が検出されていればhp_barはスキップ\r\n-            if (\r\n-                detections.get('hp_bar') and not action_taken and\r\n-                not (detections.get('waza_ok_1') or detections.get('waza_ok_2'))\r\n-            ):\r\n-                x, y = detections['hp_bar']\r\n-                # 直近1秒以内にタップしていなければ1回だけタップ\r\n-                if current_time - device_state.hp_bar_tap_time > 1.0:\r\n-                    tap_x, tap_y = x, y + 200\r\n-                    success = await self.device_controller.devices[device_id].tap_async(tap_x, tap_y)\r\n-                    if success:\r\n-                        device_state.hp_bar_tap_time = current_time\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: hp_barを検知し中央y+200をタップしました\")\r\n-            \r\n             # --- waza_ok_1, waza_ok_2, waza_ok ---\r\n             for waza_key in ('waza_ok', 'waza_ok_1', 'waza_ok_2'):\r\n                 if detections.get(waza_key) and not action_taken:\r\n                     x, y = detections[waza_key]\r\n"
                },
                {
                    "date": 1750513814346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -336,9 +336,9 @@\n         self.detection_threshold = max(0.1, min(1.0, threshold))\r\n     \r\n     def set_tap_cooldown(self, cooldown: float):\r\n         \"\"\"タップクールダウンを設定\"\"\"\r\n-        self.tap_cooldown = max(0.1, cooldown)\r\n+        self.tap_cooldown = max(0.005, cooldown)\r\n     \r\n     def set_capture_interval(self, interval: float):\r\n         \"\"\"画面キャプチャ間隔を設定\"\"\"\r\n-        self.screen_capture_interval = max(0.05, interval)\r\n+        self.screen_capture_interval = max(0.005, interval)\r\n"
                },
                {
                    "date": 1750517161072,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,344 +1,177 @@\n-import asyncio\r\n-import logging\r\n+import cv2\r\n+import numpy as np\r\n import time\r\n-from typing import Dict, Optional, Tuple, List\r\n-from enum import Enum\r\n-from dataclasses import dataclass\r\n-from device_controller import MultiDeviceController\r\n-from image_detector import MultiDeviceImageDetector\r\n+import threading\r\n+from image_detector import ImageDetector\r\n+from device_controller import DeviceController\r\n \r\n-\r\n-class GameState(Enum):\r\n-    \"\"\"ゲーム状態の列挙\"\"\"\r\n-    IDLE = \"idle\"\r\n-    BOSS_DETECTED = \"boss_detected\"\r\n-    PLAY_DETECTED = \"play_detected\"\r\n-    PUZZLE_DETECTED = \"puzzle_detected\"\r\n-    WAZA_OK_DETECTED = \"waza_ok_detected\"\r\n-    NEXT_DETECTED = \"next_detected\"\r\n-    STAGE_45_DETECTED = \"stage_45_detected\"\r\n-\r\n-\r\n-@dataclass\r\n-class DeviceState:\r\n-    \"\"\"デバイス状態を管理するデータクラス\"\"\"\r\n-    device_id: str\r\n-    current_state: GameState = GameState.IDLE\r\n-    last_action_time: float = 0\r\n-    tap_count: int = 0\r\n-    error_count: int = 0\r\n-    is_active: bool = True\r\n-    hp_bar_tap_time: float = 0  # hp_barタップ時刻\r\n-\r\n-\r\n class AutomationEngine:\r\n-    \"\"\"妖怪ウォッチぷにぷに自動周回エンジン\"\"\"\r\n-    \r\n-    def __init__(self, template_dir: str = \"image\"):\r\n-        self.device_controller = MultiDeviceController()\r\n-        self.image_detector = MultiDeviceImageDetector(template_dir)\r\n-        self.device_states = {}\r\n+    def __init__(self, config_manager):\r\n+        self.config_manager = config_manager\r\n+        self.image_detector = ImageDetector()\r\n+        self.device_controller = DeviceController()\r\n+        \r\n         self.is_running = False\r\n-        self.logger = logging.getLogger(__name__)\r\n+        self.log_callback = None\r\n         \r\n-        # 設定\r\n-        self.detection_threshold = 0.8\r\n-        self.tap_cooldown = 0.5  # タップ間隔（秒）\r\n-        self.screen_capture_interval = 0.1  # 画面キャプチャ間隔（秒）\r\n-        self.max_error_count = 5  # 最大エラー回数\r\n+        # 画像ファイルのパス\r\n+        self.image_paths = {\r\n+            'play_1': 'image/play_1.png',\r\n+            'play_2': 'image/play_2.png',\r\n+            'next': 'image/next.png',\r\n+            'close': 'image/close.png',\r\n+            'close_mini': 'image/close_mini.png'\r\n+        }\r\n         \r\n-        # 統計情報\r\n-        self.total_loops = 0\r\n-        self.start_time = 0\r\n+        # 最後のタップ時間\r\n+        self.last_tap_time = 0\r\n         \r\n-    def add_device(self, device_id: str) -> bool:\r\n-        \"\"\"デバイスを追加\"\"\"\r\n-        if self.device_controller.add_device(device_id):\r\n-            self.device_states[device_id] = DeviceState(device_id)\r\n-            self.logger.info(f\"デバイス {device_id} を追加しました\")\r\n-            return True\r\n-        return False\r\n-    \r\n-    def remove_device(self, device_id: str):\r\n-        \"\"\"デバイスを削除\"\"\"\r\n-        self.device_controller.remove_device(device_id)\r\n-        if device_id in self.device_states:\r\n-            del self.device_states[device_id]\r\n-        self.logger.info(f\"デバイス {device_id} を削除しました\")\r\n-    \r\n-    def get_device_list(self) -> List[str]:\r\n-        \"\"\"管理中のデバイス一覧を取得\"\"\"\r\n-        return list(self.device_states.keys())\r\n-    \r\n-    def get_device_state(self, device_id: str) -> Optional[DeviceState]:\r\n-        \"\"\"デバイス状態を取得\"\"\"\r\n-        return self.device_states.get(device_id)\r\n-    \r\n-    def set_device_active(self, device_id: str, active: bool):\r\n-        \"\"\"デバイスのアクティブ状態を設定\"\"\"\r\n-        if device_id in self.device_states:\r\n-            self.device_states[device_id].is_active = active\r\n-    \r\n-    async def process_device_detection(self, device_id: str, \r\n-                                     detections: Dict[str, Optional[Tuple[int, int]]]):\r\n-        \"\"\"デバイスの検出結果を処理\"\"\"\r\n-        if device_id not in self.device_states:\r\n-            return\r\n+    def set_log_callback(self, callback):\r\n+        \"\"\"ログコールバックの設定\"\"\"\r\n+        self.log_callback = callback\r\n         \r\n-        device_state = self.device_states[device_id]\r\n-        if not device_state.is_active:\r\n-            return\r\n+    def log(self, message):\r\n+        \"\"\"ログメッセージの送信\"\"\"\r\n+        if self.log_callback:\r\n+            self.log_callback(message)\r\n+            \r\n+    def get_available_devices(self):\r\n+        \"\"\"利用可能なデバイスの取得\"\"\"\r\n+        return self.device_controller.get_devices()\r\n         \r\n-        current_time = time.time()\r\n+    def start(self):\r\n+        \"\"\"自動化の開始\"\"\"\r\n+        self.is_running = True\r\n         \r\n-        # タップクールダウンチェック\r\n-        if current_time - device_state.last_action_time < self.tap_cooldown:\r\n-            return\r\n+        # デバイスの設定\r\n+        config = self.config_manager.get_config()\r\n+        device = config.get('device')\r\n         \r\n-        try:\r\n-            # 優先度順で処理\r\n-            action_taken = False\r\n-\r\n-            # --- hp_barタップ済みフラグ ---\r\n-            if not hasattr(device_state, 'hp_bar_tapped'):\r\n-                device_state.hp_bar_tapped = False\r\n-\r\n-            # --- hp_bar検知時の特殊タップ ---\r\n-            # ただしwaza_ok_1またはwaza_ok_2が検出されていればhp_barはスキップ\r\n-            if (\r\n-                detections.get('hp_bar') and not action_taken and\r\n-                not (detections.get('waza_ok_1') or detections.get('waza_ok_2'))\r\n-            ):\r\n-                if not device_state.hp_bar_tapped:\r\n-                    x, y = detections['hp_bar']\r\n-                    tap_x, tap_y = x, y + 500\r\n-                    success = await self.device_controller.devices[device_id].tap_async(tap_x, tap_y)\r\n-                    if success:\r\n-                        device_state.hp_bar_tap_time = current_time\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        device_state.hp_bar_tapped = True\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: hp_barを検知し中央y+200をタップしました\")\r\n-            # hp_barが検出されていない場合はフラグ解除\r\n-            if not detections.get('hp_bar'):\r\n-                device_state.hp_bar_tapped = False\r\n-\r\n-            # --- waza_ok_1, waza_ok_2, waza_ok ---\r\n-            for waza_key in ('waza_ok', 'waza_ok_1', 'waza_ok_2'):\r\n-                if detections.get(waza_key) and not action_taken:\r\n-                    x, y = detections[waza_key]\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.WAZA_OK_DETECTED\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: {waza_key.upper()}をタップしました\")\r\n+        if not device:\r\n+            raise Exception(\"デバイスが選択されていません\")\r\n             \r\n-            # menu, ranking, yubinが検出されたら何もしない\r\n-            if any([\r\n-                detections.get('menu'),\r\n-                detections.get('ranking'),\r\n-                detections.get('yubin')\r\n-            ]):\r\n-                self.logger.info(f\"デバイス {device_id}: menu/ranking/yubinが検出されたため何もタップしません\")\r\n-                return\r\n+        # デバイスコントローラーの初期化\r\n+        self.device_controller.set_device(device)\r\n+        \r\n+        # 画像検出器の初期化\r\n+        threshold = config.get('detection_threshold', 0.8)\r\n+        self.image_detector.set_threshold(threshold)\r\n+        \r\n+        self.log(f\"自動化開始: デバイス {device}\")\r\n+        \r\n+    def stop(self):\r\n+        \"\"\"自動化の停止\"\"\"\r\n+        self.is_running = False\r\n+        self.log(\"自動化停止\")\r\n+        \r\n+    def process_frame(self):\r\n+        \"\"\"フレームの処理\"\"\"\r\n+        if not self.is_running:\r\n+            return False\r\n             \r\n-            # 1. bossが検出されたらタップ\r\n-            if detections.get('boss') and not action_taken:\r\n-                x, y = detections['boss']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.BOSS_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"デバイス {device_id}: BOSSをタップしました\")\r\n+        try:\r\n+            # スクリーンショットの取得\r\n+            screenshot = self.device_controller.get_screenshot()\r\n+            if screenshot is None:\r\n+                return False\r\n+                \r\n+            # まずプレイボタンの検出を確認\r\n+            play_detected = False\r\n+            play_positions = []\r\n             \r\n-            # --- play, play_1, play_2が検出されたらタップ ---\r\n-            for play_key in ('play', 'play_1', 'play_2'):\r\n-                if detections.get(play_key) and not action_taken:\r\n-                    x, y = detections[play_key]\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.PLAY_DETECTED\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: {play_key.upper()}をタップしました\")\r\n+            # プレイボタンの検出\r\n+            for play_image in ['play_1', 'play_2']:\r\n+                if play_image in self.image_paths:\r\n+                    positions = self.image_detector.detect_image(screenshot, self.image_paths[play_image])\r\n+                    if positions:\r\n+                        play_detected = True\r\n+                        play_positions.extend([(play_image, pos) for pos in positions])\r\n             \r\n-            # 3. close/close_miniが検出されたらタップ（ただしstage_45が検出されている場合はスキップ）\r\n-            if not action_taken and not detections.get('stage_45'):\r\n-                if detections.get('close'):\r\n-                    x, y = detections['close']\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.IDLE\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: CLOSEをタップしました\")\r\n-                elif detections.get('close_mini'):\r\n-                    x, y = detections['close_mini']\r\n-                    success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                    if success:\r\n-                        device_state.current_state = GameState.IDLE\r\n-                        device_state.last_action_time = current_time\r\n-                        device_state.tap_count += 1\r\n-                        action_taken = True\r\n-                        self.logger.info(f\"デバイス {device_id}: CLOSE_MINIをタップしました\")\r\n-            elif detections.get('stage_45'):\r\n-                self.logger.info(f\"デバイス {device_id}: stage_45が検出されたため、close/close_miniをスキップします\")\r\n+            # 各画像の検出とタップ（優先順位付き）\r\n+            detected_any = False\r\n             \r\n-            # 4. puzzleが検出されたらタップ\r\n-            if detections.get('puzzle') and not action_taken:\r\n-                x, y = detections['puzzle']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.PUZZLE_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"デバイス {device_id}: PUZZLEをタップしました\")\r\n+            # プレイボタンが検出された場合は、プレイボタンのみタップ\r\n+            if play_detected:\r\n+                current_time = time.time()\r\n+                tap_interval = self.config_manager.get_config().get('tap_interval', 0.5)\r\n+                \r\n+                if current_time - self.last_tap_time >= tap_interval:\r\n+                    # 最初に見つかったプレイボタンをタップ\r\n+                    image_name, (x, y) = play_positions[0]\r\n+                    self.device_controller.tap(x, y)\r\n+                    self.last_tap_time = current_time\r\n+                    \r\n+                    self.log(f\"{image_name} を検出してタップ: ({x}, {y})\")\r\n+                    detected_any = True\r\n+                    \r\n+            else:\r\n+                # プレイボタンが検出されていない場合のみ、他のボタンを処理\r\n+                for image_name, image_path in self.image_paths.items():\r\n+                    # プレイボタンはすでに処理済みなのでスキップ\r\n+                    if image_name in ['play_1', 'play_2']:\r\n+                        continue\r\n+                        \r\n+                    positions = self.image_detector.detect_image(screenshot, image_path)\r\n+                    \r\n+                    if positions:\r\n+                        detected_any = True\r\n+                        \r\n+                        # タップ間隔の確認\r\n+                        current_time = time.time()\r\n+                        tap_interval = self.config_manager.get_config().get('tap_interval', 0.5)\r\n+                        \r\n+                        if current_time - self.last_tap_time >= tap_interval:\r\n+                            # 最初に見つかった位置をタップ\r\n+                            x, y = positions[0]\r\n+                            self.device_controller.tap(x, y)\r\n+                            self.last_tap_time = current_time\r\n+                            \r\n+                            self.log(f\"{image_name} を検出してタップ: ({x}, {y})\")\r\n+                            \r\n+                            # 一度にひとつの画像のみ処理\r\n+                            break\r\n+                        \r\n+            return detected_any\r\n             \r\n-            # 5. waza_okが検出されたらタップ\r\n-            if detections.get('waza_ok') and not action_taken:\r\n-                x, y = detections['waza_ok']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.WAZA_OK_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.logger.info(f\"デバイス {device_id}: WAZA_OKをタップしました\")\r\n+        except Exception as e:\r\n+            self.log(f\"処理エラー: {str(e)}\")\r\n+            return False\r\n             \r\n-            # 6. nextが検出されたらタップ\r\n-            if detections.get('next') and not action_taken:\r\n-                x, y = detections['next']\r\n-                success = await self.device_controller.devices[device_id].tap_async(x, y)\r\n-                if success:\r\n-                    device_state.current_state = GameState.NEXT_DETECTED\r\n-                    device_state.last_action_time = current_time\r\n-                    device_state.tap_count += 1\r\n-                    action_taken = True\r\n-                    self.total_loops += 1  # ループ完了のカウント\r\n-                    self.logger.info(f\"デバイス {device_id}: NEXTをタップしました（ループ完了: {self.total_loops}）\")\r\n+    def test_image_detection(self):\r\n+        \"\"\"画像検出のテスト\"\"\"\r\n+        config = self.config_manager.get_config()\r\n+        device = config.get('device')\r\n+        \r\n+        if not device:\r\n+            raise Exception(\"デバイスが選択されていません\")\r\n             \r\n-            # エラーカウントリセット\r\n-            if action_taken:\r\n-                device_state.error_count = 0\r\n+        # デバイスコントローラーの初期化\r\n+        self.device_controller.set_device(device)\r\n+        \r\n+        # 画像検出器の初期化\r\n+        threshold = config.get('detection_threshold', 0.8)\r\n+        self.image_detector.set_threshold(threshold)\r\n+        \r\n+        # スクリーンショットの取得\r\n+        screenshot = self.device_controller.get_screenshot()\r\n+        if screenshot is None:\r\n+            raise Exception(\"スクリーンショットの取得に失敗しました\")\r\n             \r\n-        except Exception as e:\r\n-            device_state.error_count += 1\r\n-            self.logger.error(f\"デバイス {device_id} の処理エラー: {e}\")\r\n-            \r\n-            # エラー回数が上限を超えた場合、デバイスを非アクティブにする\r\n-            if device_state.error_count >= self.max_error_count:\r\n-                device_state.is_active = False\r\n-                self.logger.warning(f\"デバイス {device_id} がエラー上限に達したため非アクティブにしました\")\r\n-    \r\n-    async def automation_loop(self):\r\n-        \"\"\"メイン自動化ループ\"\"\"\r\n-        self.logger.info(\"自動化ループを開始します\")\r\n-        self.start_time = time.time()\r\n+        # 各画像の検出テスト\r\n+        results = {}\r\n         \r\n-        while self.is_running:\r\n+        for image_name, image_path in self.image_paths.items():\r\n             try:\r\n-                # 全デバイスの画面キャプチャ\r\n-                screen_data = await self.device_controller.capture_all_screens()\r\n+                positions = self.image_detector.detect_image(screenshot, image_path)\r\n+                results[image_name] = len(positions) > 0\r\n                 \r\n-                if not screen_data:\r\n-                    await asyncio.sleep(self.screen_capture_interval)\r\n-                    continue\r\n+                if positions:\r\n+                    self.log(f\"{image_name}: 検出 ({len(positions)}箇所)\")\r\n+                else:\r\n+                    self.log(f\"{image_name}: 未検出\")\r\n+                    \r\n+            except Exception as e:\r\n+                self.log(f\"{image_name}: エラー - {str(e)}\")\r\n+                results[image_name] = False\r\n                 \r\n-                # 全デバイスで画像検出\r\n-                detection_results = await self.image_detector.detect_all_devices(\r\n-                    screen_data, self.detection_threshold\r\n-                )\r\n-                \r\n-                # 各デバイスの検出結果を処理\r\n-                tasks = []\r\n-                for device_id, detections in detection_results.items():\r\n-                    if device_id in self.device_states:\r\n-                        task = self.process_device_detection(device_id, detections)\r\n-                        tasks.append(task)                \r\n-                # 全デバイスの処理を並行実行\r\n-                if tasks:\r\n-                    await asyncio.gather(*tasks, return_exceptions=True)\r\n-                \r\n-                # 短い待機\r\n-                await asyncio.sleep(self.screen_capture_interval)\r\n-                \r\n-            except Exception as e:\r\n-                self.logger.error(f\"自動化ループエラー: {e}\")\r\n-                await asyncio.sleep(1)  # エラー時は少し長めに待機\r\n-    \r\n-    async def start_automation(self):\r\n-        \"\"\"自動化を開始\"\"\"\r\n-        if self.is_running:\r\n-            self.logger.warning(\"自動化は既に実行中です\")\r\n-            return\r\n-        \r\n-        if not self.device_states:\r\n-            self.logger.error(\"デバイスが登録されていません\")\r\n-            return\r\n-        \r\n-        self.is_running = True\r\n-        self.total_loops = 0\r\n-        try:\r\n-            await self.automation_loop()\r\n-        except Exception as e:\r\n-            self.logger.error(f\"自動化実行エラー: {e}\")\r\n-        finally:\r\n-            self.is_running = False\r\n-    \r\n-    def stop_automation(self):\r\n-        \"\"\"自動化を停止\"\"\"\r\n-        self.is_running = False\r\n-        self.logger.info(\"自動化を停止しました\")\r\n-    \r\n-    def get_statistics(self) -> Dict:\r\n-        \"\"\"統計情報を取得\"\"\"\r\n-        current_time = time.time()\r\n-        elapsed_time = current_time - self.start_time if self.start_time > 0 else 0\r\n-        \r\n-        stats = {\r\n-            'total_loops': self.total_loops,\r\n-            'elapsed_time': elapsed_time,\r\n-            'loops_per_hour': (self.total_loops / elapsed_time * 3600) if elapsed_time > 0 else 0,\r\n-            'active_devices': len([d for d in self.device_states.values() if d.is_active]),\r\n-            'total_devices': len(self.device_states),\r\n-            'device_details': {}\r\n-        }\r\n-        \r\n-        for device_id, state in self.device_states.items():\r\n-            stats['device_details'][device_id] = {\r\n-                'state': state.current_state.value,\r\n-                'tap_count': state.tap_count,\r\n-                'error_count': state.error_count,\r\n-                'is_active': state.is_active,\r\n-                'last_action_time': state.last_action_time\r\n-            }\r\n-        \r\n-        return stats\r\n-    \r\n-    def reset_statistics(self):\r\n-        \"\"\"統計情報をリセット\"\"\"\r\n-        self.total_loops = 0\r\n-        self.start_time = time.time()\r\n-        for state in self.device_states.values():\r\n-            state.tap_count = 0\r\n-            state.error_count = 0\r\n-    \r\n-    def set_detection_threshold(self, threshold: float):\r\n-        \"\"\"検出閾値を設定\"\"\"\r\n-        self.detection_threshold = max(0.1, min(1.0, threshold))\r\n-    \r\n-    def set_tap_cooldown(self, cooldown: float):\r\n-        \"\"\"タップクールダウンを設定\"\"\"\r\n-        self.tap_cooldown = max(0.005, cooldown)\r\n-    \r\n-    def set_capture_interval(self, interval: float):\r\n-        \"\"\"画面キャプチャ間隔を設定\"\"\"\r\n-        self.screen_capture_interval = max(0.005, interval)\r\n+        return results\r\n"
                },
                {
                    "date": 1750517501504,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,16 +12,16 @@\n         self.device_controller = DeviceController()\r\n         \r\n         self.is_running = False\r\n         self.log_callback = None\r\n-        \r\n-        # 画像ファイルのパス\r\n+          # 画像ファイルのパス\r\n         self.image_paths = {\r\n             'play_1': 'image/play_1.png',\r\n             'play_2': 'image/play_2.png',\r\n             'next': 'image/next.png',\r\n             'close': 'image/close.png',\r\n-            'close_mini': 'image/close_mini.png'\r\n+            'close_mini': 'image/close_mini.png',\r\n+            'ok': 'image/ok.png'\r\n         }\r\n         \r\n         # 最後のタップ時間\r\n         self.last_tap_time = 0\r\n"
                },
                {
                    "date": 1750518120659,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,10 @@\n         self.device_controller = DeviceController()\r\n         \r\n         self.is_running = False\r\n         self.log_callback = None\r\n-          # 画像ファイルのパス\r\n+        \r\n+        # 画像ファイルのパス\r\n         self.image_paths = {\r\n             'play_1': 'image/play_1.png',\r\n             'play_2': 'image/play_2.png',\r\n             'next': 'image/next.png',\r\n@@ -22,8 +23,16 @@\n             'close_mini': 'image/close_mini.png',\r\n             'ok': 'image/ok.png'\r\n         }\r\n         \r\n+        # タップしない画像（検出のみ行う）\r\n+        self.ignore_images = {\r\n+            'goukan': 'image/goukan.png',\r\n+            'menu': 'image/menu.png',\r\n+            'ranking': 'image/ranking.png',\r\n+            'yuubin': 'image/yuubin.png'\r\n+        }\r\n+        \r\n         # 最後のタップ時間\r\n         self.last_tap_time = 0\r\n         \r\n     def set_log_callback(self, callback):\r\n@@ -73,8 +82,31 @@\n             # スクリーンショットの取得\r\n             screenshot = self.device_controller.get_screenshot()\r\n             if screenshot is None:\r\n                 return False\r\n+                  # タップしない画像が表示されているかチェック\r\n+            ignore_detected = False\r\n+            config = self.config_manager.get_config()\r\n+            \r\n+            for ignore_name, ignore_path in self.ignore_images.items():\r\n+                # 設定でその画像の誤タップ防止が有効かチェック\r\n+                prevent_key = f'prevent_{ignore_name}'\r\n+                if not config.get(prevent_key, True):\r\n+                    continue  # この画像の誤タップ防止が無効なのでスキップ\r\n+                    \r\n+                try:\r\n+                    positions = self.image_detector.detect_image(screenshot, ignore_path)\r\n+                    if positions:\r\n+                        ignore_detected = True\r\n+                        self.log(f\"{ignore_name} を検出（タップしません）\")\r\n+                        break\r\n+                except:\r\n+                    # 画像ファイルが存在しない場合は無視\r\n+                    pass\r\n+            \r\n+            # タップしない画像が検出された場合は何もしない\r\n+            if ignore_detected:\r\n+                return True\r\n                 \r\n             # まずプレイボタンの検出を確認\r\n             play_detected = False\r\n             play_positions = []\r\n@@ -159,8 +191,9 @@\n             \r\n         # 各画像の検出テスト\r\n         results = {}\r\n         \r\n+        # タップする画像の検出テスト\r\n         for image_name, image_path in self.image_paths.items():\r\n             try:\r\n                 positions = self.image_detector.detect_image(screenshot, image_path)\r\n                 results[image_name] = len(positions) > 0\r\n@@ -172,6 +205,28 @@\n                     \r\n             except Exception as e:\r\n                 self.log(f\"{image_name}: エラー - {str(e)}\")\r\n                 results[image_name] = False\r\n+          # タップしない画像の検出テスト\r\n+        config = self.config_manager.get_config()\r\n+        for ignore_name, ignore_path in self.ignore_images.items():\r\n+            # 設定でその画像の誤タップ防止が有効かチェック\r\n+            prevent_key = f'prevent_{ignore_name}'\r\n+            if not config.get(prevent_key, True):\r\n+                results[f\"{ignore_name}(無効)\"] = False\r\n+                self.log(f\"{ignore_name}(無効): 誤タップ防止が無効です\")\r\n+                continue\r\n                 \r\n+            try:\r\n+                positions = self.image_detector.detect_image(screenshot, ignore_path)\r\n+                results[f\"{ignore_name}(無視)\"] = len(positions) > 0\r\n+                \r\n+                if positions:\r\n+                    self.log(f\"{ignore_name}(無視): 検出 ({len(positions)}箇所)\")\r\n+                else:\r\n+                    self.log(f\"{ignore_name}(無視): 未検出\")\r\n+                    \r\n+            except Exception as e:\r\n+                self.log(f\"{ignore_name}(無視): エラー - {str(e)}\")\r\n+                results[f\"{ignore_name}(無視)\"] = False\r\n+                \r\n         return results\r\n"
                },
                {
                    "date": 1750518382849,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n import cv2\r\n import numpy as np\r\n import time\r\n import threading\r\n+import os\r\n from image_detector import ImageDetector\r\n from device_controller import DeviceController\r\n \r\n class AutomationEngine:\r\n@@ -13,29 +14,51 @@\n         \r\n         self.is_running = False\r\n         self.log_callback = None\r\n         \r\n-        # 画像ファイルのパス\r\n-        self.image_paths = {\r\n-            'play_1': 'image/play_1.png',\r\n-            'play_2': 'image/play_2.png',\r\n-            'next': 'image/next.png',\r\n-            'close': 'image/close.png',\r\n-            'close_mini': 'image/close_mini.png',\r\n-            'ok': 'image/ok.png'\r\n-        }\r\n-        \r\n-        # タップしない画像（検出のみ行う）\r\n-        self.ignore_images = {\r\n-            'goukan': 'image/goukan.png',\r\n-            'menu': 'image/menu.png',\r\n-            'ranking': 'image/ranking.png',\r\n-            'yuubin': 'image/yuubin.png'\r\n-        }\r\n-        \r\n         # 最後のタップ時間\r\n         self.last_tap_time = 0\r\n         \r\n+        # 画像パスを初期化\r\n+        self.reload_images()\r\n+        \r\n+    def reload_images(self):\r\n+        \"\"\"imageフォルダから画像を再読み込みし、分類する\"\"\"\r\n+        image_dir = \"image\"\r\n+        if not os.path.exists(image_dir):\r\n+            os.makedirs(image_dir)\r\n+            \r\n+        # デフォルトのタップする画像\r\n+        default_tap_images = ['play_1.png', 'play_2.png', 'next.png', 'close.png', 'close_mini.png', 'ok.png']\r\n+        \r\n+        # デフォルトのタップしない画像\r\n+        default_ignore_images = ['koukan.png', 'menu.png', 'ranking.png', 'yubin.png']\r\n+        \r\n+        # 画像ファイルのパスを再構築\r\n+        self.image_paths = {}\r\n+        self.ignore_images = {}\r\n+        \r\n+        # imageフォルダ内のすべての画像ファイルを確認\r\n+        for filename in os.listdir(image_dir):\r\n+            if filename.lower().endswith(('.png', '.jpg', '.jpeg')):\r\n+                file_path = os.path.join(image_dir, filename)\r\n+                \r\n+                # ファイル名から拡張子を除去\r\n+                name_without_ext = os.path.splitext(filename)[0]\r\n+                \r\n+                if filename in default_ignore_images:\r\n+                    # デフォルトのタップしない画像\r\n+                    self.ignore_images[name_without_ext] = file_path\r\n+                elif filename in default_tap_images:\r\n+                    # デフォルトのタップする画像\r\n+                    self.image_paths[name_without_ext] = file_path\r\n+                else:\r\n+                    # 新規追加された画像は初期状態でタップする画像として扱う\r\n+                    # ユーザーが明示的にタップしない画像として追加した場合の処理は将来拡張\r\n+                    self.image_paths[name_without_ext] = file_path\r\n+                    \r\n+        self.log(f\"画像を再読み込みしました - タップ: {len(self.image_paths)}個, 無視: {len(self.ignore_images)}個\")\r\n+        \r\n     def set_log_callback(self, callback):\r\n         \"\"\"ログコールバックの設定\"\"\"\r\n         self.log_callback = callback\r\n         \r\n"
                }
            ],
            "date": 1750493481590,
            "name": "Commit-0",
            "content": "\"\"\"\r\n自動化エンジンモジュール\r\n自動周回のメインロジック、バトルループ、リアルタイム監視機能\r\n\"\"\"\r\n\r\nimport time\r\nimport threading\r\nimport random\r\nfrom image_detector import ImageDetector\r\nfrom device_controller import DeviceController\r\n\r\n\r\nclass AutomationEngine:\r\n    def __init__(self, image_paths, settings, log_callback):\r\n        self.image_paths = image_paths\r\n        self.settings = settings\r\n        self.log = log_callback\r\n        \r\n        self.image_detector = ImageDetector(settings['similarity_threshold'])\r\n        self.device_controller = DeviceController()\r\n        \r\n        self.running = False\r\n        self.threads = {}\r\n        self.device_status = {}\r\n        \r\n        # リアルタイム監視用\r\n        self.realtime_monitoring = False\r\n        self.realtime_monitor_thread = None\r\n        \r\n    def update_settings(self, settings):\r\n        \"\"\"設定を更新\"\"\"\r\n        self.settings = settings\r\n        self.image_detector.similarity_threshold = settings['similarity_threshold']\r\n    \r\n    def human_like_delay(self):\r\n        \"\"\"人間らしいランダムな遅延\"\"\"\r\n        delay = random.uniform(\r\n            self.settings['human_like_delay_min'], \r\n            self.settings['human_like_delay_max']\r\n        )\r\n        time.sleep(delay)\r\n    \r\n    def start_automation(self, selected_devices):\r\n        \"\"\"自動化開始\"\"\"\r\n        self.running = True\r\n        \r\n        # デバイス互換性チェック\r\n        for device_id in selected_devices:\r\n            self.log_device_compatibility(device_id)\r\n        \r\n        # 各デバイスでスレッドを開始\r\n        for device_id in selected_devices:\r\n            thread = threading.Thread(target=self.automation_loop, args=(device_id,))\r\n            thread.daemon = True\r\n            self.threads[device_id] = thread\r\n            thread.start()\r\n            self.log(\"自動化開始\", device_id)\r\n    \r\n    def stop_automation(self):\r\n        \"\"\"自動化停止\"\"\"\r\n        self.running = False\r\n        self.threads.clear()\r\n        self.log(\"全デバイスの自動化を停止\")\r\n    \r\n    def automation_loop(self, device_id):\r\n        \"\"\"最適化されたメインの自動化ループ\"\"\"\r\n        self.device_status[device_id] = \"実行中\"\r\n        puzzle_tap_count = 0\r\n        stage_45_detected = False\r\n        \r\n        while self.running and device_id in self.threads:\r\n            try:\r\n                # 優先度の高い画像を同時検索\r\n                priority_images = {}\r\n                \r\n                # stage_45.pngを最初にチェック\r\n                screenshot = self.device_controller.fast_screenshot_to_memory(\r\n                    device_id, self.settings.get('use_memory_capture', True)\r\n                )\r\n                if screenshot is None:\r\n                    time.sleep(0.5)\r\n                    continue\r\n                \r\n                stage_45_pos = self.image_detector.find_image_on_screen_optimized(\r\n                    self.image_paths['stage_45'], screenshot\r\n                )\r\n                \r\n                if stage_45_pos and not stage_45_detected:\r\n                    stage_45_detected = True\r\n                    self.log(\"ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n                elif not stage_45_pos and stage_45_detected:\r\n                    stage_45_detected = False\r\n                    self.log(\"ステージ45終了 - close系ボタンの監視を再開\", device_id)\r\n                \r\n                # close系の監視（stage_45検出時は除く）\r\n                if not stage_45_detected:\r\n                    priority_images['close'] = self.image_paths['close']\r\n                    priority_images['close_mini'] = self.image_paths['close_mini']\r\n                \r\n                # 現在の状態に応じた画像を追加\r\n                priority_images['boss'] = self.image_paths['boss']\r\n                priority_images['play'] = self.image_paths['play']\r\n                priority_images['next'] = self.image_paths['next']\r\n                \r\n                # 複数画像を同時検索（最適化版）\r\n                detected_images = self.image_detector.find_multiple_images_on_screen_optimized(\r\n                    priority_images, screenshot\r\n                )\r\n                \r\n                # playボタンを直接検出した場合の処理を追加\r\n                if 'play' in detected_images:\r\n                    self.log(\"playボタンを直接検出しました\", device_id)\r\n                    pos = detected_images['play']['pos']\r\n                    \r\n                    # play.pngをタップ前に再度stage_45.pngをチェック\r\n                    stage_45_pos = self.image_detector.find_image_on_screen_optimized(\r\n                        self.image_paths['stage_45'], screenshot\r\n                    )\r\n                    if stage_45_pos:\r\n                        stage_45_detected = True\r\n                        self.log(\"プレイ前ステージ45検出 - close系ボタンの監視を停止\", device_id)\r\n                    \r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"play\", self.settings['tap_delay']\r\n                    )\r\n                    \r\n                    # バトルループ（③④の処理）\r\n                    self.battle_loop(device_id, puzzle_tap_count)\r\n                    puzzle_tap_count = 0\r\n                    continue\r\n                \r\n                # 優先順位に従って処理\r\n                if 'close' in detected_images and not stage_45_detected:\r\n                    pos = detected_images['close']['pos']\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n                    )\r\n                    continue\r\n                    \r\n                if 'close_mini' in detected_images and not stage_45_detected:\r\n                    pos = detected_images['close_mini']['pos']\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n                    )\r\n                    continue\r\n                \r\n                # next.pngが検出された場合（最優先）\r\n                if 'next' in detected_images:\r\n                    pos = detected_images['next']['pos']\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"next\", self.settings['tap_delay']\r\n                    )\r\n                    stage_45_detected = False  # リセット\r\n                    puzzle_tap_count = 0\r\n                    continue\r\n                \r\n                # boss.pngが検出された場合\r\n                if 'boss' in detected_images:\r\n                    pos = detected_images['boss']['pos']\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"boss\", self.settings['tap_delay']\r\n                    )\r\n                    \r\n                    # play.pngを待機して検索（最適化版・強化）\r\n                    self.log(\"boss検出後、playボタンを検索中...\", device_id)\r\n                    play_found = False\r\n                    max_attempts = 10  # 最大試行回数\r\n                    \r\n                    for attempt in range(max_attempts):\r\n                        time.sleep(0.5)  # 画面遷移を待つ\r\n                        # 新しいスクリーンショットを取得\r\n                        new_screenshot = self.device_controller.fast_screenshot_to_memory(\r\n                            device_id, self.settings.get('use_memory_capture', True)\r\n                        )\r\n                        if new_screenshot is None:\r\n                            continue\r\n                            \r\n                        # 段階的閾値検索を使用\r\n                        play_pos = self.image_detector.find_image_with_multiple_thresholds(\r\n                            self.image_paths['play'], new_screenshot\r\n                        )\r\n                        \r\n                        if play_pos:\r\n                            self.log(f\"playボタン検出成功 (試行{attempt + 1}回目): {play_pos}\", device_id)\r\n                            play_found = True\r\n                            \r\n                            self.device_controller.smart_tap_screen(\r\n                                play_pos[0], play_pos[1], device_id, \"play\", self.settings['tap_delay']\r\n                            )\r\n                            \r\n                            # バトルループ（③④の処理）\r\n                            self.battle_loop(device_id, puzzle_tap_count)\r\n                            puzzle_tap_count = 0\r\n                            break\r\n                        else:\r\n                            self.log(f\"playボタン未検出 (試行{attempt + 1}回目)\", device_id)\r\n                    \r\n                    if not play_found:\r\n                        self.log(f\"playボタンが見つかりませんでした（{max_attempts}回試行）\", device_id)\r\n                \r\n                # 短い間隔で次のチェック\r\n                time.sleep(self.settings['check_interval'])\r\n                \r\n            except Exception as e:\r\n                self.log(f\"自動化エラー: {str(e)}\", device_id)\r\n                time.sleep(0.5)\r\n        \r\n        self.device_status[device_id] = \"停止\"\r\n        self.log(\"自動化停止\", device_id)\r\n    \r\n    def battle_loop(self, device_id, initial_puzzle_count=0):\r\n        \"\"\"バトル中のループ処理（③④の最適化・puzzle検知強化）\"\"\"\r\n        puzzle_tap_count = initial_puzzle_count\r\n        battle_start_time = time.time()\r\n        max_battle_time = 60  # 最大バトル時間（秒）\r\n        stage_45_in_battle = False\r\n        puzzle_search_attempts = 0  # puzzle検索試行回数\r\n        \r\n        self.log(f\"バトル開始 (初期puzzle回数: {puzzle_tap_count})\", device_id)\r\n        \r\n        while self.running and device_id in self.threads:\r\n            # 最大時間チェック\r\n            if time.time() - battle_start_time > max_battle_time:\r\n                self.log(\"バトル時間超過 - 次のサイクルに移行\", device_id)\r\n                break\r\n            \r\n            # スクリーンショット取得\r\n            screenshot = self.device_controller.fast_screenshot_to_memory(\r\n                device_id, self.settings.get('use_memory_capture', True)\r\n            )\r\n            if screenshot is None:\r\n                time.sleep(0.3)\r\n                continue\r\n            \r\n            # バトル開始時にstage_45をチェック\r\n            if not stage_45_in_battle:\r\n                stage_45_pos = self.image_detector.find_image_on_screen_optimized(\r\n                    self.image_paths['stage_45'], screenshot\r\n                )\r\n                if stage_45_pos:\r\n                    stage_45_in_battle = True\r\n                    self.log(\"バトル中ステージ45検出 - close系監視停止\", device_id)\r\n            \r\n            # バトル関連の画像を同時検索（puzzle優先順序）\r\n            battle_images = {\r\n                'puzzle': self.image_paths['puzzle'],  # puzzleを最初に配置\r\n                'next': self.image_paths['next'],\r\n                'waza_ok': self.image_paths['waza_ok']\r\n            }\r\n            \r\n            # stage_45が検出されていない場合のみclose系を追加\r\n            if not stage_45_in_battle:\r\n                battle_images['close'] = self.image_paths['close']\r\n                battle_images['close_mini'] = self.image_paths['close_mini']\r\n            \r\n            detected = self.image_detector.find_multiple_images_on_screen_optimized(\r\n                battle_images, screenshot\r\n            )\r\n            \r\n            # 最優先: puzzle.pngをタップ（回数制限あり・超積極的検知）\r\n            if puzzle_tap_count < self.settings['puzzle_tap_count']:\r\n                puzzle_detected = False\r\n                \r\n                # 方法1: 通常の検知を試行\r\n                if 'puzzle' in detected:\r\n                    pos = detected['puzzle']['pos']\r\n                    confidence = detected['puzzle']['confidence']\r\n                    self.log(f\"puzzle通常検出 (回数: {puzzle_tap_count + 1}/{self.settings['puzzle_tap_count']}, 信頼度: {confidence:.3f})\", device_id)\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"puzzle\", self.settings['tap_delay']\r\n                    )\r\n                    puzzle_tap_count += 1\r\n                    puzzle_detected = True\r\n                \r\n                # 方法2: 通常検知で失敗した場合、すぐに強化検知を試行\r\n                if not puzzle_detected:\r\n                    puzzle_pos = self.image_detector.find_puzzle_with_enhanced_detection(\r\n                        self.image_paths['puzzle'], screenshot\r\n                    )\r\n                    if puzzle_pos:\r\n                        self.log(f\"puzzle強化検出 (回数: {puzzle_tap_count + 1}/{self.settings['puzzle_tap_count']})\", device_id)\r\n                        self.device_controller.smart_tap_screen(\r\n                            puzzle_pos[0], puzzle_pos[1], device_id, \"puzzle\", self.settings['tap_delay']\r\n                        )\r\n                        puzzle_tap_count += 1\r\n                        puzzle_detected = True\r\n                \r\n                # 方法3: それでも失敗した場合、低閾値で最後の試行\r\n                if not puzzle_detected and puzzle_search_attempts % 3 == 0:  # 3回に1回だけ\r\n                    low_threshold_pos = self.image_detector.find_image_on_screen_optimized(\r\n                        self.image_paths['puzzle'], screenshot, threshold=0.5\r\n                    )\r\n                    if low_threshold_pos:\r\n                        self.log(f\"puzzle低閾値検出 (回数: {puzzle_tap_count + 1}/{self.settings['puzzle_tap_count']})\", device_id)\r\n                        self.device_controller.smart_tap_screen(\r\n                            low_threshold_pos[0], low_threshold_pos[1], device_id, \"puzzle\", self.settings['tap_delay']\r\n                        )\r\n                        puzzle_tap_count += 1\r\n                        puzzle_detected = True\r\n                \r\n                # puzzle検出成功時は短いスリープで次のループへ\r\n                if puzzle_detected:\r\n                    time.sleep(0.2)  # さらに短いディレイでpuzzleを連続検索\r\n                    continue\r\n                else:\r\n                    # puzzle検出失敗時の処理（ログ頻度を制御）\r\n                    puzzle_search_attempts += 1\r\n                    if puzzle_search_attempts % 3 == 1:  # 3回に1回ログ（頻度を上げる）\r\n                        self.log(f\"puzzle全検出失敗 ({puzzle_search_attempts}回目) - waza_okを待機中\", device_id)\r\n                        # 失敗時はリアルタイム状況をログ\r\n                        if puzzle_search_attempts % 9 == 1:  # 9回に1回は詳細ログ\r\n                            current_images = self.image_detector.find_multiple_images_on_screen_optimized(\r\n                                {'waza_ok': self.image_paths['waza_ok'], 'next': self.image_paths['next']}, screenshot\r\n                            )\r\n                            detected_names = list(current_images.keys())\r\n                            self.log(f\"現在検出中の画像: {detected_names if detected_names else 'なし'}\", device_id)\r\n            \r\n            # 次の優先度: waza_ok.pngをタップ\r\n            if 'waza_ok' in detected:\r\n                pos = detected['waza_ok']['pos']\r\n                self.device_controller.smart_tap_screen(\r\n                    pos[0], pos[1], device_id, \"waza_ok\", self.settings['tap_delay']\r\n                )\r\n                puzzle_tap_count = 0  # パズルカウンターリセット\r\n                puzzle_search_attempts = 0  # 検索試行回数もリセット\r\n                continue\r\n            \r\n            # close系の処理（stage_45が検出されていない場合のみ）\r\n            if not stage_45_in_battle:\r\n                if 'close' in detected:\r\n                    pos = detected['close']['pos']\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n                    )\r\n                    continue\r\n                    \r\n                if 'close_mini' in detected:\r\n                    pos = detected['close_mini']['pos']\r\n                    self.device_controller.smart_tap_screen(\r\n                        pos[0], pos[1], device_id, \"close\", self.settings['tap_delay']\r\n                    )\r\n                    continue\r\n            \r\n            # 最後: next.pngが検出されたらバトル終了\r\n            if 'next' in detected:\r\n                pos = detected['next']['pos']\r\n                self.device_controller.smart_tap_screen(\r\n                    pos[0], pos[1], device_id, \"next\", self.settings['tap_delay']\r\n                )\r\n                break\r\n            \r\n            # puzzleが必要な場合は短い間隔、そうでなければ通常間隔\r\n            if puzzle_tap_count < self.settings['puzzle_tap_count']:\r\n                time.sleep(max(0.15, self.settings['check_interval'] * 0.3))  # puzzle検索時は超高速\r\n            else:\r\n                time.sleep(self.settings['check_interval'])\r\n    \r\n    def toggle_realtime_monitor(self, device_id):\r\n        \"\"\"リアルタイム監視の開始/停止\"\"\"\r\n        if not self.realtime_monitoring:\r\n            self.realtime_monitoring = True\r\n            \r\n            # 監視スレッドを開始\r\n            self.realtime_monitor_thread = threading.Thread(\r\n                target=self.realtime_monitor_loop, \r\n                args=(device_id,)\r\n            )\r\n            self.realtime_monitor_thread.daemon = True\r\n            self.realtime_monitor_thread.start()\r\n            \r\n            self.log(\"リアルタイム監視開始\")\r\n            return True\r\n        else:\r\n            self.realtime_monitoring = False\r\n            self.log(\"リアルタイム監視停止\")\r\n            return False\r\n    \r\n    def realtime_monitor_loop(self, device_id):\r\n        \"\"\"リアルタイム監視のメインループ\"\"\"\r\n        last_detection_status = {}\r\n        \r\n        while self.realtime_monitoring:\r\n            try:\r\n                # スクリーンショット取得\r\n                screenshot = self.device_controller.fast_screenshot_to_memory(\r\n                    device_id, self.settings.get('use_memory_capture', True)\r\n                )\r\n                if screenshot is None:\r\n                    time.sleep(1.0)\r\n                    continue\r\n                \r\n                # 全画像を同時検索\r\n                all_images = self.image_paths.copy()\r\n                detected = self.image_detector.find_multiple_images_on_screen_optimized(\r\n                    all_images, screenshot\r\n                )\r\n                \r\n                # 検出状況の変化をログ\r\n                current_status = {}\r\n                for name in all_images.keys():\r\n                    current_status[name] = name in detected\r\n                    \r\n                    # 状態が変化した場合のみログ\r\n                    if name not in last_detection_status or last_detection_status[name] != current_status[name]:\r\n                        if current_status[name]:\r\n                            confidence = detected[name]['confidence']\r\n                            pos = detected[name]['pos']\r\n                            self.log(f\"🔍 検出: {name} (信頼度: {confidence:.3f}, 位置: {pos})\", device_id)\r\n                        else:\r\n                            self.log(f\"❌ 消失: {name}\", device_id)\r\n                \r\n                # puzzle.pngが検出されていない場合は強化検知を試行\r\n                if not current_status.get('puzzle', False):\r\n                    puzzle_pos = self.image_detector.find_puzzle_with_enhanced_detection(\r\n                        self.image_paths['puzzle'], screenshot\r\n                    )\r\n                    if puzzle_pos:\r\n                        self.log(f\"🔍 強化検出: puzzle (位置: {puzzle_pos})\", device_id)\r\n                        current_status['puzzle'] = True\r\n                \r\n                last_detection_status = current_status.copy()\r\n                \r\n                # 1秒間隔で監視\r\n                time.sleep(1.0)\r\n                \r\n            except Exception as e:\r\n                self.log(f\"監視エラー: {str(e)}\", device_id)\r\n                time.sleep(1.0)\r\n    \r\n    def log_device_compatibility(self, device_id):\r\n        \"\"\"デバイス互換性情報をログ出力\"\"\"\r\n        compat = self.device_controller.check_device_compatibility(device_id)\r\n        self.log(f\"デバイス互換性チェック: Android {compat['android_version']}\", device_id)\r\n        if compat['memory_capture_supported']:\r\n            self.log(\"メモリ直接取得: サポート\", device_id)\r\n        else:\r\n            self.log(f\"メモリ直接取得: 非サポート - {compat['reason']}\", device_id)\r\n            self.log(\"通常のファイル方式を使用します\", device_id)\r\n"
        }
    ]
}