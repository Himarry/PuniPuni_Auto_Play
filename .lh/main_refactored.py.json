{
    "sourceFile": "main_refactored.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1750493481591,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1750493481591,
            "name": "Commit-0",
            "content": "import tkinter as tk\r\nfrom tkinter import ttk, scrolledtext, messagebox\r\nimport cv2\r\nimport numpy as np\r\nimport subprocess\r\nimport threading\r\nimport time\r\nimport os\r\nfrom datetime import datetime\r\nimport json\r\n\r\n# 分割したモジュールをインポート\r\nfrom image_detector import ImageDetector\r\nfrom device_controller import DeviceController\r\nfrom automation_engine import AutomationEngine\r\n\r\nclass PuniPuniAutoPlayer:\r\n    def __init__(self, root):\r\n        self.root = root\r\n        self.root.title(\"妖怪ウォッチぷにぷに自動周回ソフト\")\r\n        self.root.geometry(\"800x600\")\r\n        \r\n        # 画像ファイルパス\r\n        self.image_paths = {\r\n            'boss': 'image/boss.jpg',\r\n            'play': 'image/play.png',\r\n            'puzzle': 'image/puzzle.png',\r\n            'waza_ok': 'image/waza_ok.png',\r\n            'next': 'image/next.png',\r\n            'close': 'image/close.png',\r\n            'close_mini': 'image/close_mini.png',\r\n            'stage_45': 'image/stage_45.png'\r\n        }\r\n        \r\n        # 設定\r\n        self.settings = {\r\n            'similarity_threshold': 0.8,\r\n            'tap_delay': 0.3,\r\n            'puzzle_tap_count': 2,\r\n            'check_interval': 0.1,\r\n            'screenshot_cache_time': 0.05,\r\n            'human_like_delay_min': 0.15,\r\n            'human_like_delay_max': 0.4,\r\n            'use_memory_capture': True\r\n        }\r\n        \r\n        # 分割したモジュールのインスタンスを作成\r\n        self.image_detector = ImageDetector(self.settings['similarity_threshold'])\r\n        self.device_controller = DeviceController()\r\n        self.automation_engine = AutomationEngine(self.image_paths, self.settings, self.log)\r\n        \r\n        # 変数の初期化\r\n        self.devices = []\r\n        self.running = False\r\n        \r\n        self.create_widgets()\r\n        self.refresh_devices()\r\n        \r\n    def create_widgets(self):\r\n        # メインフレーム\r\n        main_frame = ttk.Frame(self.root, padding=\"10\")\r\n        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n        \r\n        # デバイス選択フレーム\r\n        device_frame = ttk.LabelFrame(main_frame, text=\"デバイス選択\", padding=\"5\")\r\n        device_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))\r\n        \r\n        ttk.Button(device_frame, text=\"デバイス更新\", command=self.refresh_devices).grid(row=0, column=0, padx=(0, 10))\r\n        \r\n        self.device_listbox = tk.Listbox(device_frame, height=4, selectmode=tk.MULTIPLE)\r\n        self.device_listbox.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(5, 0))\r\n        \r\n        # 設定フレーム\r\n        settings_frame = ttk.LabelFrame(main_frame, text=\"設定\", padding=\"5\")\r\n        settings_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N), padx=(0, 10))\r\n        \r\n        ttk.Label(settings_frame, text=\"類似度閾値:\").grid(row=0, column=0, sticky=tk.W)\r\n        self.similarity_var = tk.DoubleVar(value=self.settings['similarity_threshold'])\r\n        ttk.Scale(settings_frame, from_=0.5, to=1.0, variable=self.similarity_var, \r\n                 orient=tk.HORIZONTAL, length=150).grid(row=0, column=1, padx=(5, 0))\r\n        ttk.Label(settings_frame, textvariable=self.similarity_var).grid(row=0, column=2, padx=(5, 0))\r\n        \r\n        ttk.Label(settings_frame, text=\"タップ間隔(秒):\").grid(row=1, column=0, sticky=tk.W)\r\n        self.delay_var = tk.DoubleVar(value=self.settings['tap_delay'])\r\n        ttk.Scale(settings_frame, from_=0.1, to=2.0, variable=self.delay_var, \r\n                 orient=tk.HORIZONTAL, length=150).grid(row=1, column=1, padx=(5, 0))\r\n        ttk.Label(settings_frame, textvariable=self.delay_var).grid(row=1, column=2, padx=(5, 0))\r\n        \r\n        ttk.Label(settings_frame, text=\"パズルタップ回数:\").grid(row=2, column=0, sticky=tk.W)\r\n        self.puzzle_count_var = tk.IntVar(value=self.settings['puzzle_tap_count'])\r\n        ttk.Spinbox(settings_frame, from_=1, to=10, textvariable=self.puzzle_count_var, \r\n                   width=10).grid(row=2, column=1, sticky=tk.W, padx=(5, 0))\r\n        \r\n        ttk.Label(settings_frame, text=\"検知間隔(秒):\").grid(row=3, column=0, sticky=tk.W)\r\n        self.check_interval_var = tk.DoubleVar(value=self.settings['check_interval'])\r\n        ttk.Scale(settings_frame, from_=0.05, to=1.0, variable=self.check_interval_var, \r\n                 orient=tk.HORIZONTAL, length=150).grid(row=3, column=1, padx=(5, 0))\r\n        ttk.Label(settings_frame, textvariable=self.check_interval_var).grid(row=3, column=2, padx=(5, 0))\r\n        \r\n        # メモリ直接取得設定\r\n        self.memory_capture_var = tk.BooleanVar(value=self.settings.get('use_memory_capture', True))\r\n        ttk.Checkbutton(settings_frame, text=\"メモリ直接取得\", variable=self.memory_capture_var).grid(row=4, column=0, columnspan=2, sticky=tk.W, pady=(5, 0))\r\n\r\n        # コントロールフレーム\r\n        control_frame = ttk.LabelFrame(main_frame, text=\"制御\", padding=\"5\")\r\n        control_frame.grid(row=1, column=1, sticky=(tk.W, tk.E, tk.N))\r\n        \r\n        self.start_button = ttk.Button(control_frame, text=\"開始\", command=self.start_automation)\r\n        self.start_button.grid(row=0, column=0, padx=(0, 5), pady=(0, 5))\r\n        \r\n        self.stop_button = ttk.Button(control_frame, text=\"停止\", command=self.stop_automation, state=tk.DISABLED)\r\n        self.stop_button.grid(row=0, column=1, pady=(0, 5))\r\n        \r\n        ttk.Button(control_frame, text=\"スクリーンショット\", command=self.take_screenshot).grid(row=1, column=0, columnspan=2, pady=(0, 5))\r\n        \r\n        ttk.Button(control_frame, text=\"メモリ診断\", command=self.run_memory_diagnostic).grid(row=2, column=0, columnspan=2, pady=(0, 5))\r\n        \r\n        ttk.Button(control_frame, text=\"画像検出テスト\", command=self.test_image_detection).grid(row=3, column=0, columnspan=2, pady=(0, 5))\r\n        \r\n        ttk.Button(control_frame, text=\"puzzle専用テスト\", command=self.test_puzzle_detection_specifically).grid(row=4, column=0, columnspan=2, pady=(0, 5))\r\n        \r\n        self.realtime_monitor_button = ttk.Button(control_frame, text=\"リアルタイム監視\", command=self.toggle_realtime_monitor)\r\n        self.realtime_monitor_button.grid(row=5, column=0, columnspan=2, pady=(0, 5))\r\n        \r\n        ttk.Button(control_frame, text=\"設定保存\", command=self.save_settings).grid(row=6, column=0, padx=(0, 5))\r\n        ttk.Button(control_frame, text=\"設定読込\", command=self.load_settings).grid(row=6, column=1)\r\n        \r\n        # ログフレーム\r\n        log_frame = ttk.LabelFrame(main_frame, text=\"ログ\", padding=\"5\")\r\n        log_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(10, 0))\r\n        \r\n        self.log_text = scrolledtext.ScrolledText(log_frame, height=15, width=80)\r\n        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\r\n        \r\n        # グリッドの重み設定\r\n        self.root.columnconfigure(0, weight=1)\r\n        self.root.rowconfigure(0, weight=1)\r\n        main_frame.columnconfigure(0, weight=1)\r\n        main_frame.columnconfigure(1, weight=1)\r\n        main_frame.rowconfigure(2, weight=1)\r\n        device_frame.columnconfigure(0, weight=1)\r\n        log_frame.columnconfigure(0, weight=1)\r\n        log_frame.rowconfigure(0, weight=1)\r\n        \r\n    def log(self, message, device_id=None):\r\n        \"\"\"ログメッセージを表示\"\"\"\r\n        timestamp = datetime.now().strftime(\"%H:%M:%S\")\r\n        if device_id:\r\n            log_message = f\"[{timestamp}] [{device_id}] {message}\\n\"\r\n        else:\r\n            log_message = f\"[{timestamp}] {message}\\n\"\r\n        \r\n        self.log_text.insert(tk.END, log_message)\r\n        self.log_text.see(tk.END)\r\n        print(log_message.strip())\r\n        \r\n    def refresh_devices(self):\r\n        \"\"\"ADBデバイスを更新\"\"\"\r\n        self.devices = self.device_controller.refresh_devices()\r\n        \r\n        # リストボックスを更新\r\n        self.device_listbox.delete(0, tk.END)\r\n        for device in self.devices:\r\n            self.device_listbox.insert(tk.END, device)\r\n        \r\n        self.log(f\"デバイス検出: {len(self.devices)}台\")\r\n        \r\n    def get_selected_devices(self):\r\n        \"\"\"選択されたデバイスを取得\"\"\"\r\n        selected_indices = self.device_listbox.curselection()\r\n        return [self.devices[i] for i in selected_indices]\r\n        \r\n    def take_screenshot(self, device_id=None, force_new=False):\r\n        \"\"\"スクリーンショットを取得（キャッシュ機能付き）\"\"\"\r\n        if not device_id:\r\n            devices = self.get_selected_devices()\r\n            if not devices:\r\n                messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n                return\r\n            device_id = devices[0]\r\n        \r\n        # device_controllerのtake_screenshotメソッドを使用\r\n        use_memory = self.memory_capture_var.get() if hasattr(self, 'memory_capture_var') else self.settings.get('use_memory_capture', True)\r\n        screenshot = self.device_controller.take_screenshot(device_id, force_new, use_memory)\r\n        \r\n        if screenshot is not None:\r\n            self.log(f\"スクリーンショット取得成功\", device_id)\r\n            return screenshot\r\n        else:\r\n            self.log(f\"スクリーンショット取得失敗\", device_id)\r\n            return None\r\n            \r\n    def find_image_on_screen_optimized(self, template_path, device_id, threshold=None):\r\n        \"\"\"最適化された画像検索（メモリ直接対応）\"\"\"\r\n        if threshold is None:\r\n            threshold = self.similarity_var.get()\r\n            \r\n        # スクリーンショットを取得\r\n        screenshot = self.take_screenshot(device_id)\r\n        if screenshot is None:\r\n            return None\r\n        \r\n        # image_detectorを使用して画像検索\r\n        return self.image_detector.find_image_on_screen_optimized(template_path, screenshot, threshold)\r\n            \r\n    def find_multiple_images_on_screen_optimized(self, template_paths, device_id, threshold=None):\r\n        \"\"\"最適化された複数画像同時検索（メモリ直接対応）\"\"\"\r\n        if threshold is None:\r\n            threshold = self.similarity_var.get()\r\n            \r\n        # スクリーンショットを取得\r\n        screenshot = self.take_screenshot(device_id)\r\n        if screenshot is None:\r\n            return {}\r\n        \r\n        # image_detectorを使用して複数画像検索\r\n        return self.image_detector.find_multiple_images_on_screen_optimized(template_paths, screenshot, threshold)\r\n        \r\n    def smart_tap_screen(self, x, y, device_id, tap_type=\"normal\"):\r\n        \"\"\"スマートタップ機能（タップ種類に応じて遅延を調整）\"\"\"\r\n        # device_controllerのsmart_tap_screenメソッドを使用\r\n        delay_multiplier = self.delay_var.get() if hasattr(self, 'delay_var') else self.settings['tap_delay']\r\n        success = self.device_controller.smart_tap_screen(x, y, device_id, tap_type, delay_multiplier)\r\n        \r\n        if success:\r\n            self.log(f\"タップ: ({x}, {y}) [{tap_type}]\", device_id)\r\n        else:\r\n            self.log(f\"タップ失敗: ({x}, {y}) [{tap_type}]\", device_id)\r\n        \r\n        return success\r\n        \r\n    def start_automation(self):\r\n        \"\"\"自動化開始\"\"\"\r\n        selected_devices = self.get_selected_devices()\r\n        if not selected_devices:\r\n            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n            return\r\n        \r\n        # 画像ファイルの確認\r\n        missing_files = []\r\n        for name, path in self.image_paths.items():\r\n            if not os.path.exists(path):\r\n                missing_files.append(path)\r\n        \r\n        if missing_files:\r\n            messagebox.showerror(\"エラー\", f\"画像ファイルが見つかりません:\\n\" + \"\\n\".join(missing_files))\r\n            return\r\n        \r\n        # 設定を更新\r\n        self.settings['similarity_threshold'] = self.similarity_var.get()\r\n        self.settings['tap_delay'] = self.delay_var.get()\r\n        self.settings['puzzle_tap_count'] = self.puzzle_count_var.get()\r\n        self.settings['check_interval'] = self.check_interval_var.get()\r\n        self.settings['use_memory_capture'] = self.memory_capture_var.get()\r\n        \r\n        # automation_engineに設定を更新\r\n        self.automation_engine.update_settings(self.settings)\r\n        \r\n        # automation_engineを使用して自動化開始\r\n        self.automation_engine.start_automation(selected_devices)\r\n        \r\n        self.running = True\r\n        self.start_button.config(state=tk.DISABLED)\r\n        self.stop_button.config(state=tk.NORMAL)\r\n        \r\n        self.log(\"自動化開始\")\r\n            \r\n    def stop_automation(self):\r\n        \"\"\"自動化停止\"\"\"\r\n        self.running = False\r\n        \r\n        # automation_engineの停止\r\n        self.automation_engine.stop_automation()\r\n        \r\n        self.start_button.config(state=tk.NORMAL)\r\n        self.stop_button.config(state=tk.DISABLED)\r\n        \r\n        self.log(\"全デバイスの自動化を停止\")\r\n        \r\n    def save_settings(self):\r\n        \"\"\"設定保存\"\"\"\r\n        settings = {\r\n            'similarity_threshold': self.similarity_var.get(),\r\n            'tap_delay': self.delay_var.get(),\r\n            'puzzle_tap_count': self.puzzle_count_var.get(),\r\n            'check_interval': self.check_interval_var.get(),\r\n            'use_memory_capture': self.memory_capture_var.get()\r\n        }\r\n        \r\n        try:\r\n            with open('settings.json', 'w', encoding='utf-8') as f:\r\n                json.dump(settings, f, indent=2, ensure_ascii=False)\r\n            self.log(\"設定を保存しました\")\r\n        except Exception as e:\r\n            self.log(f\"設定保存エラー: {str(e)}\")\r\n            \r\n    def load_settings(self):\r\n        \"\"\"設定読込\"\"\"\r\n        try:\r\n            with open('settings.json', 'r', encoding='utf-8') as f:\r\n                settings = json.load(f)\r\n            \r\n            self.similarity_var.set(settings.get('similarity_threshold', 0.8))\r\n            self.delay_var.set(settings.get('tap_delay', 0.3))\r\n            self.puzzle_count_var.set(settings.get('puzzle_tap_count', 2))\r\n            self.check_interval_var.set(settings.get('check_interval', 0.1))\r\n            self.memory_capture_var.set(settings.get('use_memory_capture', True))\r\n            \r\n            self.log(\"設定を読み込みました\")\r\n        except FileNotFoundError:\r\n            self.log(\"設定ファイルが見つかりません\")\r\n        except Exception as e:\r\n            self.log(f\"設定読込エラー: {str(e)}\")\r\n\r\n    def run_memory_diagnostic(self):\r\n        \"\"\"メモリ診断テスト\"\"\"\r\n        selected_devices = self.get_selected_devices()\r\n        if not selected_devices:\r\n            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n            return\r\n        \r\n        device_id = selected_devices[0]\r\n        \r\n        # device_controllerを使用してメモリ診断\r\n        compatibility = self.device_controller.check_device_compatibility(device_id)\r\n        \r\n        if compatibility.get('memory_capture_supported', False):\r\n            self.log(\"メモリ直接取得: 対応\", device_id)\r\n        else:\r\n            self.log(\"メモリ直接取得: 非対応 - ファイル方式を使用\", device_id)\r\n\r\n    def test_image_detection(self):\r\n        \"\"\"画像検出テスト\"\"\"\r\n        selected_devices = self.get_selected_devices()\r\n        if not selected_devices:\r\n            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n            return\r\n        \r\n        device_id = selected_devices[0]\r\n        self.log(\"=== 画像検出テスト開始 ===\", device_id)\r\n        \r\n        for name, path in self.image_paths.items():\r\n            if not os.path.exists(path):\r\n                self.log(f\"❌ ファイルが存在しません: {path}\", device_id)\r\n                continue\r\n            \r\n            # image_detectorを使用してテスト\r\n            result = self.find_image_on_screen_optimized(path, device_id)\r\n            if result:\r\n                self.log(f\"✅ 検出成功: {name} at {result}\", device_id)\r\n            else:\r\n                self.log(f\"❌ 検出失敗: {name}\", device_id)        \r\n        self.log(\"=== テスト終了 ===\", device_id)\r\n    \r\n    def test_puzzle_detection_specifically(self):\r\n        \"\"\"puzzle.png専用テスト\"\"\"\r\n        selected_devices = self.get_selected_devices()\r\n        if not selected_devices:\r\n            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n            return\r\n        \r\n        device_id = selected_devices[0]\r\n        self.log(\"=== puzzle.png専用テスト ===\", device_id)\r\n        \r\n        # image_detectorの強化検出機能を使用\r\n        screenshot = self.take_screenshot(device_id)\r\n        if screenshot is not None:\r\n            result = self.image_detector.find_puzzle_with_enhanced_detection(\r\n                self.image_paths['puzzle'], \r\n                screenshot\r\n            )\r\n            \r\n            if result:\r\n                self.log(f\"✅ puzzle検出成功: {result}\", device_id)\r\n            else:\r\n                self.log(\"❌ puzzle検出失敗\", device_id)\r\n        else:\r\n            self.log(\"❌ スクリーンショット取得失敗\", device_id)\r\n        \r\n        self.log(\"=== テスト終了 ===\", device_id)\r\n\r\n    def toggle_realtime_monitor(self):\r\n        \"\"\"リアルタイム監視の開始/停止\"\"\"\r\n        selected_devices = self.get_selected_devices()\r\n        if not selected_devices:\r\n            messagebox.showwarning(\"警告\", \"デバイスを選択してください\")\r\n            return\r\n        \r\n        # automation_engineのリアルタイム監視機能を使用\r\n        if not hasattr(self.automation_engine, 'realtime_monitoring') or not self.automation_engine.realtime_monitoring:\r\n            self.automation_engine.start_realtime_monitor(selected_devices[0])\r\n            self.realtime_monitor_button.config(text=\"監視停止\")\r\n            self.log(\"リアルタイム監視開始\")\r\n        else:\r\n            self.automation_engine.stop_realtime_monitor()\r\n            self.realtime_monitor_button.config(text=\"リアルタイム監視\")\r\n            self.log(\"リアルタイム監視停止\")\r\n\r\ndef main():\r\n    root = tk.Tk()\r\n    app = PuniPuniAutoPlayer(root)\r\n    \r\n    def on_closing():\r\n        if app.running:\r\n            app.stop_automation()\r\n        if hasattr(app.automation_engine, 'realtime_monitoring') and app.automation_engine.realtime_monitoring:\r\n            app.automation_engine.stop_realtime_monitor()\r\n        root.destroy()\r\n    \r\n    root.protocol(\"WM_DELETE_WINDOW\", on_closing)\r\n    root.mainloop()\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"
        }
    ]
}